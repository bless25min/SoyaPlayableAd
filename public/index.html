<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>交易技巧模擬學習挑戰 (V13.1 - Latency Optimized)</title>
    <style>
        /* CSS is unchanged */
        :root {
            --color-bg: #f5f7fa;
            --color-panel-bg: #ffffff;
            --color-border: #e0e3eb;
            --color-text-primary: #333333;
            --color-text-secondary: #7f8c8d;
            --color-primary: #3498db;
            --color-primary-dark: #2980b9;
            --color-success: #2ecc71;
            --color-danger: #e74c3c;
            --color-neutral-bg: #95a5a6;
            --color-warning: #f1c40f;
            --font-main: 'Helvetica Neue', Arial, sans-serif;
            --shadow-main: 0 4px 12px rgba(0, 0, 0, 0.05);
            --radius-main: 8px;
            --chart-bg: #ffffff;
            --chart-grid: #f0f0f0;
            --chart-date-separator: #cccccc;
            --chart-crosshair: #777777;
            --color-bull: #26a69a;
            --color-bear: #ef5350;
            --side-panel-width: 320px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: var(--font-main); background-color: var(--color-bg); color: var(--color-text-primary); display: flex; flex-direction: column; height: 100dvh; @supports not (height: 100dvh) { height: 100vh; } overflow: hidden; }
        .header { background-color: var(--color-panel-bg); padding: 8px 15px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); z-index: 10; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; flex-wrap: wrap; gap: 5px 15px; }
        .main-container-v9 { display: grid; grid-template-rows: minmax(200px, 1fr) auto; flex: 1; overflow: hidden; min-height: 0; }
        .chart-container-v9 { display: flex; flex-direction: column; overflow: hidden; padding: 10px; }
        .bottom-content-v9 { background-color: var(--color-panel-bg); border-top: 1px solid var(--color-border); display: flex; flex-direction: column; }
        #tabPositionsHistory { max-height: 50vh; }
        .bottom-nav-bar-v9 { background-color: var(--color-panel-bg); flex-shrink: 0; z-index: 30; display: flex; }
        .nav-btn-v9 { flex: 1; padding: 12px 10px; text-align: center; cursor: pointer; background: none; border: none; font-size: 16px; color: var(--color-text-secondary); transition: color 0.2s, background-color 0.2s; }
        .nav-btn-v9.active { color: var(--color-primary); font-weight: bold; box-shadow: inset 0 2px 0 0 var(--color-primary); }
        .nav-btn-v9:hover { background-color: var(--color-bg); }
        .tab-content-v9 { display: none; flex-direction: column; overflow: hidden; }
        .tab-content-v9.active { display: flex; }
        #tabOrder { padding: 10px; gap: 8px; }
        .footer-ad { background-color: var(--color-panel-bg); color: var(--color-text-secondary); text-align: center; padding: 5px 10px; font-size: 12px; border-top: 1px solid var(--color-border); flex-shrink: 0; padding-bottom: max(5px, env(safe-area-inset-bottom)); }
        .footer-ad a { color: inherit; text-decoration: none; }
        .footer-ad a:hover { text-decoration: underline; }
        @media (min-width: 901px) {
            .main-container-v9 { display: flex; flex-direction: row; grid-template-rows: unset; }
            .chart-container-v9 { padding-right: 0; flex: 1; }
            .bottom-content-v9 { width: var(--side-panel-width); height: auto; border-top: none; border-left: 1px solid var(--color-border); padding: 10px 0; flex-shrink: 0; }
            #tabPositionsHistory { max-height: none; flex: 1; }
            .bottom-nav-bar-v9 { box-shadow: none; border-top: none; border-bottom: 1px solid var(--color-border); }
            .nav-btn-v9 { padding: 12px; font-size: 14px; background-color: var(--color-bg); }
            .nav-btn-v9.active { background-color: var(--color-panel-bg); box-shadow: inset 0 -2px 0 0 var(--color-primary); }
            #tabOrder { padding: 20px; gap: 15px; justify-content: flex-start; }
        }
        @media (max-width: 900px) {
            .chart-container-v9 { padding: 5px; }
            .header { padding: 6px 10px; }
            .hud, .hud-right { gap: 10px; }
            .hud-value { font-size: 14px; }
            .progress-container { width: 80px; }
        }
        .hud { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .hud-item { display: flex; flex-direction: column; }
        .hud-label { font-size: 11px; color: var(--color-text-secondary); }
        .hud-value { font-size: 15px; font-weight: bold; }
        #hud-pl.positive { color: var(--color-success); }
        #hud-pl.negative { color: var(--color-danger); }
        .hud-right { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .progress-container { width: 120px; }
        .progress-bar { height: 6px; background-color: var(--color-border); border-radius: 3px; overflow: hidden; margin-top: 3px; }
        .progress-fill { height: 100%; width: 0%; background-color: var(--color-primary); transition: width 0.3s ease; }
        .chart-wrap { position: relative; flex: 1; background-color: var(--chart-bg); border-radius: var(--radius-main); box-shadow: var(--shadow-main); overflow: hidden; cursor: crosshair; touch-action: none; }
        #chartCanvas { position: absolute; top: 0; left: 0; }
        .chart-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .position-line { position: absolute; left: 0; display: flex; align-items: center; pointer-events: none; transition: opacity 0.2s; }
        .position-line-dash { flex: 1; height: 1px; border-top-style: dashed; border-top-width: 1px; }
        .position-label { padding: 3px 6px; font-size: 12px; border-radius: 3px; color: white; font-weight: bold; margin-left: 5px; margin-right: 5px; white-space: nowrap; }
        .position-pl { padding: 3px 6px; font-size: 12px; border-radius: 3px; background-color: rgba(255, 255, 255, 0.9); margin-right: 5px; font-weight: bold; box-shadow: var(--shadow-main); }
        .controls-overlay-container { position: absolute; top: 10px; left: 10px; right: 10px; z-index: 5; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        .controls { display: flex; align-items: center; gap: 10px; pointer-events: auto; background-color: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); padding: 8px; border-radius: var(--radius-main); box-shadow: var(--shadow-main); transition: opacity 0.3s ease, background-color 0.3s ease; }
        .controls-collapsed { opacity: 0.6; background-color: rgba(255, 255, 255, 0.5); backdrop-filter: blur(2px); }
        .controls:hover, .controls:focus-within { opacity: 1; background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); }
        .collapsible-controls { display: flex; gap: 10px; transition: max-width 0.4s ease, opacity 0.4s ease, margin-left 0.4s ease, padding-left 0.4s ease, border-left-width 0.4s ease; overflow: hidden; max-width: 500px; opacity: 1; }
        .controls-left:not(.controls-collapsed) .collapsible-controls { border-left: 1px solid var(--color-border); padding-left: 10px; margin-left: 5px; }
        .controls-collapsed .collapsible-controls { max-width: 0; opacity: 0; margin-left: 0; padding-left: 0; border-left-width: 0; }
        .btn-toggle-controls { font-size: 12px; padding: 4px 8px; min-height: 28px; }
        .btn { padding: 8px 12px; border: none; border-radius: var(--radius-main); cursor: pointer; font-weight: bold; transition: transform 0.1s, background-color 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 5px; user-select: none; line-height: 1.2; min-height: 32px; }
        .btn:hover:not(:disabled) { opacity: 0.9; }
        .btn:active:not(:disabled) { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: default; transform: scale(1); }
        .btn-primary { background-color: var(--color-primary); color: white; }
        .btn-secondary { background-color: var(--color-border); color: var(--color-text-primary); }
        .btn-danger { background-color: var(--color-danger); color: white; }
        .btn-neutral { background-color: var(--color-neutral-bg); color: white; }
        .btn-end-game { background-color: var(--color-panel-bg); color: var(--color-danger); border: 1px solid var(--color-danger); }
        .btn-end-game:hover:not(:disabled) { background-color: var(--color-danger); color: white; }
        .speed-selector { display: flex; border: 1px solid var(--color-border); border-radius: var(--radius-main); overflow: hidden; }
        .speed-btn { padding: 8px 10px; background-color: var(--color-panel-bg); border: none; cursor: pointer; font-size: 14px; }
        .speed-btn.active { background-color: var(--color-primary); color: white; }
        .speed-btn:not(:last-child) { border-right: 1px solid var(--color-border); }
        .order-controls { display: flex; gap: 15px; flex-direction: column; align-items: stretch; }
        .input-group-horizontal { display: flex; align-items: center; gap: 10px; }
        .input-group-horizontal label { font-size: 14px; color: var(--color-text-secondary); white-space: nowrap; width: 50px; }
        .input-field { padding: 8px 10px; border: 1px solid var(--color-border); font-size: 16px; text-align: center; width: auto; flex: 1; height: 36px; -moz-appearance: textfield; border-radius: var(--radius-main); }
        .input-field.scrubbable { cursor: ew-resize; }
        .input-field::-webkit-outer-spin-button, .input-field::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .trade-actions { display: flex; gap: 10px; justify-content: center; }
        .btn-trade { padding: 12px 10px; font-size: 18px; color: white; flex: 1; }
        .btn-buy { background-color: var(--color-bull); }
        .btn-sell { background-color: var(--color-bear); }
        .order-info-bar { display: flex; justify-content: center; align-items: center; border-top: 1px solid var(--color-border); padding-top: 8px; margin-top: 5px; }
        .estimates { font-size: 12px; color: var(--color-text-secondary); display: flex; gap: 15px; }
        @media (max-width: 900px) {
            .order-controls { flex-direction: row; gap: 10px; justify-content: space-between; align-items: center; }
            .input-group-horizontal label { width: auto; }
            .input-field { width: 80px; font-size: 14px; padding: 6px 5px; height: 32px; }
            .btn-trade { font-size: 16px; padding: 10px 8px; }
            .order-info-bar { padding-top: 6px; margin-top: 0; justify-content: center; }
            .estimates { gap: 10px; font-size: 11px; }
        }
        .challenge-info { display: none; }
        .panel-tabs { display: flex; border-bottom: 1px solid var(--color-border); flex-shrink: 0; }
        .tab-btn { flex: 1; padding: 12px; text-align: center; cursor: pointer; background-color: var(--color-bg); border: none; font-weight: bold; }
        .tab-btn.active { background-color: var(--color-panel-bg); color: var(--color-primary); border-bottom: 2px solid var(--color-primary); }
        .tabs-wrapper { flex: 1; overflow: hidden; display: flex; flex-direction: column; min-height: 0; }
        .tab-content { padding: 15px; display: none; flex-direction: column; gap: 15px; flex-grow: 1; overflow-y: auto; }
        .tab-content.active { display: flex; }
        .positions-list, .history-list { display: flex; flex-direction: column; gap: 10px; flex: 1; }
        .empty-state { display: flex; justify-content: center; align-items: center; text-align: center; color: var(--color-text-secondary); font-size: 14px; padding: 20px; flex: 1; height: 100%; }
        .trade-item { background-color: var(--color-bg); border: 1px solid var(--color-border); border-radius: var(--radius-main); padding: 10px; font-size: 14px; }
        .trade-header { display: flex; justify-content: space-between; margin-bottom: 8px; font-weight: bold; }
        .trade-type.BUY { color: var(--color-bull); }
        .trade-type.SELL { color: var(--color-bear); }
        .trade-details { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }
        .trade-detail-label { font-size: 12px; color: var(--color-text-secondary); }
        .trade-actions-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; }
        .btn-small { padding: 5px 10px; font-size: 12px; }
        @media (max-width: 900px) {
            .controls-overlay-container { top: 5px; left: 5px; right: 5px; align-items: flex-start; }
            .controls { padding: 5px; gap: 5px; }
            .controls-left { flex-direction: column; align-items: stretch; }
            .collapsible-controls { flex-direction: column; transition: max-height 0.4s ease, opacity 0.4s ease, margin-top 0.4s ease, padding-top 0.4s ease, border-top-width 0.4s ease; max-width: none; max-height: 500px; }
            .controls-left:not(.controls-collapsed) .collapsible-controls { padding-left: 0; margin-left: 0; border-left: none; border-top: 1px solid var(--color-border); padding-top: 5px; margin-top: 5px; }
            .controls-collapsed .collapsible-controls { max-width: none; max-height: 0; opacity: 0; margin-top: 0; padding-top: 0; border-top-width: 0; }
            .speed-selector { display: flex; }
            .speed-btn { flex: 1; }
            .btn { font-size: 12px; padding: 6px 8px; min-height: 28px; }
        }
        @media (max-width: 600px) {
            .header { padding: 4px 8px; gap: 5px; }
            .hud, .hud-right { gap: 8px; }
            .hud-label { font-size: 10px; }
            .hud-value { font-size: 13px; }
            @media (max-width: 380px) { .hud .hud-item:first-child { display: none; } }
            .progress-container { width: auto; flex: 1; max-width: 120px; }
            #tabOrder { padding: 5px; gap: 5px; }
            .order-controls { gap: 5px; }
            .input-group-horizontal label { font-size: 12px; }
            .input-field { width: 60px; font-size: 12px; padding: 5px 3px; height: 28px; }
            .trade-actions { gap: 5px; }
            .btn-trade { font-size: 14px; padding: 8px 3px; }
            .order-info-bar { padding-top: 4px; }
            .estimates { font-size: 10px; gap: 8px; }
        }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--color-panel-bg); padding: 30px; border-radius: var(--radius-main); box-shadow: var(--shadow-main); max-width: 550px; width: 90%; text-align: center; transform: scale(0.95); transition: transform 0.3s ease; max-height: 90vh; overflow-y: auto; }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .modal-title { font-size: 24px; margin-bottom: 15px; font-weight: bold; }
        .modal-body { font-size: 16px; margin-bottom: 25px; line-height: 1.5; }
        .cta-button { background-color: var(--color-success); color: white; padding: 15px 30px; font-size: 18px; letter-spacing: 1px; text-decoration: none; }
        .tutorial-highlight { position: absolute; border: 3px dashed var(--color-primary); border-radius: var(--radius-main); box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6); z-index: 1001; pointer-events: none; transition: top 0.3s, left 0.3s, width 0.3s, height 0.3s; }
        .tutorial-message { position: absolute; background-color: var(--color-primary); color: white; padding: 15px; border-radius: var(--radius-main); max-width: 300px; z-index: 1002; box-shadow: var(--shadow-main); transition: top 0.3s, left 0.3s; }
        .achievements-section { margin-top: 25px; border-top: 1px solid var(--color-border); padding-top: 15px; text-align: left; }
        .achievements-list { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; list-style-type: none; padding: 0; margin-top: 10px; }
        @media (max-width: 500px) { .achievements-list { grid-template-columns: 1fr; } }
        .achievement-item { background-color: var(--color-bg); border: 1px solid var(--color-border); border-radius: var(--radius-main); padding: 10px; display: flex; align-items: center; gap: 10px; font-size: 14px; }
        .achievement-icon { font-size: 20px; }
        #notification-container { position: fixed; top: 20px; right: 20px; z-index: 1010; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        @media (max-width: 900px) { #notification-container { top: 60px; right: 10px; left: 10px; align-items: center; } }
        @media (max-width: 600px) { #notification-container { top: 85px; } }
        .notification-toast { background-color: var(--color-primary-dark); color: white; padding: 15px 20px; border-radius: var(--radius-main); box-shadow: var(--shadow-main); display: flex; flex-direction: column; align-items: flex-start; gap: 5px; max-width: 350px; width: 100%; opacity: 0; transform: translateY(-20px); transition: opacity 0.5s, transform 0.5s; }
        .notification-toast.show { opacity: 1; transform: translateY(0); }
        .hidden { display: none !important; }
        .loader-wrap { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--color-bg); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; gap: 20px; text-align: center; padding: 20px; }
        .loading-spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .file-upload-prompt { display: none !important; }
    </style>
</head>
<body>
    <!-- HTML structure is unchanged -->
    <div class="loader-wrap" id="loader"> <div id="loader-status"> <div class="loading-spinner"></div> <p>正在連接伺服器並初始化模擬環境...</p> </div> </div> <div id="notification-container"></div> <header class="header"> <div class="hud"> <div class="hud-item"> <span class="hud-label">模擬日期</span> <span class="hud-value" id="hud-date">--/--/-- --:--</span> </div> <div class="hud-item"> <span class="hud-label">虛擬帳戶淨值</span> <span class="hud-value" id="hud-equity">$10000.00</span> </div> <div class="hud-item"> <span class="hud-label">浮動損益</span> <span class="hud-value" id="hud-pl">$0.00</span> </div> </div> <div class="hud-right"> <div class="hud-item"> <span class="hud-label">花費時間</span> <span class="hud-value" id="hud-timer">00:00</span> </div> <div class="hud-item progress-container"> <span class="hud-label">挑戰進度</span> <div class="progress-bar"> <div class="progress-fill" id="hud-progress"></div> </div> </div> </div> </header> <div class="main-container-v9"> <div class="chart-container-v9"> <div class="chart-wrap" id="chartWrap"> <div class="controls-overlay-container"> <div class="controls controls-left controls-collapsed" id="chartControls"> <div class="collapsible-controls"> <button class="btn btn-primary" id="btnPlayPause">▶️ 播放</button> <button class="btn btn-secondary" id="btnStepForward">➡️ 逐K前進</button> <div class="speed-selector" id="speedSelector"> <button class="speed-btn active" data-speed="1">1x</button> <button class="speed-btn" data-speed="5">5x</button> <button class="speed-btn" data-speed="20">20x</button> <button class="speed-btn" data-speed="40">40x</button> </div> <button class="btn btn-secondary" id="btnZoomIn">🔍+</button> <button class="btn btn-secondary" id="btnZoomOut">🔍-</button> </div> <button class="btn btn-secondary btn-toggle-controls" id="btnToggleControls">展開設定</button> </div> <div class="controls controls-right"> <button class="btn btn-end-game" id="btnEndGame">結束挑戰</button> </div> </div> <canvas id="chartCanvas"></canvas> <div class="chart-overlay" id="chartOverlay"></div> </div> </div> <div class="bottom-content-v9" id="bottomContent"> <nav class="bottom-nav-bar-v9" id="bottomNavBar"> <button class="nav-btn-v9 active" data-target="tabOrder">下單</button> <button class="nav-btn-v9" data-target="tabPositionsHistory">倉位/紀錄 (<span id="positionsCountNav">0</span>)</button> </nav> <div class="tab-content-v9 active" id="tabOrder"> <div class="order-controls"> <div class="input-group-horizontal"> <label for="inputSL">SL</label> <input type="number" class="input-field scrubbable" id="inputSL" placeholder="價格" step="0.1" min="0" data-scrub-step="0.5"> </div> <div class="input-group-horizontal"> <label for="inputLots">手數</label> <input type="number" class="input-field scrubbable" id="inputLots" value="0.10" step="0.01" min="0.01" data-scrub-step="0.05"> </div> <div class="input-group-horizontal"> <label for="inputTP">TP</label> <input type="number" class="input-field scrubbable" id="inputTP" placeholder="價格" step="0.1" min="0" data-scrub-step="0.5"> </div> </div> <div class="trade-actions"> <button class="btn btn-trade btn-sell" id="btnSell">賣出</button> <button class="btn btn-trade btn-neutral" id="btnCloseAllGlobal">全部平倉</button> <button class="btn btn-trade btn-buy" id="btnBuy">買入</button> </div> <div class="order-info-bar"> <div class="estimates"> <span id="estimateSL"></span> <span id="estimateTP"></span> </div> </div> </div> <div class="tab-content-v9" id="tabPositionsHistory"> <div class="challenge-info" id="challengeInfo"> <h4>🏆 30天交易模擬挑戰</h4> <p>從隨機歷史日期開始，在一個月內盡力提升交易技巧與模擬績效！</p> </div> <div class="panel-tabs"> <button class="tab-btn active" data-target="tabPositions">持倉 (<span id="positionsCount">0</span>)</button> <button class="tab-btn" data-target="tabHistory">紀錄</button> </div> <div class="tabs-wrapper"> <div class="tab-content active" id="tabPositions"> <div class="positions-list" id="positionsList"> <div class="empty-state" id="emptyPositions">目前沒有持倉。</div> </div> </div> <div class="tab-content" id="tabHistory"> <div class="history-list" id="historyList"> <div class="empty-state" id="emptyHistory">還沒有交易紀錄。</div> </div> </div> </div> </div> </div> </div> <footer class="footer-ad"> 本模擬遊戲由 <a href="https://www.massenlighten.com" target="_blank">眾曜智庫</a> 提供用於教學目的 </footer> <div class="modal-overlay" id="eventModal"> <div class="modal-content"> <h2 class="modal-title" id="eventTitle">⚠️ 重大財經事件</h2> <div class="modal-body" id="eventBody" style="text-align: left;"></div> <button class="btn btn-primary" id="eventContinueBtn">繼續模擬</button> </div> </div> <div class="modal-overlay" id="endGameModal"> <div class="modal-content"> <h2 class="modal-title">🎉 挑戰結束！</h2> <div class="modal-body" style="text-align: center;"> <p>您的最終模擬成績：</p> <h1 id="finalScore" style="font-size: 36px; margin: 10px 0;">$10000.00</h1> <p id="finalRoR" style="font-size: 20px;"></p> <p id="finalTime" style="font-size: 16px; color: var(--color-text-secondary);"></p> <div id="endGameStats"></div> <div class="achievements-section" id="achievementsSection"> <h3>🏆 已解鎖成就</h3> <ul class="achievements-list" id="achievementsList"></ul> </div> </div> <a href="https://www.massenlighten.com/soya%E5%A5%B3%E7%A5%9E" target="_blank" class="btn cta-button" id="ctaButton">了解更多交易知識</a> <button class="btn btn-secondary" id="restartButton" style="margin-top: 15px;">重新挑戰</button> </div> </div> <div class="tutorial-highlight hidden" id="tutorialHighlight"></div> <div class="tutorial-message hidden" id="tutorialMessage"> <p id="tutorialText"></p> <button class="btn btn-small" id="tutorialNextBtn" style="margin-top: 10px; background-color: white; color: var(--color-primary);">下一步</button> </div>

    <script>
        // ============================================================================
        // Trading Simulator Frontend (V13.1 - Latency Optimized)
        // ============================================================================

        const CONFIG = { TICK_INTERVAL: 500, CHART_PADDING: { top: 20, right: 60, bottom: 30, left: 10 }, CANDLE_WIDTH_DEFAULT: 8, CANDLE_SPACING: 3, CONTRACT_SIZE: 100, INITIAL_BALANCE: 10000, MIN_VISIBLE_CANDLES: 10, MAX_VISIBLE_CANDLES: 200, };
        const ACHIEVEMENTS = { FIRST_TRADE: { title: "模擬初體驗", description: "完成了第一筆模擬交易。", icon: "🎓" }, BIG_WIN: { title: "漂亮的操作", description: "單筆模擬交易獲得顯著虛擬收益。(>$3000)", icon: "🎯" }, BIG_LOSS: { title: "寶貴的經驗", description: "從大幅虛擬虧損中學習風險管理的重要性。(>$3000)", icon: "💡" }, WIN_STREAK_3: { title: "連戰連捷", description: "連續三次模擬交易獲得虛擬收益。", icon: "⭐" }, LOSS_STREAK_3: { title: "需要冷靜", description: "連續三次模擬交易出現虛擬虧損，建議重新審視策略。", icon: "🤔" }, HOLD_LOSS_7D: { title: "長期觀察", description: "持有處於虛擬虧損狀態的部位超過7天。", icon: "⏳" }, HOLD_WIN_7D: { title: "趨勢跟隨者", description: "成功持有一個處於虛擬收益狀態的部位超過7天。", icon: "📈" }, TRADER_10: { title: "積極練習", description: "累積完成了10筆模擬交易。", icon: "🔄" }, QUICK_DRAW: { title: "短線高手", description: "在1小時內完成一筆有虛擬收益的模擬交易。", icon: "⚡" }, DOUBLE_UP: { title: "模擬績效卓越", description: "虛擬帳戶淨值達到初始資金的兩倍。(>$20000)", icon: "🏆" }, MARGIN_CALL: { title: "風險警示", description: "虛擬帳戶淨值曾低於$2000，請注意風險控管。", icon: "⚠️" }, };
        const state = { gameData: [], isLoading: true, isPlaying: false, isEnded: false, speedMultiplier: 1, currentIndex: 0, barAnimationProgress: 0, equity: CONFIG.INITIAL_BALANCE, floatingPL: 0, openPositions: [], tradeHistory: [], performanceFeedback: null, wasPlayingBeforeEvent: false, nextTickPromise: null, chart: { canvas: null, ctx: null, width: 0, height: 0, viewStartIndex: 0, viewEndIndex: 0, minPrice: 0, maxPrice: 0, candleWidth: CONFIG.CANDLE_WIDTH_DEFAULT, candleSpacing: CONFIG.CANDLE_SPACING, isDragging: false, dragStartX: 0, dragStartY: 0, dragStartScroll: 0, scrollOffset: 0, isCrosshairPinned: false, pinnedCrosshairPos: { x: 0, y: 0 }, draggedLineType: null, pinchStartDistance: 0, pinchStartCandleWidth: 0, isPinching: false, }, mouse: { x: -1, y: -1, isOverChart: false }, isMobile: false, tutorialActive: false, tutorialCompletedOnce: false, gameStartTime: null, elapsedTime: 0, timerIntervalId: null, unlockedAchievements: new Set(), achievementStats: { consecutiveWins: 0, consecutiveLosses: 0, maxEquity: CONFIG.INITIAL_BALANCE, minEquity: CONFIG.INITIAL_BALANCE }, };
        const DOM = {};

        async function apiRequest(endpoint, options = {}) {
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    const errData = await response.json().catch(() => ({ error: "伺服器發生未知錯誤" }));
                    throw new Error(errData.error || `HTTP Error ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`API request to ${endpoint} failed:`, error);
                alert(`與伺服器通訊失敗: ${error.message}`);
                throw error;
            }
        }

        function init() { state.isMobile = window.innerWidth <= 900 || 'ontouchstart' in window || navigator.maxTouchPoints > 0; cacheDOMElements(); setupEventListeners(); initChart(); startGame(); }

        async function startGame() {
            DOM.endGameModal.classList.remove('active');
            DOM.loader.classList.remove('hidden');
            resetState();
            try {
                const data = await apiRequest('/api/start', { method: 'POST' });
                state.gameData = data.gameData;
                state.currentIndex = data.startIndex;
                state.equity = data.initialBalance;
                const initialVisibleCandles = calculateVisibleCandles();
                state.currentIndex = Math.min(Math.floor(initialVisibleCandles * 0.8), state.gameData.length - 1);
                state.isLoading = false;
                DOM.loader.classList.add('hidden');
                startTimer();
                updateUI();
                requestAnimationFrame(draw);
                if (!state.tutorialCompletedOnce) {
                    startTutorial();
                }
            } catch (error) {
                DOM.loader.querySelector('p').textContent = '無法啟動遊戲，請重新整理頁面。';
            }
        }

        let lastTickTime = 0, animationFrameId;
        async function gameLoop(timestamp) {
            if (!state.isPlaying || state.isEnded) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // Pre-fetch the next tick as soon as the current one begins processing.
            if (!state.nextTickPromise) {
                state.nextTickPromise = apiRequest('/api/tick', { method: 'POST' });
            }

            const effectiveInterval = CONFIG.TICK_INTERVAL / state.speedMultiplier;
            if (lastTickTime === 0) lastTickTime = timestamp;
            const deltaTime = timestamp - lastTickTime;

            if (deltaTime > 0) {
                const progressIncrement = deltaTime / effectiveInterval;
                state.barAnimationProgress = Math.min(1, state.barAnimationProgress + progressIncrement);
                updateAccountDisplay();
                updatePositionProfits();

                if (state.barAnimationProgress >= 1) {
                    try {
                        const data = await state.nextTickPromise;
                        state.nextTickPromise = null; // Consume the promise
                        handleTickData(data);
                        state.barAnimationProgress = 0;
                        if (state.isEnded) {
                            endGame();
                            return;
                        }
                        if (state.chart.scrollOffset > 0) state.chart.scrollOffset++;
                    } catch (error) {
                        togglePlayPause();
                    }
                }
                lastTickTime = timestamp;
            }
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        async function stepForward() {
            if (state.isPlaying || state.isEnded) return;
            // Cancel any in-flight pre-fetch if user takes manual control
            state.nextTickPromise = null;
            try {
                const data = await apiRequest('/api/tick', { method: 'POST' });
                state.barAnimationProgress = 0;
                handleTickData(data);
                state.barAnimationProgress = 1;
                if (state.chart.scrollOffset > 0) state.chart.scrollOffset = Math.max(0, state.chart.scrollOffset - 1);
                updateUI();
                requestAnimationFrame(draw);
                if (state.isEnded) endGame();
            } catch (error) { /* handled by apiRequest */ }
        }

        function handleTickData(data) {
            state.isEnded = data.isEnded;
            state.currentIndex = data.currentIndex;
            state.equity = data.equity;
            state.floatingPL = data.floatingPL;
            state.openPositions = data.openPositions;
            if (data.newlyClosedTrades && data.newlyClosedTrades.length > 0) {
                data.newlyClosedTrades.forEach(trade => {
                    state.tradeHistory.push(trade);
                    addTradeAnimation('CLOSE', trade.closePrice, state.currentIndex - 1, trade.profit);
                    updateAchievementStats(trade);
                    checkTradeAchievements(trade);
                });
            }
            if (data.events && data.events.length > 0) {
                data.events.forEach(event => {
                    switch (event.type) {
                        case 'FINANCIAL_EVENT': showEventModal(event.data); break;
                        case 'MARKET_ALERT': addChartAlertAnimation(event.data.type, event.data.price, state.currentIndex); break;
                        case 'PERFORMANCE_FEEDBACK': state.performanceFeedback = event.data; break;
                    }
                });
            }
            updateAccountDisplay();
            checkEquityAchievements();
            checkDurationAchievements();
        }

        function endGame() { if (!state.isEnded) state.isEnded = true; state.isPlaying = false; cancelAnimationFrame(animationFrameId); stopTimer(); checkFinalAchievements(); updateUI(); showEndGameModal(); }

        // The rest of the file contains all the other functions (UI, Drawing, Event Listeners, etc.)
        // which are included for completeness but are identical to the previous version.
        function resetState() { if (state.timerIntervalId) clearInterval(state.timerIntervalId); Object.assign(state, { gameData: [], isLoading: true, isPlaying: false, isEnded: false, currentIndex: 0, barAnimationProgress: 0, equity: CONFIG.INITIAL_BALANCE, floatingPL: 0, openPositions: [], tradeHistory: [], gameStartTime: null, elapsedTime: 0, timerIntervalId: null, unlockedAchievements: new Set(), achievementStats: { consecutiveWins: 0, consecutiveLosses: 0, maxEquity: CONFIG.INITIAL_BALANCE, minEquity: CONFIG.INITIAL_BALANCE }, performanceFeedback: null, wasPlayingBeforeEvent: false, nextTickPromise: null }); Object.assign(state.chart, { scrollOffset: 0, isCrosshairPinned: false, isDragging: false, isPinching: false, draggedLineType: null, }); DOM.chartOverlay.innerHTML = ''; DOM.positionsList.querySelectorAll('.trade-item').forEach(item => item.remove()); DOM.historyList.querySelectorAll('.trade-item').forEach(item => item.remove()); DOM.inputLots.value = "0.10"; DOM.inputSL.value = ""; DOM.inputTP.value = ""; DOM.hudTimer.textContent = "00:00"; }
        function cacheDOMElements() { Object.assign(DOM, { loader: document.getElementById('loader'), hudDate: document.getElementById('hud-date'), hudEquity: document.getElementById('hud-equity'), hudPL: document.getElementById('hud-pl'), hudProgress: document.getElementById('hud-progress'), hudTimer: document.getElementById('hud-timer'), btnPlayPause: document.getElementById('btnPlayPause'), btnStepForward: document.getElementById('btnStepForward'), speedSelector: document.getElementById('speedSelector'), chartWrap: document.getElementById('chartWrap'), chartCanvas: document.getElementById('chartCanvas'), chartOverlay: document.getElementById('chartOverlay'), chartControls: document.getElementById('chartControls'), bottomNavBar: document.getElementById('bottomNavBar'), positionsCountNav: document.getElementById('positionsCountNav'), btnToggleControls: document.getElementById('btnToggleControls'), inputLots: document.getElementById('inputLots'), inputSL: document.getElementById('inputSL'), inputTP: document.getElementById('inputTP'), estimateSL: document.getElementById('estimateSL'), estimateTP: document.getElementById('estimateTP'), positionsList: document.getElementById('positionsList'), historyList: document.getElementById('historyList'), positionsCount: document.getElementById('positionsCount'), btnCloseAllGlobal: document.getElementById('btnCloseAllGlobal'), emptyPositions: document.getElementById('emptyPositions'), emptyHistory: document.getElementById('emptyHistory'), eventModal: document.getElementById('eventModal'), endGameModal: document.getElementById('endGameModal'), tutorialHighlight: document.getElementById('tutorialHighlight'), tutorialMessage: document.getElementById('tutorialMessage'), tutorialText: document.getElementById('tutorialText'), tutorialNextBtn: document.getElementById('tutorialNextBtn'), notificationContainer: document.getElementById('notification-container'), }); }
        async function openOrder(type, lots, sl, tp) { if (state.isEnded) return; addTradeAnimation(type, getCurrentPrice(), state.currentIndex); try { const data = await apiRequest('/api/trade', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ type, lots, sl, tp }), }); updateStateFromResponse(data); DOM.inputSL.value = ""; DOM.inputTP.value = ""; } catch(e) {} }
        async function closeOrder(id) { if (state.isEnded) return; try { const data = await apiRequest(`/api/trade/${id}`, { method: 'DELETE' }); updateStateFromResponse(data); if (data.lastClosedTrade) { addTradeAnimation('CLOSE', data.lastClosedTrade.closePrice, state.currentIndex, data.lastClosedTrade.profit); } } catch(e) {} }
        async function closeAllOrders() { if (state.isEnded || state.openPositions.length === 0) return; if (!confirm(`確定要關閉所有 ${state.openPositions.length} 個持倉嗎？`)) return; try { const data = await apiRequest('/api/trades', { method: 'DELETE' }); updateStateFromResponse(data); if (data.lastClosedTrades) { data.lastClosedTrades.forEach(trade => addTradeAnimation('CLOSE', trade.closePrice, state.currentIndex, trade.profit)); } } catch(e) {} }
        function updateStateFromResponse(data) { state.equity = data.equity; state.floatingPL = data.floatingPL; state.openPositions = data.openPositions; state.tradeHistory = data.tradeHistory; updateUI(); }
        function updateUI() { updateHUD(); updatePositionsPanel(); updateHistoryPanel(); updateControls(); updateOrderPanel(); if (!state.isPlaying) requestAnimationFrame(draw); }
        function showEventModal(event) { if (state.isPlaying) { state.wasPlayingBeforeEvent = true; togglePlayPause(); } else { state.wasPlayingBeforeEvent = false; } document.getElementById('eventTitle').textContent = `⚠️ ${event.title}`; document.getElementById('eventBody').textContent = event.description; DOM.eventModal.classList.add('active'); }
        function continueFromEvent() { DOM.eventModal.classList.remove('active'); if (state.wasPlayingBeforeEvent) togglePlayPause(); }
        function showEndGameModal() { const finalRoR = (state.equity - CONFIG.INITIAL_BALANCE) / CONFIG.INITIAL_BALANCE; let simulationDays = 30; if (state.gameData.length > 1) { simulationDays = (state.gameData[state.gameData.length-1].time - state.gameData[0].time) / 86400000; } document.getElementById('finalScore').textContent = `$${state.equity.toFixed(2)}`; document.getElementById('finalRoR').innerHTML = `模擬回報率: ${(finalRoR * 100).toFixed(2)}%`; document.getElementById('finalRoR').style.color = finalRoR >= 0 ? 'var(--color-success)' : 'var(--color-danger)'; const minutes = Math.floor(state.elapsedTime / 60); const seconds = state.elapsedTime % 60; document.getElementById('finalTime').textContent = `總花費時間: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; let feedbackHTML = ''; if (state.performanceFeedback) { feedbackHTML = `<div class="performance-feedback" style="text-align: left; margin-top: 20px; padding: 15px; background-color: var(--color-bg); border-radius: var(--radius-main);"><h3 style="text-align: center; margin-bottom: 10px;">📊 模擬表現分析</h3><p style="margin-top: 10px;"><strong>基礎評估：</strong><br>${state.performanceFeedback.feedbackGeneral.text}</p><p style="margin-top: 10px;"><strong>進階評估：</strong><br>${state.performanceFeedback.feedbackFund.text}</p></div>`; } const totalTrades = state.tradeHistory.length; const winRate = totalTrades > 0 ? (state.tradeHistory.filter(t => t.profit > 0).length / totalTrades) * 100 : 0; const totalProfit = state.tradeHistory.reduce((sum, t) => sum + t.profit, 0); document.getElementById('endGameStats').innerHTML = `${feedbackHTML}<div style="margin-top: 20px; padding-top: 10px; border-top: 1px solid var(--color-border); text-align: left;"><p><strong>交易統計：</strong></p><ul style="list-style-position: inside; padding-left: 10px;"><li>總交易次數: ${totalTrades}</li><li>勝率: ${winRate.toFixed(2)}%</li><li>模擬總損益: $${totalProfit.toFixed(2)}</li><li>模擬期間: 約 ${Math.round(simulationDays)} 天</li></ul></div>`; displayAchievements(); DOM.endGameModal.classList.add('active'); }
        function startTimer() { state.gameStartTime = Date.now(); if (state.timerIntervalId) clearInterval(state.timerIntervalId); state.timerIntervalId = setInterval(updateTimer, 1000); }
        function updateTimer() { if (state.gameStartTime && !state.isEnded) { state.elapsedTime = Math.floor((Date.now() - state.gameStartTime) / 1000); const minutes = Math.floor(state.elapsedTime / 60); const seconds = state.elapsedTime % 60; DOM.hudTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; } }
        function stopTimer() { if (state.timerIntervalId) { clearInterval(state.timerIntervalId); state.timerIntervalId = null; } }
        function initChart() { state.chart.canvas = DOM.chartCanvas; state.chart.ctx = state.chart.canvas.getContext('2d'); resizeCanvas(); }
        function resizeCanvas() { const newIsMobile = window.innerWidth <= 900 || 'ontouchstart' in window || navigator.maxTouchPoints > 0; if (newIsMobile !== state.isMobile) { state.isMobile = newIsMobile; if (state.tutorialActive) { setTimeout(showTutorialStep, 50); } } const dpr = window.devicePixelRatio || 1; const rect = DOM.chartWrap.getBoundingClientRect(); const width = Math.max(1, Math.floor(rect.width)); const height = Math.max(1, Math.floor(rect.height)); if (state.chart.width !== width || state.chart.height !== height) { state.chart.canvas.width = width * dpr; state.chart.canvas.height = height * dpr; state.chart.canvas.style.width = `${width}px`; state.chart.canvas.style.height = `${height}px`; state.chart.ctx.scale(dpr, dpr); state.chart.width = width; state.chart.height = height; validateScrollOffset(); } if (!state.isLoading) { draw(); } }
        function draw() { if (state.isLoading || state.gameData.length === 0) return; const ctx = state.chart.ctx; ctx.clearRect(0, 0, state.chart.width, state.chart.height); calculateViewport(); drawBackground(ctx); drawGrid(ctx); drawCandles(ctx); drawOrderSetupLines(ctx); drawYAxis(ctx); drawXAxis(ctx); drawCrosshair(ctx); drawTradeAnimations(ctx); drawChartAlertAnimations(ctx); updatePositionOverlays(); }
        function drawOrderSetupLines(ctx) { if (!DOM.inputSL || !DOM.inputTP || !DOM.inputLots) return; const slPrice = parseFloat(DOM.inputSL.value); const tpPrice = parseFloat(DOM.inputTP.value); const lots = parseFloat(DOM.inputLots.value); if (!isNaN(slPrice) && slPrice > 0) { drawSetupLine(ctx, slPrice, 'SL', lots); } if (!isNaN(tpPrice) && tpPrice > 0) { drawSetupLine(ctx, tpPrice, 'TP', lots); } }
        function drawSetupLine(ctx, price, type, lots) { const y = priceToY(price); const { left, right, top, bottom } = CONFIG.CHART_PADDING; const { width, height } = state.chart; if (y < top || y > height - bottom) return; const color = type === 'SL' ? getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-success').trim(); ctx.strokeStyle = color; ctx.lineWidth = state.chart.draggedLineType === type ? 2.5 : 1.5; ctx.setLineDash([10, 5]); ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(width - right, y); ctx.stroke(); ctx.setLineDash([]); const currentPrice = getCurrentPrice(); let estimatedPL = 0; if (!isNaN(lots) && lots > 0 && currentPrice > 0) { estimatedPL = Math.abs(currentPrice - price) * CONFIG.CONTRACT_SIZE * lots; } const labelText = `${type}: ${type === 'SL' ? '-' : '+'}$${estimatedPL.toFixed(2)}`; const padding = 5; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const textMetrics = ctx.measureText(labelText); const labelWidth = textMetrics.width + padding * 2; const labelHeight = 20; ctx.fillStyle = color; ctx.globalAlpha = 0.85; ctx.fillRect(left, y - labelHeight, labelWidth, labelHeight); ctx.globalAlpha = 1.0; ctx.fillStyle = 'white'; ctx.fillText(labelText, left + padding, y - (labelHeight - 16) / 2 ); }
        function calculateVisibleCandles() { const { width, candleWidth, candleSpacing } = state.chart; const { left, right } = CONFIG.CHART_PADDING; const chartAreaWidth = width - left - right; const candleUnitWidth = candleWidth + candleSpacing; if (candleUnitWidth <= 0) return 100; return Math.max(1, Math.floor(chartAreaWidth / candleUnitWidth)); }
        function calculateViewport() { const visibleCandles = calculateVisibleCandles(); let endIndex = state.currentIndex + 1 - state.chart.scrollOffset; let startIndex = endIndex - visibleCandles; if (endIndex > state.currentIndex + 1) { endIndex = state.currentIndex + 1; startIndex = Math.max(0, endIndex - visibleCandles); } if (startIndex < 0) { startIndex = 0; endIndex = Math.min(state.currentIndex + 1, startIndex + visibleCandles); } state.chart.viewStartIndex = startIndex; state.chart.viewEndIndex = endIndex; let minPrice = Infinity; let maxPrice = -Infinity; for (let i = startIndex; i < endIndex; i++) { if (i >= state.gameData.length || i < 0) continue; const bar = state.gameData[i]; if (i === state.currentIndex && state.chart.scrollOffset === 0) { const animatedBar = getAnimatedBar(bar); minPrice = Math.min(minPrice, animatedBar.low); maxPrice = Math.max(maxPrice, animatedBar.high); } else { minPrice = Math.min(minPrice, bar.low); maxPrice = Math.max(maxPrice, bar.high); } } const priceRange = maxPrice - minPrice; if (priceRange <= 0 || !isFinite(priceRange)) { const centerPrice = (minPrice === Infinity) ? (state.gameData[0]?.close || 1900) : minPrice; const padding = centerPrice * 0.001; state.chart.minPrice = centerPrice - padding; state.chart.maxPrice = centerPrice + padding; } else { const padding = priceRange * 0.1; state.chart.minPrice = minPrice - padding; state.chart.maxPrice = maxPrice + padding; } }
        function priceToY(price) { const { height, minPrice, maxPrice } = state.chart; const { top, bottom } = CONFIG.CHART_PADDING; const chartAreaHeight = height - top - bottom; const priceRange = maxPrice - minPrice; if (chartAreaHeight <= 0 || priceRange <= 0) return top + chartAreaHeight / 2; const y = top + chartAreaHeight * (1 - (price - minPrice) / priceRange); return Math.max(top, Math.min(height - bottom, y)); }
        function yToPrice(y) { const { height, minPrice, maxPrice } = state.chart; const { top, bottom } = CONFIG.CHART_PADDING; const chartAreaHeight = height - top - bottom; const priceRange = maxPrice - minPrice; if (chartAreaHeight <= 0) return (minPrice + maxPrice) / 2; const constrainedY = Math.max(top, Math.min(height - bottom, y)); const price = minPrice + priceRange * (1 - (constrainedY - top) / chartAreaHeight); return price; }
        function indexToX(index) { const { viewStartIndex, candleWidth, candleSpacing } = state.chart; const { left } = CONFIG.CHART_PADDING; const candleUnitWidth = candleWidth + candleSpacing; return left + (index - viewStartIndex) * candleUnitWidth + candleWidth / 2; }
        function drawBackground(ctx) { ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim(); ctx.fillRect(0, 0, state.chart.width, state.chart.height); }
        function drawGrid(ctx) { const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim(); const dateSeparatorColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-date-separator').trim(); const { left, right, top, bottom } = CONFIG.CHART_PADDING; ctx.strokeStyle = gridColor; ctx.lineWidth = 1; const yTicks = calculateYAxisTicks(); yTicks.forEach(tick => { const y = priceToY(tick.price); ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(state.chart.width - right, y); ctx.stroke(); }); const xTicks = calculateXAxisTicks(); xTicks.forEach(tick => { const x = indexToX(tick.index); if (x >= left && x <= state.chart.width - right) { if (tick.isDateSeparator) { ctx.strokeStyle = dateSeparatorColor; ctx.lineWidth = 1.5; } else { ctx.strokeStyle = gridColor; ctx.lineWidth = 1; } ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, state.chart.height - bottom); ctx.stroke(); } }); ctx.lineWidth = 1; }
        function getAnimatedBar(bar) { const progress = state.barAnimationProgress; const open = bar.open; const wickProgress = Math.min(1, progress * 2); const high = open + (bar.high - open) * wickProgress; const low = open + (bar.low - open) * wickProgress; const close = open + (bar.close - open) * progress; const finalHigh = Math.max(high, close, open); const finalLow = Math.min(low, close, open); return { open, high: finalHigh, low: finalLow, close }; }
        function drawCandles(ctx) { const { viewStartIndex, viewEndIndex, candleWidth } = state.chart; const colorBull = getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim(); const colorBear = getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim(); for (let i = viewStartIndex; i < viewEndIndex; i++) { if (i >= state.gameData.length || i < 0) continue; const bar = state.gameData[i]; let displayBar = bar; if (i === state.currentIndex && state.chart.scrollOffset === 0) { displayBar = getAnimatedBar(bar); } const x = indexToX(i); const openY = priceToY(displayBar.open); const highY = priceToY(displayBar.high); const lowY = priceToY(displayBar.low); const closeY = priceToY(displayBar.close); const color = displayBar.close >= displayBar.open ? colorBull : colorBear; ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x, highY); ctx.lineTo(x, lowY); ctx.stroke(); const bodyTop = Math.min(openY, closeY); const bodyHeight = Math.abs(openY - closeY); const finalHeight = Math.max(1, bodyHeight); const finalWidth = Math.max(1, candleWidth); ctx.fillRect(x - finalWidth / 2, bodyTop, finalWidth, finalHeight); } }
        function calculateYAxisTicks() { const { minPrice, maxPrice, height } = state.chart; const priceRange = maxPrice - minPrice; if (priceRange <= 0) return []; const targetCount = Math.max(2, Math.floor(height / 50)); const rawSpacing = priceRange / targetCount; const magnitude = Math.pow(10, Math.floor(Math.log10(rawSpacing))); const normalizedSpacing = rawSpacing / magnitude; let tickSpacing; if (normalizedSpacing > 5) tickSpacing = 10 * magnitude; else if (normalizedSpacing > 2) tickSpacing = 5 * magnitude; else if (normalizedSpacing > 1) tickSpacing = 2 * magnitude; else tickSpacing = magnitude; const ticks = []; let currentTick = Math.ceil(minPrice / tickSpacing) * tickSpacing; while (currentTick <= maxPrice) { if (isFinite(currentTick)) ticks.push({ price: currentTick }); currentTick += tickSpacing; if (tickSpacing === 0) break; } return ticks; }
        function drawYAxis(ctx) { const { width, height } = state.chart; const { right } = CONFIG.CHART_PADDING; const axisX = width - right; ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim(); ctx.fillRect(axisX, 0, right, height); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim(); ctx.beginPath(); ctx.moveTo(axisX, 0); ctx.lineTo(axisX, height); ctx.stroke(); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim(); ctx.font = '12px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; const ticks = calculateYAxisTicks(); ticks.forEach(tick => { const y = priceToY(tick.price); ctx.fillText(tick.price.toFixed(2), axisX + 5, y); }); const isCrosshairActive = (state.mouse.isOverChart || state.chart.isCrosshairPinned) && !state.chart.isDragging && !state.chart.draggedLineType; if (state.currentIndex < state.gameData.length && state.chart.scrollOffset === 0 && !isCrosshairActive) { const currentPrice = getCurrentPrice(); const currentY = priceToY(currentPrice); const color = currentPrice >= state.gameData[state.currentIndex].open ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim(); ctx.fillStyle = color; ctx.fillRect(axisX + 1, currentY - 10, right - 1, 20); ctx.fillStyle = 'white'; ctx.fillText(currentPrice.toFixed(2), axisX + 5, currentY); } }
        function calculateXAxisTicks() { const { viewStartIndex, viewEndIndex, width } = state.chart; if (viewEndIndex <= viewStartIndex || viewStartIndex >= state.gameData.length) return []; const targetCount = Math.max(2, Math.floor(width / 100)); const visibleCandles = viewEndIndex - viewStartIndex; const interval = Math.max(1, Math.round(visibleCandles / targetCount)); const ticks = []; let lastDateStr = null; for (let i = viewStartIndex; i < viewEndIndex; i++) { if (i < 0 || i >= state.gameData.length) continue; const time = state.gameData[i].time; const currentDate = new Date(time); const currentDateStr = currentDate.toDateString(); let isDateSeparator = false; if (lastDateStr !== null && currentDateStr !== lastDateStr) { isDateSeparator = true; } lastDateStr = currentDateStr; if (isDateSeparator || (i - viewStartIndex) % interval === 0) { if (!ticks.some(t => t.index === i)) { ticks.push({ index: i, time: time, isDateSeparator: isDateSeparator }); } } } return ticks; }
        function drawXAxis(ctx) { const { width, height } = state.chart; const { bottom, right, left } = CONFIG.CHART_PADDING; const axisY = height - bottom; ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim(); ctx.fillRect(0, axisY, width, bottom); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim(); ctx.beginPath(); ctx.moveTo(0, axisY); ctx.lineTo(width - right, axisY); ctx.stroke(); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim(); ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const ticks = calculateXAxisTicks(); let timeDiff = 0; if (state.chart.viewEndIndex > state.chart.viewStartIndex && state.gameData.length > 0) { const startIndex = Math.max(0, state.chart.viewStartIndex); const endIndex = Math.min(state.gameData.length - 1, state.chart.viewEndIndex - 1); if (endIndex >= startIndex) { timeDiff = state.gameData[endIndex].time - state.gameData[startIndex].time; } } ticks.forEach(tick => { const x = indexToX(tick.index); if (x >= left && x <= width - right) { const date = new Date(tick.time); let label; if (tick.isDateSeparator) { label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' }); ctx.font = 'bold 12px sans-serif'; } else { ctx.font = '12px sans-serif'; if (timeDiff < 48 * 3600 * 1000) { label = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }); } else { label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' }); } } ctx.fillText(label, x, axisY + 5); } }); }
        function drawCrosshair(ctx) { if (state.chart.isDragging && state.chart.draggedLineType === null) return; let x, y; if (state.chart.isCrosshairPinned) { x = state.chart.pinnedCrosshairPos.x; y = state.chart.pinnedCrosshairPos.y; } else if (state.mouse.isOverChart) { x = state.mouse.x; y = state.mouse.y; } else { return; } const { left, right, top, bottom } = CONFIG.CHART_PADDING; const { width, height } = state.chart; if (x < left || x > width - right || y < top || y > height - bottom) return; const showVertical = state.chart.draggedLineType === null; const crosshairColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-crosshair').trim(); ctx.strokeStyle = crosshairColor; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(width - right, y); ctx.stroke(); if (showVertical) { ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, height - bottom); ctx.stroke(); } ctx.setLineDash([]); const crosshairPrice = yToPrice(y); const axisX = width - right; ctx.fillStyle = crosshairColor; ctx.fillRect(axisX + 1, y - 10, right - 1, 20); ctx.fillStyle = 'white'; ctx.font = '12px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillText(crosshairPrice.toFixed(2), axisX + 5, y); }
        function updatePositionOverlays() { const overlay = DOM.chartOverlay; const linesToKeep = new Set(); state.openPositions.forEach(pos => { const entryId = `line-entry-${pos.id}`; const slId = `line-sl-${pos.id}`; const tpId = `line-tp-${pos.id}`; const entryColor = pos.type === 'BUY' ? 'var(--color-bull)' : 'var(--color-bear)'; createOrUpdatePositionLine(overlay, entryId, pos.entryPrice, entryColor, `進場價 ${pos.entryPrice.toFixed(2)}`, pos); linesToKeep.add(entryId); if (pos.sl) { createOrUpdatePositionLine(overlay, slId, pos.sl, 'var(--color-danger)', `停損 ${pos.sl.toFixed(2)}`, null, calculatePotentialProfit(pos, pos.sl)); linesToKeep.add(slId); } if (pos.tp) { createOrUpdatePositionLine(overlay, tpId, pos.tp, 'var(--color-success)', `停利 ${pos.tp.toFixed(2)}`, null, calculatePotentialProfit(pos, pos.tp)); linesToKeep.add(tpId); } }); Array.from(overlay.children).forEach(child => { if (child.classList.contains('position-line') && !linesToKeep.has(child.id)) { overlay.removeChild(child); } }); }
        function createOrUpdatePositionLine(container, id, price, color, labelText, position = null, potentialPL = null) { let line = document.getElementById(id); if (!line) { line = document.createElement('div'); line.id = id; line.className = 'position-line'; const label = document.createElement('div'); label.className = 'position-label'; line.appendChild(label); const plDisplay = document.createElement('div'); plDisplay.className = 'position-pl'; line.appendChild(plDisplay); const dash = document.createElement('div'); dash.className = 'position-line-dash'; line.appendChild(dash); container.appendChild(line); } const y = priceToY(price); if (y < CONFIG.CHART_PADDING.top || y > state.chart.height - CONFIG.CHART_PADDING.bottom) { line.style.opacity = 0; } else { line.style.opacity = 1; line.style.top = `${y - 10}px`; } line.style.width = `calc(100% - ${CONFIG.CHART_PADDING.right}px)`; const dash = line.querySelector('.position-line-dash'); dash.style.borderTopColor = color; const label = line.querySelector('.position-label'); label.style.backgroundColor = color; label.textContent = labelText; const plDisplay = line.querySelector('.position-pl'); let displayValue = null; if (position) { displayValue = position.profit; } else if (potentialPL !== null) { displayValue = potentialPL; } if (displayValue !== null) { plDisplay.textContent = `$${displayValue.toFixed(2)}`; plDisplay.style.color = displayValue >= 0 ? 'var(--color-success)' : 'var(--color-danger)'; plDisplay.style.display = 'block'; } else { plDisplay.style.display = 'none'; } }
        const tradeAnimations = []; const chartAlertAnimations = [];
        function addTradeAnimation(type, price, index, profit = 0) { tradeAnimations.push({ type, price, index, profit, startTime: performance.now(), duration: type === 'CLOSE' ? 1500 : 800 }); if (!state.isPlaying) requestAnimationFrame(draw); }
        function addChartAlertAnimation(type, price, index) { chartAlertAnimations.push({ type, price, index, startTime: performance.now(), duration: 2500 }); if (!state.isPlaying) requestAnimationFrame(draw); }
        function drawTradeAnimations(ctx) { const now = performance.now(); let animationsRunning = false; for (let i = tradeAnimations.length - 1; i >= 0; i--) { const anim = tradeAnimations[i]; const elapsed = now - anim.startTime; const progress = Math.min(1, elapsed / anim.duration); const opacity = 1 - progress; const x = indexToX(anim.index); const y = priceToY(anim.price); if (x < CONFIG.CHART_PADDING.left || x > state.chart.width - CONFIG.CHART_PADDING.right) { if (progress >= 1) tradeAnimations.splice(i, 1); else animationsRunning = true; continue; } ctx.globalAlpha = opacity; if (anim.type === 'BUY' || anim.type === 'SELL') { const color = anim.type === 'BUY' ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim(); ctx.fillStyle = color; const size = 12 + progress * 5; const offsetY = anim.type === 'BUY' ? 15 : -15; ctx.beginPath(); if (anim.type === 'BUY') { ctx.moveTo(x, y + offsetY); ctx.lineTo(x - size/2, y + offsetY + size); ctx.lineTo(x + size/2, y + offsetY + size); } else { ctx.moveTo(x, y + offsetY); ctx.lineTo(x - size/2, y + offsetY - size); ctx.lineTo(x + size/2, y + offsetY - size); } ctx.closePath(); ctx.fill(); } else if (anim.type === 'CLOSE') { const color = anim.profit >= 0 ? getComputedStyle(document.documentElement).getPropertyValue('--color-success').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim(); ctx.fillStyle = color; ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; const floatY = y - progress * 60; ctx.fillText(`$${anim.profit.toFixed(2)}`, x, floatY); } ctx.globalAlpha = 1; if (progress >= 1) { tradeAnimations.splice(i, 1); } else { animationsRunning = true; } } if (animationsRunning && !state.isPlaying) requestAnimationFrame(draw); }
        function drawChartAlertAnimations(ctx) { const now = performance.now(); let animationsRunning = false; const { left, right, top, bottom } = CONFIG.CHART_PADDING; const { width, height } = state.chart; for (let i = chartAlertAnimations.length - 1; i >= 0; i--) { const anim = chartAlertAnimations[i]; const elapsed = now - anim.startTime; const progress = Math.min(1, elapsed / anim.duration); const opacity = progress < 0.7 ? 1 : 1 - ((progress - 0.7) / 0.3); const y = priceToY(anim.price); let color, text; if (anim.type === 'BREAKOUT') { color = '#FFD700'; text = '💥 突破 7 日新高！'; } else { color = getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim(); text = '🔻 跌破 7 日新低！'; } ctx.globalAlpha = opacity * 0.8; ctx.strokeStyle = color; ctx.lineWidth = 2 + Math.sin(progress * Math.PI * 8) * 0.5; ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(width - right, y); ctx.stroke(); ctx.globalAlpha = opacity; const fontSize = 16; const padding = 8; const floatDistance = progress * 30 + 20; const chartAreaWidth = width - left - right; const textX = left + chartAreaWidth / 2; let floatY = y - floatDistance; ctx.font = `bold ${fontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textMetrics = ctx.measureText(text); const rectHeight = fontSize + padding * 2; const halfHeight = rectHeight / 2; if (floatY - halfHeight < top) { floatY = y + floatDistance; if (floatY + halfHeight > height - bottom) { if (y < (top + height - bottom) / 2) { floatY = top + halfHeight; } else { floatY = height - bottom - halfHeight; } } } const rectWidth = textMetrics.width + padding * 2; const rectX = textX - rectWidth / 2; const rectY = floatY - halfHeight; ctx.fillStyle = `rgba(50, 50, 50, ${opacity * 0.7})`; ctx.fillRect(rectX, rectY, rectWidth, rectHeight); ctx.fillStyle = color; ctx.fillText(text, textX, floatY); ctx.globalAlpha = 1; ctx.lineWidth = 1; if (progress >= 1) { chartAlertAnimations.splice(i, 1); } else { animationsRunning = true; } } if (animationsRunning && !state.isPlaying) requestAnimationFrame(draw); }
        function getCurrentPrice() { if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return 0; const currentBar = state.gameData[state.currentIndex]; return getAnimatedBar(currentBar).close; }
        function calculatePotentialProfit(position, targetPrice) { const priceDiff = position.type === 'BUY' ? targetPrice - position.entryPrice : position.entryPrice - targetPrice; return priceDiff * CONFIG.CONTRACT_SIZE * position.lots; }
        function updateAccountDisplay() { DOM.hudEquity.textContent = `$${state.equity.toFixed(2)}`; DOM.hudPL.textContent = `$${state.floatingPL.toFixed(2)}`; DOM.hudPL.classList.toggle('positive', state.floatingPL > 0); DOM.hudPL.classList.toggle('negative', state.floatingPL < 0); }
        function updatePositionProfits() { const currentPrice = getCurrentPrice(); if(currentPrice <= 0) return; state.openPositions.forEach(pos => { pos.profit = calculatePotentialProfit(pos, currentPrice); }); }
        function updateOrderPanel() { DOM.btnCloseAllGlobal.disabled = state.openPositions.length === 0 || state.isEnded; updateEstimatedPL(); }
        function updateEstimatedPL() { if (!DOM.inputLots || !DOM.inputSL || !DOM.inputTP) return; const lots = parseFloat(DOM.inputLots.value); const slPrice = parseFloat(DOM.inputSL.value); const tpPrice = parseFloat(DOM.inputTP.value); const currentPrice = getCurrentPrice(); DOM.estimateSL.textContent = ''; DOM.estimateTP.textContent = ''; if (isNaN(lots) || lots <= 0 || currentPrice <= 0) return; if (!isNaN(slPrice) && slPrice > 0) { const slPL = Math.abs(currentPrice - slPrice) * CONFIG.CONTRACT_SIZE * lots; DOM.estimateSL.textContent = `SL: -$${slPL.toFixed(2)}`; } if (!isNaN(tpPrice) && tpPrice > 0) { const tpPL = Math.abs(currentPrice - tpPrice) * CONFIG.CONTRACT_SIZE * lots; DOM.estimateTP.textContent = `TP: +$${tpPL.toFixed(2)}`; } }
        function updateHUD() { if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return; const currentDate = new Date(state.gameData[state.currentIndex].time); DOM.hudDate.textContent = currentDate.toLocaleString('zh-TW', { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false }); updateAccountDisplay(); const progress = (state.currentIndex / (state.gameData.length - 1)) * 100; DOM.hudProgress.style.width = `${Math.min(100, progress)}%`; }
        function updatePositionsPanel() { DOM.positionsCount.textContent = state.openPositions.length; if (DOM.positionsCountNav) DOM.positionsCountNav.textContent = state.openPositions.length; DOM.emptyPositions.style.display = state.openPositions.length === 0 ? 'flex' : 'none'; const existingItems = DOM.positionsList.querySelectorAll('.trade-item'); const currentIds = new Set(state.openPositions.map(p => p.id)); existingItems.forEach(item => { if (!currentIds.has(parseInt(item.dataset.id))) DOM.positionsList.removeChild(item); }); state.openPositions.forEach(pos => { let item = DOM.positionsList.querySelector(`[data-id="${pos.id}"]`); if (!item) { item = document.createElement('div'); item.className = 'trade-item'; item.dataset.id = pos.id; item.innerHTML = `<div class="trade-header"><span class="trade-type ${pos.type}">#${pos.id} ${pos.type === 'BUY' ? '買入' : '賣出'} ${pos.lots.toFixed(2)}手</span><span class="trade-profit"></span></div><div class="trade-details"><div><div class="trade-detail-label">進場價</div><div>${pos.entryPrice.toFixed(2)}</div></div><div><div class="trade-detail-label">停損(SL)</div><div class="trade-sl"></div></div><div><div class="trade-detail-label">停利(TP)</div><div class="trade-tp"></div></div></div><div class="trade-actions-buttons"><button class="btn btn-small btn-secondary btn-modify" disabled>修改</button><button class="btn btn-small btn-danger btn-close">平倉</button></div>`; DOM.positionsList.insertBefore(item, DOM.emptyPositions); } const profitElement = item.querySelector('.trade-profit'); profitElement.textContent = `$${pos.profit.toFixed(2)}`; profitElement.style.color = pos.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)'; item.querySelector('.trade-sl').textContent = pos.sl ? pos.sl.toFixed(2) : 'N/A'; item.querySelector('.trade-tp').textContent = pos.tp ? pos.tp.toFixed(2) : 'N/A'; }); }
        function updateHistoryPanel() { DOM.emptyHistory.style.display = state.tradeHistory.length === 0 ? 'flex' : 'none'; const tradeItemCount = DOM.historyList.querySelectorAll('.trade-item').length; if (tradeItemCount === state.tradeHistory.length) return; DOM.historyList.querySelectorAll('.trade-item').forEach(item => item.remove()); [...state.tradeHistory].reverse().forEach(trade => { const item = document.createElement('div'); item.className = 'trade-item'; item.innerHTML = `<div class="trade-header"><span class="trade-type ${trade.type}">#${trade.id} ${trade.type === 'BUY' ? '買入' : '賣出'} ${trade.lots.toFixed(2)}手</span><span style="color: ${trade.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)'}">$${trade.profit.toFixed(2)}</span></div><div class="trade-details"><div><div class="trade-detail-label">開倉價</div><div>${trade.entryPrice.toFixed(2)}</div></div><div><div class="trade-detail-label">平倉價</div><div>${trade.closePrice.toFixed(2)}</div></div><div><div class="trade-detail-label">持有時間</div><div>${formatDuration(trade.closeTime - trade.entryTime)}</div></div></div>`; DOM.historyList.insertBefore(item, DOM.emptyHistory); }); }
        function updateControls() { DOM.btnPlayPause.textContent = state.isPlaying ? '⏸️ 暫停' : '▶️ 播放'; DOM.btnStepForward.disabled = state.isPlaying || state.isEnded; DOM.btnPlayPause.disabled = state.isEnded; document.getElementById('btnBuy').disabled = state.isEnded; document.getElementById('btnSell').disabled = state.isEnded; document.getElementById('btnEndGame').disabled = state.isEnded; }
        function setupEventListeners() { window.addEventListener('resize', resizeCanvas); DOM.btnPlayPause.addEventListener('click', togglePlayPause); DOM.btnStepForward.addEventListener('click', stepForward); DOM.speedSelector.addEventListener('click', handleSpeedChange); document.getElementById('btnZoomIn').addEventListener('click', () => zoomChart(1.2)); document.getElementById('btnZoomOut').addEventListener('click', () => zoomChart(1/1.2)); document.getElementById('btnEndGame').addEventListener('click', handleEndGameClick); document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', handleInternalTabSwitch)); document.querySelectorAll('.nav-btn-v9').forEach(btn => btn.addEventListener('click', handleNavigationTabSwitch)); DOM.btnToggleControls.addEventListener('click', toggleCollapsibleControls); setupInputScrubbing(); DOM.inputLots.addEventListener('input', updateOrderPanel); DOM.inputSL.addEventListener('input', updateOrderPanel); DOM.inputTP.addEventListener('input', updateOrderPanel); document.getElementById('btnBuy').addEventListener('click', () => handleTrade('BUY')); document.getElementById('btnSell').addEventListener('click', () => handleTrade('SELL')); DOM.btnCloseAllGlobal.addEventListener('click', closeAllOrders); DOM.positionsList.addEventListener('click', (e) => { const target = e.target; const tradeItem = target.closest('.trade-item'); if (!tradeItem) return; const id = parseInt(tradeItem.dataset.id); if (target.classList.contains('btn-close')) closeOrder(id); else if (target.classList.contains('btn-modify')) alert('修改功能暫未開放。'); }); DOM.chartWrap.addEventListener('mousemove', handleMouseMove); DOM.chartWrap.addEventListener('mouseleave', handleMouseLeave); DOM.chartWrap.addEventListener('wheel', handleMouseWheel, { passive: false }); DOM.chartWrap.addEventListener('mousedown', handleDragStart); window.addEventListener('mousemove', handleDragging); window.addEventListener('mouseup', handleDragEnd); DOM.chartWrap.addEventListener('touchstart', handleTouchStart, { passive: false }); window.addEventListener('touchmove', handleTouchMove, { passive: false }); window.addEventListener('touchend', handleTouchEnd); document.getElementById('restartButton').addEventListener('click', startGame); document.getElementById('eventContinueBtn').addEventListener('click', continueFromEvent); }
        function handleEndGameClick() { if (state.isEnded) return; if (state.isPlaying) togglePlayPause(); if (confirm("確定要提前結束本次挑戰嗎？")) endGame(); }
        function toggleCollapsibleControls() { DOM.chartControls.classList.toggle('controls-collapsed'); DOM.btnToggleControls.textContent = DOM.chartControls.classList.contains('controls-collapsed') ? '展開設定' : '隱藏設定'; setTimeout(resizeCanvas, 50); }
        function togglePlayPause() { if (state.isEnded) return; state.isPlaying = !state.isPlaying; if (state.isPlaying) { lastTickTime = 0; animationFrameId = requestAnimationFrame(gameLoop); } else { cancelAnimationFrame(animationFrameId); state.nextTickPromise = null; } updateControls(); }
        function handleSpeedChange(e) { if (e.target.classList.contains('speed-btn')) { document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); state.speedMultiplier = parseInt(e.target.dataset.speed); lastTickTime = 0; } }
        function handleNavigationTabSwitch(e) { const target = e.target.closest('.nav-btn-v9'); if (!target) return; const targetId = target.dataset.target; document.querySelectorAll('.nav-btn-v9').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content-v9').forEach(c => c.classList.remove('active')); target.classList.add('active'); document.getElementById(targetId).classList.add('active'); setTimeout(resizeCanvas, 50); if (state.tutorialActive) setTimeout(showTutorialStep, 50); }
        function handleInternalTabSwitch(e) { const target = e.target.closest('.tab-btn'); if (!target) return; document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); target.classList.add('active'); document.getElementById(target.dataset.target).classList.add('active'); if (state.tutorialActive) setTimeout(showTutorialStep, 50); }
        function handleTrade(type) { const lots = parseFloat(DOM.inputLots.value); const sl = DOM.inputSL.value ? parseFloat(DOM.inputSL.value) : null; const tp = DOM.inputTP.value ? parseFloat(DOM.inputTP.value) : null; if (isNaN(lots) || lots < 0.01) { alert("請輸入有效的手數 (Lots)，最小為 0.01。"); return; } if ((sl !== null && (isNaN(sl) || sl <= 0)) || (tp !== null && (isNaN(tp) || tp <= 0))) { alert("停損/停利價格必須是正數。"); return; } openOrder(type, lots, sl, tp); }
        function handleMouseMove(e) { const rect = DOM.chartWrap.getBoundingClientRect(); state.mouse.x = e.clientX - rect.left; state.mouse.y = e.clientY - rect.top; state.mouse.isOverChart = true; if (state.chart.isCrosshairPinned && !state.isMobile) state.chart.isCrosshairPinned = false; updateCursorStyle(); if (!state.isPlaying && !state.chart.isDragging) requestAnimationFrame(draw); }
        function handleMouseLeave() { state.mouse.isOverChart = false; updateCursorStyle(); if (!state.isPlaying && !state.chart.isDragging) requestAnimationFrame(draw); }
        function handleMouseWheel(e) { e.preventDefault(); zoomChart(e.deltaY > 0 ? 1 / 1.1 : 1.1); }
        function zoomChart(factor) { const newWidth = state.chart.candleWidth * factor; const MIN_CANDLE_WIDTH = 2; const MAX_CANDLE_WIDTH = 50; const chartAreaWidth = state.chart.width - CONFIG.CHART_PADDING.left - CONFIG.CHART_PADDING.right; const newSpacing = state.chart.candleSpacing * factor; const newUnitWidth = newWidth + newSpacing; if (newUnitWidth <= 0) return; if (chartAreaWidth > 0) { const visibleCandles = Math.floor(chartAreaWidth / newUnitWidth); if (visibleCandles < CONFIG.MIN_VISIBLE_CANDLES && factor > 1) { if (chartAreaWidth > CONFIG.MIN_VISIBLE_CANDLES * (CONFIG.CANDLE_WIDTH_DEFAULT + CONFIG.CANDLE_SPACING)) return; } if (visibleCandles > CONFIG.MAX_VISIBLE_CANDLES && factor < 1) return; } if (newWidth < MIN_CANDLE_WIDTH || newWidth > MAX_CANDLE_WIDTH) return; state.chart.candleWidth = newWidth; state.chart.candleSpacing = newSpacing; validateScrollOffset(); if (!state.isPlaying) requestAnimationFrame(draw); }
        function getLineNearPoint(x, y) { const proximityThreshold = 8; const { left, right } = CONFIG.CHART_PADDING; const { width } = state.chart; if (x < left || x > width - right) return null; if (!DOM.inputSL || !DOM.inputTP) return null; const slPrice = parseFloat(DOM.inputSL.value); const tpPrice = parseFloat(DOM.inputTP.value); if (!isNaN(slPrice) && slPrice > 0) { const slY = priceToY(slPrice); if (Math.abs(y - slY) <= proximityThreshold) return 'SL'; } if (!isNaN(tpPrice) && tpPrice > 0) { const tpY = priceToY(tpPrice); if (Math.abs(y - tpY) <= proximityThreshold) return 'TP'; } return null; }
        function updateCursorStyle() { if (state.chart.isDragging || state.chart.isPinching) return; const chartX = state.mouse.x; const chartY = state.mouse.y; if (state.mouse.isOverChart) { const lineType = getLineNearPoint(chartX, chartY); if (lineType) { DOM.chartWrap.style.cursor = 'ns-resize'; } else { DOM.chartWrap.style.cursor = 'crosshair'; } } else { DOM.chartWrap.style.cursor = 'crosshair'; } }
        function handleDragStart(e) { if (e.button === 0) startDrag(e.clientX, e.clientY); }
        function handleDragging(e) { if (state.chart.isDragging) performDrag(e.clientX, e.clientY); }
        function handleDragEnd() { if (state.chart.isDragging) { endDrag(); } }
        function handleTouchStart(e) { if (!e.target.closest('#chartWrap')) return; if (e.touches.length === 2) { if (e.cancelable) e.preventDefault(); state.chart.isDragging = false; state.chart.isPinching = true; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; state.chart.pinchStartDistance = Math.sqrt(dx * dx + dy * dy); state.chart.pinchStartCandleWidth = state.chart.candleWidth; } else if (e.touches.length === 1) { if (!e.target.closest('.controls')) { if (e.cancelable) e.preventDefault(); } state.chart.isPinching = false; startDrag(e.touches[0].clientX, e.touches[0].clientY); } }
        function handleTouchMove(e) { if (state.chart.isPinching && e.touches.length === 2) { if (e.cancelable) e.preventDefault(); const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const currentDistance = Math.sqrt(dx * dx + dy * dy); if (state.chart.pinchStartDistance > 0) { const scaleFactor = currentDistance / state.chart.pinchStartDistance; const newWidth = state.chart.pinchStartCandleWidth * scaleFactor; zoomChart(newWidth / state.chart.candleWidth); } } else if (e.touches.length === 1 && state.chart.isDragging) { if (e.cancelable) e.preventDefault(); const dx = e.touches[0].clientX - state.chart.dragStartX; const dy = e.touches[0].clientY - state.chart.dragStartY; if (state.chart.draggedLineType === null && Math.sqrt(dx * dx + dy * dy) > 10 && state.chart.isCrosshairPinned) { state.chart.isCrosshairPinned = false; } performDrag(e.touches[0].clientX, e.touches[0].clientY); } }
        function handleTouchEnd(e) { if (state.chart.isPinching) { state.chart.isPinching = false; if (e.touches.length === 1) { startDrag(e.touches[0].clientX, e.touches[0].clientY); } return; } if (!state.chart.isDragging) return; if (state.chart.draggedLineType !== null) { endDrag(); return; } const touchDuration = Date.now() - state.chart.dragStartTimeStamp; const dx = state.chart.dragCurrentX - state.chart.dragStartX; const dy = state.chart.dragCurrentY - state.chart.dragStartY; const isTap = touchDuration < 300 && Math.sqrt(dx * dx + dy * dy) < 10; let isOnControls = false; const rect = DOM.chartWrap.getBoundingClientRect(); const startX = state.chart.dragStartX; const startY = state.chart.dragStartY; const controlsContainers = document.querySelectorAll('.controls-overlay-container .controls'); controlsContainers.forEach(container => { const ctrlRect = container.getBoundingClientRect(); if (startX >= ctrlRect.left && startX <= ctrlRect.right && startY >= ctrlRect.top && startY <= ctrlRect.bottom) { isOnControls = true; } }); if (isTap && !isOnControls) { if (state.chart.isCrosshairPinned) { state.chart.isCrosshairPinned = false; } else { state.chart.pinnedCrosshairPos.x = state.chart.dragCurrentX - rect.left; state.chart.pinnedCrosshairPos.y = state.chart.dragCurrentY - rect.top; state.chart.isCrosshairPinned = true; } } endDrag(); }
        function startDrag(clientX, clientY) { const rect = DOM.chartWrap.getBoundingClientRect(); const chartX = clientX - rect.left; const chartY = clientY - rect.top; const lineType = getLineNearPoint(chartX, chartY); if (lineType) { state.chart.isDragging = true; state.chart.draggedLineType = lineType; DOM.chartWrap.style.cursor = 'ns-resize'; } else { state.chart.isDragging = true; state.chart.draggedLineType = null; state.chart.dragStartX = clientX; state.chart.dragStartScroll = state.chart.scrollOffset; if (!state.chart.isPinching) { DOM.chartWrap.style.cursor = 'grabbing'; } } state.chart.dragCurrentX = clientX; state.chart.dragCurrentY = clientY; state.chart.dragStartTimeStamp = Date.now(); }
        function performDrag(clientX, clientY) { state.chart.dragCurrentX = clientX; state.chart.dragCurrentY = clientY; if (state.chart.draggedLineType) { const rect = DOM.chartWrap.getBoundingClientRect(); const chartY = clientY - rect.top; const newPrice = yToPrice(chartY); if (newPrice > 0) { const inputField = state.chart.draggedLineType === 'SL' ? DOM.inputSL : DOM.inputTP; inputField.value = newPrice.toFixed(2); updateUI(); } } else { const dx = clientX - state.chart.dragStartX; const candleUnitWidth = state.chart.candleWidth + state.chart.candleSpacing; if (candleUnitWidth <= 0) return; state.chart.scrollOffset = state.chart.dragStartScroll + Math.round(dx / candleUnitWidth); validateScrollOffset(); requestAnimationFrame(draw); } }
        function endDrag() { state.chart.isDragging = false; state.chart.draggedLineType = null; updateCursorStyle(); if (!state.isPlaying) requestAnimationFrame(draw); }
        function validateScrollOffset() { if (state.gameData.length === 0) { state.chart.scrollOffset = 0; return; } const visibleCandles = calculateVisibleCandles(); const maxOffset = Math.max(0, state.currentIndex + 1 - visibleCandles); state.chart.scrollOffset = Math.max(0, Math.min(maxOffset, state.chart.scrollOffset)); }
        function unlockAchievement(key) { if (!state.unlockedAchievements.has(key)) { state.unlockedAchievements.add(key); const achievement = ACHIEVEMENTS[key]; if (achievement) showNotification(`🏆 成就解鎖: ${achievement.title}`, achievement.description); } }
        function updateAchievementStats(closedTrade) { if (closedTrade.profit > 0) { state.achievementStats.consecutiveWins++; state.achievementStats.consecutiveLosses = 0; } else if (closedTrade.profit < 0) { state.achievementStats.consecutiveLosses++; state.achievementStats.consecutiveWins = 0; } }
        function checkTradeAchievements(trade) { if (state.tradeHistory.length >= 1) unlockAchievement('FIRST_TRADE'); if (state.tradeHistory.length >= 10) unlockAchievement('TRADER_10'); if (trade.profit > 3000) unlockAchievement('BIG_WIN'); if (trade.profit < -3000) unlockAchievement('BIG_LOSS'); if (state.achievementStats.consecutiveWins >= 3) unlockAchievement('WIN_STREAK_3'); if (state.achievementStats.consecutiveLosses >= 3) unlockAchievement('LOSS_STREAK_3'); if (trade.profit > 0 && (trade.closeTime - trade.entryTime) <= 3600000) unlockAchievement('QUICK_DRAW'); }
        function checkEquityAchievements() { if (state.equity >= 20000) unlockAchievement('DOUBLE_UP'); if (state.equity < 2000) unlockAchievement('MARGIN_CALL'); }
        function checkDurationAchievements() { if (!state.gameData || state.currentIndex >= state.gameData.length) return; const currentTime = state.gameData[state.currentIndex].time; state.openPositions.forEach(pos => { if (currentTime - pos.entryTime > 7 * 24 * 60 * 60 * 1000) { if (pos.profit > 0) unlockAchievement('HOLD_WIN_7D'); else if (pos.profit < 0) unlockAchievement('HOLD_LOSS_7D'); } }); }
        function checkFinalAchievements() { const totalTrades = state.tradeHistory.length; if (totalTrades >= 10) { const winRate = (state.tradeHistory.filter(t => t.profit > 0).length / totalTrades) * 100; if (winRate > 60) unlockAchievement('CONSISTENT'); } }
        function displayAchievements() { const listElement = document.getElementById('achievementsList'); const sectionElement = document.getElementById('achievementsSection'); listElement.innerHTML = ''; if (state.unlockedAchievements.size === 0) { sectionElement.style.display = 'none'; return; } sectionElement.style.display = 'block'; state.unlockedAchievements.forEach(key => { const achievement = ACHIEVEMENTS[key]; if (achievement) { const item = document.createElement('li'); item.className = 'achievement-item'; item.innerHTML = `<span class="achievement-icon">${achievement.icon}</span><div><strong>${achievement.title}</strong><p style="font-size: 12px; color: var(--color-text-secondary);">${achievement.description}</p></div>`; listElement.appendChild(item); } }); }
        function showNotification(title, message) { if (!DOM.notificationContainer) return; const toast = document.createElement('div'); toast.className = 'notification-toast'; toast.innerHTML = `<strong>${title}</strong><p>${message}</p>`; DOM.notificationContainer.insertBefore(toast, DOM.notificationContainer.firstChild); setTimeout(() => toast.classList.add('show'), 10); setTimeout(() => { toast.classList.remove('show'); setTimeout(() => { if (DOM.notificationContainer.contains(toast)) DOM.notificationContainer.removeChild(toast); }, 500); }, 5000); }
        function formatDuration(ms) { if (ms < 0) ms = 0; const minutes = Math.floor(ms / 60000); const hours = Math.floor(minutes / 60); const days = Math.floor(hours / 24); if (days > 0) return `${days}天 ${hours % 24}小時`; if (hours > 0) return `${hours}小時 ${minutes % 60}分鐘`; if (minutes === 0) return `${Math.floor(ms / 1000)}秒`; return `${minutes}分鐘`; }
        const TUTORIAL_STEPS = [ { selector: '.header', message: '歡迎！本次模擬挑戰目標是在30天內學習交易並提升績效。您可以在頂部追蹤虛擬帳戶狀態和進度。', action: 'next' }, { selector: '.chart-container-v9', message: '圖表區域已最大化。拖曳查看歷史數據，使用滑鼠滾輪或手機雙指縮放 (Pinch-to-Zoom) 查看細節。', action: 'next' }, { selector: '#btnToggleControls', message: '圖表設定預設已收合並以半透明顯示。點擊此按鈕展開速度控制和縮放選項。', action: 'next' }, { dynamicSelector: () => state.isMobile ? '.bottom-nav-bar-v9' : '.main-container-v9 .bottom-nav-bar-v9', dynamicMessage: () => state.isMobile ? '使用底部導航欄切換「下單」和「倉位/紀錄」頁面。' : '使用側邊欄頂部的頁籤切換「下單」和「倉位/紀錄」面板。', action: 'next' }, { selector: '#tabOrder', message: '下單介面集中在此。', action: 'ensureActiveTabOrder', skipDraw: true }, { selector: '.order-controls', message: '設定停損(SL)、手數和停利(TP)。在輸入框上按住並左右拖動 (Scrubbing) 可快速調整數值。', action: 'next' }, { selector: '.chart-wrap', message: '當您設定 SL/TP 價格後，圖表上會顯示對應的價格線。您可以直接【拖曳】這些線條來快速微調價格。', action: 'demoSLTPInput' }, { selector: '.trade-actions', message: '點擊「賣出」、「全部平倉」或「買入」進行交易。', action: 'next' }, { selector: '.order-info-bar', message: '您可以在此查看預估的停損/停利金額。祝您模擬順利！', action: 'next' }, ];
        let currentTutorialStep = 0;
        function startTutorial() { if (state.isPlaying) togglePlayPause(); state.tutorialActive = true; currentTutorialStep = 0; showTutorialStep(); }
        function ensureActiveTab(tabId) { const tabContent = document.getElementById(tabId); if (!tabContent.classList.contains('active')) { const navButton = document.querySelector(`.nav-btn-v9[data-target="${tabId}"]`); if (navButton) { handleNavigationTabSwitch({ target: navButton }); } } }
        function demoSLTPInput() { const currentPrice = getCurrentPrice(); if (currentPrice > 0) { DOM.inputSL.value = (currentPrice - 10).toFixed(2); DOM.inputTP.value = (currentPrice + 10).toFixed(2); updateUI(); } }
        function showTutorialStep() { if (currentTutorialStep >= TUTORIAL_STEPS.length) { endTutorial(); return; } const step = TUTORIAL_STEPS[currentTutorialStep]; if (step.action === 'ensureActiveTabOrder') { ensureActiveTab('tabOrder'); if (step.skipDraw) { currentTutorialStep++; setTimeout(showTutorialStep, 50); return; } } else if (step.action === 'demoSLTPInput') { demoSLTPInput(); } if (step.dynamicSelector) { step.selector = step.dynamicSelector(); if (step.dynamicMessage) { step.message = step.dynamicMessage(); } } const element = document.querySelector(step.selector); if (!element || (element.offsetParent === null && !step.selector.includes('bottom-nav-bar-v9'))) { const parentTab = element ? element.closest('.tab-content-v9') : null; if (parentTab && !parentTab.classList.contains('active')) { ensureActiveTab(parentTab.id); setTimeout(showTutorialStep, 100); return; } if (!element) { console.warn("Tutorial element not found:", step.selector); completeTutorialStep(); return; } } if (step.selector === '#btnToggleControls' && !DOM.chartControls.classList.contains('controls-collapsed')) { toggleCollapsibleControls(); } DOM.tutorialText.textContent = step.message; highlightElement(element); if (!DOM.tutorialMessage.classList.contains('hidden')) { DOM.tutorialNextBtn.classList.remove('hidden'); DOM.tutorialNextBtn.onclick = completeTutorialStep; } }
        function completeTutorialStep() { if (!state.tutorialActive) return; currentTutorialStep++; showTutorialStep(); }
        function endTutorial() { state.tutorialActive = false; state.tutorialCompletedOnce = true; DOM.tutorialHighlight.classList.add('hidden'); DOM.tutorialMessage.classList.add('hidden'); DOM.inputSL.value = ""; DOM.inputTP.value = ""; updateUI(); if (DOM.chartControls.classList.contains('controls-collapsed')) { toggleCollapsibleControls(); } if (!state.isPlaying && !state.isEnded) togglePlayPause(); }
        function highlightElement(element) { const rect = element.getBoundingClientRect(); const padding = 10; if (rect.width === 0 && rect.height === 0) { DOM.tutorialHighlight.classList.add('hidden'); DOM.tutorialMessage.classList.add('hidden'); return; } DOM.tutorialHighlight.classList.remove('hidden'); DOM.tutorialHighlight.style.top = `${rect.top + window.scrollY - padding}px`; DOM.tutorialHighlight.style.left = `${rect.left + window.scrollX - padding}px`; DOM.tutorialHighlight.style.width = `${rect.width + padding * 2}px`; DOM.tutorialHighlight.style.height = `${rect.height + padding * 2}px`; DOM.tutorialMessage.classList.remove('hidden'); DOM.tutorialMessage.style.width = 'auto'; const messageRect = DOM.tutorialMessage.getBoundingClientRect(); let positionAboveTop = rect.top + window.scrollY - messageRect.height - padding - 15; let positionBelowTop = rect.bottom + window.scrollY + padding + 15; const viewportTop = window.scrollY; const viewportBottom = window.scrollY + window.innerHeight; const safetyMargin = 15; const spaceAbove = (rect.top + window.scrollY) - viewportTop; const spaceBelow = viewportBottom - (rect.bottom + window.scrollY); let finalMessageTop; if (spaceBelow >= messageRect.height + safetyMargin * 2) { finalMessageTop = positionBelowTop; } else if (spaceAbove >= messageRect.height + safetyMargin * 2) { finalMessageTop = positionAboveTop; } else { if (spaceBelow >= spaceAbove) { finalMessageTop = viewportBottom - messageRect.height - safetyMargin; } else { finalMessageTop = viewportTop + safetyMargin; } } let messageLeft = rect.left + window.scrollX; if (!state.isMobile && element.closest('.bottom-content-v9')) { messageLeft = rect.left + window.scrollX - messageRect.width - padding - 15; } if (messageLeft + messageRect.width > window.innerWidth - safetyMargin) { messageLeft = window.innerWidth - messageRect.width - safetyMargin; } messageLeft = Math.max(safetyMargin, messageLeft); DOM.tutorialMessage.style.top = `${finalMessageTop}px`; DOM.tutorialMessage.style.left = `${messageLeft}px`; }
        function setupInputScrubbing() { document.querySelectorAll('.input-field.scrubbable').forEach(input => { let isScrubbing = false; let startX = 0; let startValue = 0; const scrubStep = parseFloat(input.dataset.scrubStep) || 1; const inputId = input.id; const isLots = inputId === 'inputLots'; const decimalPlaces = 2; const onScrubMove = (e) => { if (!isScrubbing) return; if (e.cancelable) e.preventDefault(); const clientX = e.clientX || (e.touches && e.touches[0].clientX); const dx = clientX - startX; const sensitivity = 10; const steps = Math.floor(dx / sensitivity); let newValue = startValue + steps * scrubStep; if (isLots) { if (newValue < 0.01) newValue = 0.01; } else { if (newValue < 0) { newValue = 0; } } const precisionFactor = Math.pow(10, decimalPlaces); newValue = Math.round(newValue * precisionFactor) / precisionFactor; if (newValue === 0 && !isLots) { input.value = ''; } else { input.value = newValue.toFixed(decimalPlaces); } updateUI(); }; const onScrubEnd = () => { if (!isScrubbing) return; isScrubbing = false; document.body.style.cursor = ''; window.removeEventListener('mousemove', onScrubMove); window.removeEventListener('mouseup', onScrubEnd); window.removeEventListener('touchmove', onScrubMove); window.removeEventListener('touchend', onScrubEnd); }; const onScrubStart = (e) => { if (e.type === 'mousedown' && e.button !== 0) return; if (document.activeElement === input && window.getSelection().toString()) { return; } if (e.cancelable) e.preventDefault(); isScrubbing = true; startX = e.clientX || (e.touches && e.touches[0].clientX); let currentValue = parseFloat(input.value); if (isNaN(currentValue) || (!isLots && currentValue <= 0)) { if (!isLots) { const currentPrice = getCurrentPrice(); if (currentPrice > 0) { startValue = currentPrice; } else { startValue = 0; } } else { startValue = 0.10; } } else { startValue = currentValue; } document.body.style.cursor = 'ew-resize'; window.addEventListener('mousemove', onScrubMove); window.addEventListener('mouseup', onScrubEnd); window.addEventListener('touchmove', onScrubMove, { passive: false }); window.addEventListener('touchend', onScrubEnd); }; input.addEventListener('mousedown', onScrubStart); input.addEventListener('touchstart', onScrubStart, { passive: false }); }); }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>