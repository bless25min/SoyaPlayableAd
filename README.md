交易獲利挑戰賽：專案開發歷程全紀錄與最終藍圖
1. 專案概述
專案名稱：交易獲利挑戰賽 (Trading Profit Challenge)

核心目標：開發一款獨立、輕量、高效能的 HTML5 可玩式廣告 (Playable Ad)。旨在透過一個簡化但真實的交易模擬體驗，吸引對金融交易感興趣的潛在使用者，最終引導他們點擊行動呼籲 (CTA) 按鈕，前往指定的目標網頁。

核心挑戰：在嚴格的檔案大小與載入速度限制下（單一 HTML 檔案，無外部請求），打造一個功能完整、體驗流暢且具備遊戲化吸引力的網頁應用程式。

2. 功能模組詳解 (最終版功能清單)
這份清單整合了您所有版本的功能，是我們重構時必須實現的完整功能集。

A. 圖表渲染引擎
繪製技術：使用原生 HTML5 Canvas 確保流暢性。

K 線圖：

顏色：陽棒（上漲 c >= o）為綠色，陰棒（下跌 c < o）為紅色。

動態繪製：每一根新的 K 棒都必須有從「開盤價」開始，動態展示「最高/最低價影線」，最後「實體收盤」的完整動畫過程。

互動操作：

支援滑鼠/觸控拖曳平移圖表。

支援滾輪或介面按鈕進行縮放。

座標軸與標示：

價格軸：在圖表右側動態顯示價格區間。

時間軸：在圖表底部顯示日期/時間標籤。

當前價格線：一條水平虛線，標示最新價格，並在價格軸上有一個對應的價格標籤。

交易資訊疊加：

持倉線：為每一筆持倉訂單繪製進場價、停損價 (SL)、停利價 (TP) 的水平虛線。

即時損益標籤：在進場線旁，以一個有色塊背景的標籤，即時顯示該筆訂單的浮動損益。

B. 交易與帳戶系統
下單面板：

可設定手數、停損價格、停利價格。

所有輸入框都配有步進按鈕 (▲ / ▼)，方便微調。

交易執行：

支援市價買入 (Buy) 和賣出 (Sell)。

支援一鍵全部平倉。

倉位管理 (「持倉」分頁)：

以列表形式顯示所有未平倉訂單的詳細資訊（方向、手數、進場價、即時損益）。

每一筆訂單都可以即時修改其 SL/TP 價格。

可對單筆訂單進行平倉操作。

交易日誌 (「紀錄」分頁)：

以列表形式顯示所有已平倉的歷史交易紀錄（方向、手數、進出場價格、最終損益）。

帳戶 HUD (頂部抬頭顯示器)：

永久顯示模擬日期、帳戶淨值、總浮動損益。

設有進度條，顯示當前挑戰的完成進度。

C. 遊戲化與流程模組
新手導引：首次進入時，以高亮框和彈出式說明框，引導使用者了解圖表、下單、播放控制等核心功能。

播放控制面板：

播放/暫停按鈕。

逐 K 前進按鈕。

多段變速控制（例如 0.25x, 0.5x, 1x, 2x, 5x）。

財經事件系統：在特定日期暫停模擬，彈出一個視窗顯示當日的重大新聞事件，增加沉浸感和挑戰性。

結束與引導 (End Card)：挑戰結束後，彈出專業的結算畫面，顯示最終淨值與總損益，並提供清晰的 CTA 按鈕和「再次挑戰」按鈕。

D. 數據處理模組
數據源：從指定的 GitHub Raw URL 載入 XAUUSD_M15.csv 檔案。

數據解析器：必須能自動偵測並兼容兩種格式：

時間戳,開,高,低,收 (逗號分隔)

年.月.日 時:分:秒 開 高 低 收 (空格/Tab 分隔)

數據抽樣：每次遊戲開始時，從完整數據集中隨機抽取一個月的區間作為本次挑戰內容。

3. 開發歷程與迭代回顧
這次的重構是基於我們之前一系列的嘗試與除錯，以下是對整個過程的總結，也是避免重蹈覆轍的備忘錄：

V1.0 - 基礎實現：完成了基本的圖表繪製和播放功能，但介面和功能較為簡陋。

V2.0 - 介面與功能完善：根據您的舊版程式碼，我們確立了最終的 UI/UX 設計，包括頂部 HUD、三頁籤（交易、持倉、紀錄）的底部面板、以及完整的播放控制項。K 線顏色、持倉線、各種動畫效果等都在這個階段被明確定義。

V3.0 - 穩定性攻防戰 (Debug 階段)：這是專案最關鍵也最曲折的階段。

遭遇問題 1：啟動時崩潰。

現象：新手導引系統在頁面載入時，因找不到 id="playback-controls" 的 HTML 元素而導致 JavaScript 執行中斷，造成白屏。

根本原因：JavaScript 在 HTML DOM 完全渲染完成前就執行了（即「競態條件 Race Condition」）。同時，HTML 結構中也確實遺漏了必要的 id。

最終解決方案：1. 將所有初始化程式碼放入 DOMContentLoaded 事件監聽器中。 2. 為新手導引的目標元素補上 id。 3. 在導引函式中加入元素存在性檢查，作為雙重保險。

遭遇問題 2：數據無法解析。

現象：圖表始終為空，控制台顯示解析出的有效數據為 0。

根本原因：程式碼最初錯誤地假設 CSV 檔案是以「逗號」分隔的，而您的檔案實際上是以「空格/Tab」分隔的。

最終解決方案：重寫一個更強大的 parseData 函式，使其能夠自動檢測檔案格式，並兼容兩種不同的分隔符與日期格式。

遭遇問題 3：功能遺失與程式碼混亂。

現象：在反覆修復 Bug 的過程中，舊版本中已實現的完整功能（如持倉線、動畫、SL/TP 修改等）被不慎移除，導致程式碼版本混亂，功能殘缺不全。

根本原因：未能將「舊版的完整功能」與「新版的 Bug 修復」進行正確、細緻的合併，而是採取了簡單的程式碼覆蓋，導致了災難性的後果。

最終解決方案：停止修補，進行本次的完全重構。

4. 最終版重構藍圖
本次重構將採用以下清晰、穩定的架構來實現上述所有功能：

單一狀態管理 (state 物件)：

建立一個全域的 state 物件，用來存放所有會變動的數據，例如：fullDataset, gameData, currentBarIndex, positions, journal, account, isPaused, view (圖表視圖) 等。

所有的用戶互動（如下單、縮放）和遊戲循環都只修改 state 物件，絕不直接操作 DOM。

主渲染迴圈 (requestAnimationFrame)：

建立一個名為 draw() 的主繪圖函式。

使用 requestAnimationFrame(draw) 來創建一個持續的渲染迴圈。這個迴圈是所有視覺更新的唯一入口。

draw() 函式會讀取當前的 state，並將 K 線、持倉線、動畫等所有視覺元素一次性繪製到 Canvas 上。

當遊戲暫停時，可以透過判斷 state.isPaused 來選擇性地停止不必要的重繪，以節省效能。

清晰的邏輯分離：

init()：程式進入點，負責獲取 DOM 元素、綁定所有永久性的事件監聽器（如按鈕點擊、圖表拖曳等）。

loadData() & parseData()：專門負責數據的獲取與解析。

startGame()：負責初始化或重置一局新遊戲的所有 state。

gameLoop()：由 setInterval 驅動，只負責推進遊戲邏輯（currentBarIndex++）、更新持倉盈虧、檢查事件等，然後請求一次重繪。

draw()：只負責根據 state 進行繪圖，不包含任何遊戲邏輯。

updateUI()：負責更新所有非 Canvas 的 DOM 元素（如頂部 HUD、持倉列表等）。

這個架構確保了數據流的單向性和可預測性，將極大地提高程式碼的穩定性和可維護性。

這份文件是我們接下來重構工作的基礎。請您確認這份藍圖是否完整且準確地反映了您的專案目標。一旦您確認，我將立即開始進行程式碼的重新編寫。
