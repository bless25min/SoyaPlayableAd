交易獲利挑戰賽 (Trading Profit Challenge) - 開發歷程
1. 專案概述 (Project Overview)
本專案旨在開發一款獨立、輕量、高效能的 HTML5 交易模擬遊戲。

專案的起點是將一個現有的、功能完備的交易模擬器，改造成一個適合廣告投放的可玩式廣告 (Playable Ad)。然而，在初期的極簡化原型探索後，根據明確的核心需求，專案方向發生了重大轉變，回歸到打造一個功能豐富、體驗專業的擬真交易模擬器。

整個開發歷程經歷了從概念探索、核心玩法轉向、功能專業化迭代，到最終因遭遇技術瓶頸而進行架構重構的完整週期。最終版本在單一 HTML 檔案中，不依賴任何外部函式庫，實現了功能完整、體驗流暢且架構穩定的高品質網頁應用。

2. 核心功能 (最終版)
圖表互動引擎 (Chart Interaction Engine):

高效能渲染: 使用原生 HTML5 Canvas 繪製 K 線圖，確保拖曳、縮放等互動的流暢性。

即時數據視覺化: 在圖表上恆久顯示動態的價格軸、時間軸，以及一條標示最新價位的「當前價格線」。

專業交易疊加層:

為每一筆持倉訂單在圖表上繪製其進場價、停損價 (SL)、停利價 (TP) 的水平線。

在進場線旁附帶一個即時更新的浮動損益標籤，盈虧狀態一目了然。

專業交易系統 (Professional Trading System):

整合式下單面板: 採用螢幕底部常駐的多功能面板，讓用戶在觀察圖表的同時能快速設定手數、停損與停利。

訂單設定即時預覽: 當用戶在面板中輸入 SL/TP 價格時，圖表上會同步出現對應的虛線，提供下單前的視覺化參考。

完整的倉位與歷史管理:

提供「持倉」與「交易紀錄」獨立分頁。

允許用戶對任何一筆未平倉訂單即時修改其 SL/TP 價格。

遊戲化與流程控制 (Gamification & Flow Control):

挑戰模式: 以「在隨機抽取的一個月數據內，最大化帳戶獲利」為核心目標。

專業播放控制器: 包含播放/暫停、單根 K 棒步進、以及多段變速控制。

財經事件系統: 在特定日期暫停模擬，彈出重大新聞事件，增加沉浸感與挑戰性。

3. 開發歷程與版本迭代 (Development Journey & Version Iteration)
V1.0 - 概念探索：從零到可玩式廣告 (Playable Ad)
背景與目標: 初始指令非常明確：「將一個現有的複雜交易模擬器，改造成一個輕量、快速、適合廣告投放的 HTML5 遊戲」。此階段的唯一目標是高點擊轉換率。

執行與產出: 為達成此目標，我移除了所有複雜的交易機制，產出了幾個極簡化的遊戲原型：

版本 1a (單次預測): 核心玩法被簡化為一個問題：「15 秒後，價格會比現在高還是低？」，提供即時的對錯回饋。

版本 1b (限時操作): 引入 20 秒倒數計時，圖表自動播放，用戶需在時間內「手動平倉」來完成一次超簡化的交易體驗。

關鍵轉折: 這些原型雖然符合「可玩式廣告」的定義，但其過於簡化的玩法，與您期望的專案核心價值——「交易策略與獲利」——相去甚遠，為下一個階段的重大轉向埋下伏筆。

V2.0 - 第一次重大轉向：回歸「交易獲利」核心
背景與目標: 您提出了決定性的反饋，徹底扭轉了專案方向：「遊戲目的是獲利，而非預測，應該要能夠有多次的嘗試，隨時可以分批下單，設定停損，停利；重新大改遊戲機制」。

執行與產出: 我立即停止了廣告模型的開發，轉而進行全面的機制重構：

玩法重塑: 確立了「在限定時間內最大化獲利」的核心目標。

功能回歸: 重新引入了多次下單、部位管理、以及在下單時設定 SL/TP 的核心交易功能。

UI 演進: 設計了專為手機優化的新介面，包含底部的核心操作按鈕和一個彈出式的下單面板。

結論: 專案成功地從一個簡單的「猜謎遊戲」轉型為一個具備基本交易邏輯的「模擬器」，確立了其真正的靈魂。

V3.0 - 專業化迭代與「穩定性攻防戰」
背景與目標: V2.0 的原型雖然方向正確，但在專業性和使用者體驗上仍有巨大差距。您提出了一系列極其具體且專業的優化要求，例如：

「走勢圖上沒有價格...」
「點下單的時候由於背景模糊，看不到走勢圖...」
「要有水平線標示設定的價格回饋在走勢圖上...」
「下單後也持續在走勢圖上顯示目前倉位的進場 停損停利價格水平線標示 以及即時損益數字...」

執行與產出 (功能面): 我根據這些需求，對 UI/UX 進行了又一次核心重構，產出了整合式底部下單面板、即時圖表價格標示、持倉視覺化等高級功能，使產品體驗趨近於專業交易軟體。

遭遇的挑戰 (技術面): 這種快速、複雜的功能迭代，使得專案的技術債急劇累積，最終爆發了多個嚴重問題，進入了「穩定性攻防戰」階段：

啟動崩潰: JavaScript 在 HTML 渲染完成前執行，導致「競態條件」錯誤。

數據無法解析: 舊的解析器無法兼容您實際使用的數據格式。

程式碼混亂: 在反覆修補 Bug 的過程中，發生了功能遺失和版本混亂。

V4.0 - 藍圖指導下的完全重構
背景與目標: 為了解決 V3.0 的混亂局面，您親自制定了一份名為「交易獲利挑戰賽：專案開發歷程全紀錄與最終藍圖」的關鍵文件。這份文件不僅精準地總結了過去的問題，更為專案的未來制定了清晰、穩定的技術架構。此階段的目標是：停止修補，嚴格遵循您的藍圖，從零開始進行一次徹底的重構。

執行與產出: 我嚴格遵循您提供的藍圖，完成了最終版本的重構：

單一狀態管理: 建立全域 state 物件作為唯一數據源，根絕了數據不一致的問題。

主渲染迴圈: 採用 requestAnimationFrame 建立唯一的繪圖迴圈，將繪圖與邏輯分離。

清晰的邏輯分離: 將程式碼嚴格劃分為數據處理、遊戲循環、繪圖、UI 更新等獨立模組。

結論: 這次重構不僅解決了 V3.0 的所有技術問題，更產出了一個功能完整、架構清晰、行為可預測的最終穩定版本。它標誌著整個探索與開發過程的圓滿完成，為專案的長期發展奠定了堅實的基礎。

## V5.0 - 架構重構：Cloudflare Pages 全棧 (Full-Stack)

為了實現更高的安全性、可擴展性和更簡易的部署流程，專案已重構為 Cloudflare Pages 的全棧架構。前端和後端 API 被整合在同一個專案中，實現了無縫的開發與部署體驗。

### 架構概述 (Architecture Overview)

*   **前端 (Frontend)**: 位於 `/public` 目錄，由 Cloudflare Pages 提供靜態資源服務。`index.html` 負責所有 UI 渲染和使用者互動。
*   **後端 (Backend)**: 位於 `/functions` 目錄，由 Cloudflare Pages Functions 提供無伺服器 API 服務。這種模式下，後端 API 與前端專案緊密整合，無需單獨部署或綁定 Worker。

此架構將核心商業邏輯完美地隱藏在後端，前端只負責「顯示」和「請求」，大幅提升了應用的安全性與可維護性。

### 目錄結構 (Directory Structure)

*   `/public`: 包含所有前端靜態資源 (`index.html`)。
*   `/functions`: 包含所有後端 API 邏輯。
    *   `/functions/api/[[path]].js`: 一個「萬用路由 (catch-all)」檔案，負責處理所有對 `/api/*` 路徑的請求。
    *   `/functions/XAUUSD_M15.csv`: 遊戲所使用的歷史數據，與後端函式部署在一起。
*   `package.json`: Node.js 專案設定檔，用於管理開發依賴 (例如 `wrangler`)。

### 本地開發 (Local Development)

您可以在本地電腦上完整地模擬 Cloudflare 環境，同時運行前端和後端。

1.  **安裝依賴**:
    如果尚未安裝，請打開您的終端機 (Terminal)，進入專案根目錄，然後執行 `npm install` 來安裝必要的開發工具。
    ```bash
    npm install
    ```

2.  **啟動本地伺服器**:
    安裝完成後，執行以下指令來啟動本地開發伺服器：
    ```bash
    npm start
    ```
    `wrangler` 將會啟動一個伺服器 (通常在 `http://127.0.0.1:8788`)。它會自動提供 `/public` 目錄下的前端頁面，並將所有 `/api/*` 的請求轉發到 `/functions` 目錄下的後端邏輯，完美模擬線上環境。

### 生產環境部署 (Deployment)

部署流程已大幅簡化。

1.  **透過 Git (推薦)**:
    *   將您的專案推送到一個 GitHub 或 GitLab 倉庫。
    *   在 Cloudflare 儀表板上，建立一個新的 Pages 專案並將其連接到您的 Git 倉庫。
    *   在 **Build settings** (建置設定) 中，進行以下設定：
        *   **Build command** (建置指令): `npm install`
        *   **Build output directory** (建置輸出目錄): `/public`
    *   **完成！** 儲存設定後，Cloudflare 在部署時會先安裝必要的依賴，然後將 `/public` 目錄作為前端，並自動偵測 `/functions` 目錄作為後端 API。

2.  **手動部署 (使用 Wrangler CLI)**:
    如果您偏好手動部署，可以執行以下指令：
    ```bash
    npx wrangler pages deploy public
    ```
    此指令會將 `public` 目錄的內容以及 `/functions` 目錄下的 API 函式一同部署。
