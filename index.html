<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>XAUUSD äº¤æ˜“æ¨¡æ“¬æŒ‘æˆ° (Playable Ad Rework)</title>
    <style>
        /* 1. Reset & Variables */
        :root {
            --color-bg: #f5f7fa;
            --color-panel-bg: #ffffff;
            --color-border: #e0e3eb;
            --color-text-primary: #333333;
            --color-text-secondary: #7f8c8d;
            --color-primary: #3498db;
            --color-primary-dark: #2980b9;
            --color-success: #2ecc71;
            --color-danger: #e74c3c;
            --font-main: 'Helvetica Neue', Arial, sans-serif;
            --shadow-main: 0 4px 12px rgba(0, 0, 0, 0.05);
            --radius-main: 8px;

            /* Chart Specific */
            --chart-bg: #ffffff;
            --chart-grid: #f0f0f0;
            --chart-crosshair: #999999;
            --color-bull: #26a69a; /* Green for Up */
            --color-bear: #ef5350; /* Red for Down */
            --color-buy: #3498db;
            --color-sell: #e91e63;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 2. Layout Structure */
        .header {
            background-color: var(--color-panel-bg);
            padding: 10px 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: var(--color-panel-bg);
            border-left: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: 40%;
                border-left: none;
                border-top: 1px solid var(--color-border);
            }
            .chart-container {
                height: 60%;
                padding: 10px;
            }
        }

        /* 3. Header (HUD) Components */
        .hud {
            display: flex;
            gap: 20px;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
        }

        .hud-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .hud-value {
            font-size: 16px;
            font-weight: bold;
        }

        #hud-pl.positive { color: var(--color-success); }
        #hud-pl.negative { color: var(--color-danger); }

        .progress-container {
            width: 150px;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--color-border);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--color-primary);
            transition: width 0.3s ease;
        }

        /* 4. Chart Components */
        .chart-wrap {
            position: relative;
            flex: 1;
            background-color: var(--chart-bg);
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            overflow: hidden;
            cursor: crosshair;
        }

        #chartCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* DOM Overlays for Position Lines */
        .position-line {
            position: absolute;
            left: 0;
            /* Assuming 60px Y-axis width, defined in JS CONFIG.CHART_PADDING.right */
            width: calc(100% - 60px); 
            display: flex;
            align-items: center;
            pointer-events: none; /* Allow interaction with chart below */
            transition: opacity 0.2s;
        }

        .position-line-dash {
            flex: 1;
            height: 1px;
            border-top-style: dashed;
            border-top-width: 1px;
        }

        .position-label {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            margin-left: 5px;
            white-space: nowrap;
        }

        .position-pl {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.9);
            margin-right: 5px;
            font-weight: bold;
            box-shadow: var(--shadow-main);
        }

        /* 5. Controls & Toolbar */
        .controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius-main);
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            user-select: none;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:active {
            transform: scale(0.98);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: default;
            transform: scale(1);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--color-border);
            color: var(--color-text-primary);
        }

        .speed-selector {
            display: flex;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            overflow: hidden;
        }

        .speed-btn {
            padding: 8px 10px;
            background-color: var(--color-panel-bg);
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .speed-btn.active {
            background-color: var(--color-primary);
            color: white;
        }

        .speed-btn:not(:last-child) {
            border-right: 1px solid var(--color-border);
        }

        /* 6. Sidebar (Trading Panel) */
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border);
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            background-color: var(--color-bg);
            border: none;
            font-weight: bold;
        }

        .tab-btn.active {
            background-color: var(--color-panel-bg);
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-primary);
        }

        .tab-content {
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 15px;
        }

        .tab-content.active {
            display: flex;
        }

        /* 6.1 Order Panel */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-label {
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .input-stepper {
            display: flex;
            align-items: center;
        }

        .input-field {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            font-size: 16px;
            text-align: center;
             -moz-appearance: textfield;
        }
        .input-field::-webkit-outer-spin-button,
        .input-field::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }


        .stepper-btn {
            width: 40px;
            height: 42px;
            background-color: var(--color-border);
            border: none;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .stepper-btn:active {
            background-color: var(--color-primary);
            color: white;
        }

        .stepper-btn:first-child {
            border-top-left-radius: var(--radius-main);
            border-bottom-left-radius: var(--radius-main);
        }

        .stepper-btn:last-child {
            border-top-right-radius: var(--radius-main);
            border-bottom-right-radius: var(--radius-main);
        }

        .input-stepper .input-field {
            border-radius: 0;
            border-left: none;
            border-right: none;
        }


        .trade-buttons {
            display: flex;
            gap: 10px;
        }

        .btn-buy {
            background-color: var(--color-bull);
            color: white;
            flex: 1;
            padding: 12px;
            font-size: 18px;
        }

        .btn-sell {
            background-color: var(--color-bear);
            color: white;
            flex: 1;
            padding: 12px;
            font-size: 18px;
        }

        /* 6.2 Positions & History */
        .positions-list, .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .trade-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            padding: 10px;
            font-size: 14px;
        }

        .trade-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .trade-type.BUY { color: var(--color-bull); }
        .trade-type.SELL { color: var(--color-bear); }

        .trade-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .trade-detail-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .trade-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* 7. Modals & Overlays (Tutorial, Events, End Screen) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            /* Animation: Fade-in */
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--color-panel-bg);
            padding: 30px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            max-width: 500px;
            width: 90%;
            text-align: center;
            /* Animation: Slight zoom-in */
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .modal-body {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .cta-button {
            background-color: var(--color-success);
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-decoration: none; /* For <a> tag implementation */
        }

        /* 7.1 Tutorial Specific */
        .tutorial-highlight {
            position: absolute;
            border: 3px dashed var(--color-primary);
            border-radius: var(--radius-main);
            /* Overlay effect using large box-shadow */
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            z-index: 1001;
            pointer-events: none;
            /* Smooth transition between steps */
            transition: top 0.3s, left 0.3s, width 0.3s, height 0.3s;
        }

        .tutorial-message {
            position: absolute;
            background-color: var(--color-primary);
            color: white;
            padding: 15px;
            border-radius: var(--radius-main);
            max-width: 300px;
            z-index: 1002;
            box-shadow: var(--shadow-main);
            transition: top 0.3s, left 0.3s;
        }

        /* 8. Utilities */
        .hidden {
            display: none !important;
        }

        .loader-wrap {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            gap: 20px;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrap" id="loader">
        <div class="loading-spinner"></div>
        <p>æ­£åœ¨è¼‰å…¥æ•¸æ“šèˆ‡åˆå§‹åŒ–åœ–è¡¨...</p>
    </div>

    <!-- Header (HUD) -->
    <header class="header">
        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">æ¨¡æ“¬æ—¥æœŸ</span>
                <span class="hud-value" id="hud-date">--/--/-- --:--</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">å¸³æˆ¶æ·¨å€¼ (Equity)</span>
                <span class="hud-value" id="hud-equity">$10000.00</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">æµ®å‹•æç›Š (P/L)</span>
                <span class="hud-value" id="hud-pl">$0.00</span>
            </div>
        </div>
        <div class="hud-item progress-container">
            <span class="hud-label">æŒ‘æˆ°é€²åº¦</span>
            <div class="progress-bar">
                <div class="progress-fill" id="hud-progress"></div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        
        <!-- Chart Area -->
        <div class="chart-container">
            <div class="controls">
                <button class="btn btn-primary" id="btnPlayPause">â–¶ï¸ æ’­æ”¾</button>
                <button class="btn btn-secondary" id="btnStepForward">â¡ï¸ é€Kå‰é€²</button>
                <div class="speed-selector" id="speedSelector">
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="5">5x</button>
                    <button class="speed-btn" data-speed="20">20x</button>
                </div>
                <button class="btn btn-secondary" id="btnZoomIn">ğŸ”+</button>
                <button class="btn btn-secondary" id="btnZoomOut">ğŸ”-</button>
            </div>

            <div class="chart-wrap" id="chartWrap">
                <canvas id="chartCanvas"></canvas>
                <div class="chart-overlay" id="chartOverlay">
                    <!-- Position lines (DOM Overlays) will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- Sidebar (Trading Panel) -->
        <aside class="sidebar">
            <div class="panel-tabs">
                <button class="tab-btn active" data-target="tabOrder">ä¸‹å–®</button>
                <button class="tab-btn" data-target="tabPositions">æŒå€‰ (<span id="positionsCount">0</span>)</button>
                <button class="tab-btn" data-target="tabHistory">ç´€éŒ„</button>
            </div>

            <div class="tab-content active" id="tabOrder">
                <div class="input-group">
                    <label class="input-label">æ‰‹æ•¸ (Lots)</label>
                    <div class="input-stepper">
                        <button class="stepper-btn" id="lotsDown">âˆ’</button>
                        <input type="number" class="input-field" id="inputLots" value="0.10" step="0.01" min="0.01">
                        <button class="stepper-btn" id="lotsUp">+</button>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">åœæåƒ¹æ ¼ (SL)</label>
                    <div class="input-stepper">
                        <button class="stepper-btn" id="slDown">âˆ’</button>
                        <input type="number" class="input-field" id="inputSL" placeholder="é¸å¡«" step="0.1">
                        <button class="stepper-btn" id="slUp">+</button>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">åœåˆ©åƒ¹æ ¼ (TP)</label>
                    <div class="input-stepper">
                        <button class="stepper-btn" id="tpDown">âˆ’</button>
                        <input type="number" class="input-field" id="inputTP" placeholder="é¸å¡«" step="0.1">
                        <button class="stepper-btn" id="tpUp">+</button>
                    </div>
                    
                </div>

                <div class="trade-buttons">
                    <button class="btn btn-buy" id="btnBuy">è²·å…¥ (BUY)</button>
                    <button class="btn btn-sell" id="btnSell">è³£å‡º (SELL)</button>
                </div>
            </div>

            <div class="tab-content" id="tabPositions">
                <div class="positions-list" id="positionsList">
                    <!-- Positions will be dynamically added here -->
                </div>
                <button class="btn btn-danger" id="btnCloseAll" style="margin-top: 15px; display: none;">å…¨éƒ¨å¹³å€‰</button>
            </div>

            <div class="tab-content" id="tabHistory">
                <div class="history-list" id="historyList">
                    <!-- History will be dynamically added here -->
                </div>
            </div>
        </aside>
    </div>

    <!-- Modals -->
    <div class="modal-overlay" id="eventModal">
        <div class="modal-content">
            <h2 class="modal-title" id="eventTitle">âš ï¸ é‡å¤§è²¡ç¶“äº‹ä»¶</h2>
            <div class="modal-body" id="eventBody" style="text-align: left;">
                <!-- Event details here -->
            </div>
            <button class="btn btn-primary" id="eventContinueBtn">ç¹¼çºŒæ¨¡æ“¬</button>
        </div>
    </div>

    <div class="modal-overlay" id="endGameModal">
        <div class="modal-content">
            <h2 class="modal-title">ğŸ‰ æŒ‘æˆ°çµæŸï¼</h2>
            <div class="modal-body" style="text-align: center;">
                <p>æ‚¨çš„æœ€çµ‚æˆç¸¾ï¼š</p>
                <h1 id="finalScore" style="font-size: 36px; margin: 10px 0;">$10000.00</h1>
                <p id="finalRoR" style="font-size: 20px;"></p>
                <div id="endGameStats" style="text-align: left; margin-top: 20px; padding-top: 10px; border-top: 1px solid var(--color-border);"></div>
            </div>
            <a href="https://www.example.com/register" target="_blank" class="btn cta-button" id="ctaButton">ç«‹å³é–‹è¨­çœŸå¯¦å¸³æˆ¶</a>
            <button class="btn btn-secondary" id="restartButton" style="margin-top: 15px;">é‡æ–°æŒ‘æˆ°</button>
        </div>
    </div>

    <!-- Tutorial Elements (Hidden by default, managed by JS) -->
    <div class="tutorial-highlight hidden" id="tutorialHighlight"></div>
    <div class="tutorial-message hidden" id="tutorialMessage">
        <p id="tutorialText"></p>
        <button class="btn btn-small" id="tutorialNextBtn" style="margin-top: 10px; background-color: white; color: var(--color-primary);">ä¸‹ä¸€æ­¥</button>
    </div>

    <script>
        // ============================================================================
        // å°ˆæ¡ˆï¼šXAUUSD äº¤æ˜“æ¨¡æ“¬ Playable Ad (Rework)
        // æ¶æ§‹ï¼šç‹€æ…‹é©…å‹• (State-Driven Architecture)
        // æ¸²æŸ“ï¼šHTML5 Canvas + DOM Overlays
        // ============================================================================

        // ----------------------------------------------------------------------------
        // 1. ç‹€æ…‹ç®¡ç†èˆ‡å¸¸æ•¸ (State Management & Constants)
        // ----------------------------------------------------------------------------

        const CONFIG = {
            DATA_URL: 'XAUUSD_M15.csv',
            TICK_INTERVAL: 500, // Base time (ms) for one K bar animation (at 1x speed)
            CHART_PADDING: { top: 20, right: 60, bottom: 30, left: 10 },
            CANDLE_WIDTH_DEFAULT: 8,
            CANDLE_SPACING: 3,
            CONTRACT_SIZE: 100, // XAUUSD specific
            INITIAL_BALANCE: 10000,
            SIMULATION_DURATION_DAYS: 30,
        };

        // Global State Object - The single source of truth
        const state = {
            // Data
            rawData: [],
            gameData: [],
            
            // Game Status
            isLoading: true,
            isPlaying: false,
            isEnded: false,
            speedMultiplier: 1,
            currentIndex: 0,
            
            // K-Bar Animation
            barAnimationProgress: 0, // 0 (Open) to 1 (Close)

            // Account & Trading
            balance: CONFIG.INITIAL_BALANCE,
            equity: CONFIG.INITIAL_BALANCE,
            floatingPL: 0,
            openPositions: [],
            tradeHistory: [],
            orderIdCounter: 1,

            // Chart Viewport
            chart: {
                canvas: null,
                ctx: null,
                width: 0,
                height: 0,
                // Viewport indices define what data is currently visible
                viewStartIndex: 0, 
                viewEndIndex: 0,
                minPrice: 0,
                maxPrice: 0,
                candleWidth: CONFIG.CANDLE_WIDTH_DEFAULT,
                candleSpacing: CONFIG.CANDLE_SPACING,
                isDragging: false,
                dragStartX: 0,
                // scrollOffset represents how many candles are scrolled off the right side (0 means viewing the latest)
                scrollOffset: 0, 
            },

            // UI & Interaction
            mouse: { x: -1, y: -1, isOverChart: false },
            tutorialActive: false,
            
            // Events (Mock data for demonstration)
            financialEvents: [
                { triggerDay: 5, title: 'ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)', description: 'éè¾²æ•¸æ“šå³å°‡å…¬å¸ƒï¼Œå¸‚å ´é æœŸå°‡å‡ºç¾åŠ‡çƒˆæ³¢å‹•ã€‚è«‹æ³¨æ„é¢¨éšªï¼' },
                { triggerDay: 15, title: 'ç¾åœ‹ CPI å…¬å¸ƒ', description: 'æ¶ˆè²»è€…ç‰©åƒ¹æŒ‡æ•¸ (CPI) é«˜æ–¼é æœŸï¼Œå¯èƒ½å¼•ç™¼å¸‚å ´å°é€šè†¨çš„æ“”æ†‚ã€‚' },
                { triggerDay: 25, title: 'FOMC åˆ©ç‡æ±ºè­°', description: 'è¯æº–æœƒå³å°‡å®£å¸ƒåˆ©ç‡æ±ºè­°ã€‚å¸‚å ´æ™®éé æœŸå°‡ç¶­æŒç¾æœ‰åˆ©ç‡ã€‚' },
            ],
            triggeredEvents: new Set(),
        };

        // DOM Element Caching
        const DOM = {};

        // ----------------------------------------------------------------------------
        // 2. æ•¸æ“šè™•ç† (Data Processing)
        // ----------------------------------------------------------------------------

        async function loadData() {
            try {
                const response = await fetch(CONFIG.DATA_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();
                state.rawData = parseData(csvText);
                
                if (state.rawData.length === 0) {
                    throw new Error("ç„¡æ³•è§£ææ•¸æ“šæˆ–æ•¸æ“šç‚ºç©ºã€‚è«‹æª¢æŸ¥ CSV æª”æ¡ˆæ ¼å¼ã€‚");
                }
                
                console.log(`æˆåŠŸè¼‰å…¥ ${state.rawData.length} ç­†æ•¸æ“šã€‚`);
                startGame();
            } catch (error) {
                console.error("è¼‰å…¥æ•¸æ“šå¤±æ•—:", error);
                document.getElementById('loader').innerHTML = `<p style="color: red;">éŒ¯èª¤ï¼š${error.message}</p><p>è«‹ç¢ºä¿ XAUUSD_M15.csv èˆ‡ index.html ä½æ–¼åŒä¸€å€‹ç›®éŒ„ï¼Œä¸¦ä¸”ä¼ºæœå™¨é…ç½®æ­£ç¢ºï¼ˆæˆ–ç€è¦½å™¨å…è¨±æœ¬åœ°æª”æ¡ˆå­˜å–ï¼‰ã€‚</p>`;
            }
        }

        // è‡ªå‹•åµæ¸¬ä¸¦è§£æ CSV æ•¸æ“š
        function parseData(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];

            // 1. åµæ¸¬åˆ†éš”ç¬¦å’Œæ™‚é–“æ ¼å¼
            const firstLine = lines.find(line => line.trim() !== '' && !line.toLowerCase().includes('time') && !line.toLowerCase().includes('date') && !line.toLowerCase().includes('open'));
            if (!firstLine) return [];

            let delimiter = ',';
            
            // å„ªå…ˆåˆ¤æ–·æ˜¯å¦ç‚ºç©ºæ ¼/Tabåˆ†éš” (å¸¸è¦‹æ–¼ MT4/MT5 å°å‡º)
            if (firstLine.includes('\t') || (firstLine.includes(' ') && !firstLine.includes(','))) {
                delimiter = /\s+/; // ç©ºæ ¼æˆ– Tab
            }

            const testParts = firstLine.split(delimiter);

            if (testParts.length < 5) return [];

            // åµæ¸¬æ™‚é–“æ ¼å¼
            let timeFormat = 'unknown';
            if (testParts[0].match(/^\d{10,}$/)) {
                // çœ‹èµ·ä¾†åƒæ™‚é–“æˆ³
                timeFormat = 'timestamp';
            } else if (testParts[0].match(/^\d{4}[\.\-]\d{2}[\.\-]\d{2}$/) && testParts[1].match(/^\d{2}:\d{2}/)) {
                 // æ ¼å¼ç‚º YYYY.MM.DD HH:MM
                timeFormat = 'datetime_separate';
            } else {
                // å‡è¨­ç‚ºåˆä½µçš„æ—¥æœŸæ™‚é–“å­—ä¸²
                timeFormat = 'datetime_combined';
            }
            

            const parsedData = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // è·³éæ¨™é¡Œåˆ—æˆ–ç©ºè¡Œ
                if (line === '' || line.toLowerCase().includes('open') || line.toLowerCase().includes('time')) continue;

                const values = line.split(delimiter);
                
                let timestamp, open, high, low, close;

                try {
                    if (timeFormat === 'timestamp') {
                        if (values.length < 5) continue;
                        timestamp = parseInt(values[0]);
                        if (timestamp < 10000000000) timestamp *= 1000; // ç§’è½‰æ¯«ç§’
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    } else if (timeFormat === 'datetime_separate') {
                         // æ ¼å¼: Date Time O H L C
                        if (values.length < 6) continue;
                        const dateStr = `${values[0]} ${values[1]}`;
                        timestamp = new Date(dateStr.replace(/\./g, '-')).getTime();
                        open = parseFloat(values[2]);
                        high = parseFloat(values[3]);
                        low = parseFloat(values[4]);
                        close = parseFloat(values[5]);
                    } else if (timeFormat === 'datetime_combined') {
                        // æ ¼å¼: DateTime O H L C (é©ç”¨æ–¼æŸäº›é€—è™Ÿåˆ†éš”çš„æª”æ¡ˆ)
                        if (values.length < 5) continue;
                        timestamp = new Date(values[0].replace(/\./g, '-')).getTime();
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    }

                    if (isNaN(timestamp) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        continue;
                    }

                    parsedData.push({ time: timestamp, open, high, low, close });
                } catch (error) {
                    // console.warn(`Skipping line ${i+1} due to parsing error. Content: ${lines[i]}`);
                }
            }

            // ç¢ºä¿æ•¸æ“šæŒ‰æ™‚é–“æ’åº
            return parsedData.sort((a, b) => a.time - b.time);
        }

        // ----------------------------------------------------------------------------
        // 3. éŠæˆ²åˆå§‹åŒ–èˆ‡æµç¨‹æ§åˆ¶ (Game Initialization & Flow Control)
        // ----------------------------------------------------------------------------

        function init() {
            console.log("Initializing application...");
            cacheDOMElements();
            setupEventListeners();
            initChart();
            loadData();
        }

        // å¿«å–æ‰€æœ‰å¿…è¦çš„ DOM å…ƒç´ 
        function cacheDOMElements() {
            // HUD
            DOM.hudDate = document.getElementById('hud-date');
            DOM.hudEquity = document.getElementById('hud-equity');
            DOM.hudPL = document.getElementById('hud-pl');
            DOM.hudProgress = document.getElementById('hud-progress');
            // Controls
            DOM.btnPlayPause = document.getElementById('btnPlayPause');
            DOM.btnStepForward = document.getElementById('btnStepForward');
            DOM.speedSelector = document.getElementById('speedSelector');
            // Chart
            DOM.chartWrap = document.getElementById('chartWrap');
            DOM.chartCanvas = document.getElementById('chartCanvas');
            DOM.chartOverlay = document.getElementById('chartOverlay');
            // Sidebar
            DOM.inputLots = document.getElementById('inputLots');
            DOM.inputSL = document.getElementById('inputSL');
            DOM.inputTP = document.getElementById('inputTP');
            DOM.positionsList = document.getElementById('positionsList');
            DOM.historyList = document.getElementById('historyList');
            DOM.positionsCount = document.getElementById('positionsCount');
            DOM.btnCloseAll = document.getElementById('btnCloseAll');
            // Modals
            DOM.loader = document.getElementById('loader');
            DOM.eventModal = document.getElementById('eventModal');
            DOM.endGameModal = document.getElementById('endGameModal');
            // Tutorial
            DOM.tutorialHighlight = document.getElementById('tutorialHighlight');
            DOM.tutorialMessage = document.getElementById('tutorialMessage');
            DOM.tutorialText = document.getElementById('tutorialText');
            DOM.tutorialNextBtn = document.getElementById('tutorialNextBtn');
        }

        function startGame() {
            console.log("Starting new game...");
            resetState();
            selectRandomDataSegment();

            if (state.gameData.length === 0) {
                console.error("Game data is empty. Cannot start game.");
                return;
            }
            
            // Initialize chart view (Show first few candles)
            const initialVisibleCandles = calculateVisibleCandles();
            // åˆå§‹é¡¯ç¤ºç´„ 80% çš„å¯è¦–ç¯„åœ
            state.currentIndex = Math.min(Math.floor(initialVisibleCandles * 0.8), state.gameData.length - 1);
            
            state.isLoading = false;
            DOM.loader.classList.add('hidden');
            
            updateUI();
            requestAnimationFrame(draw);

            // Start tutorial
            startTutorial();
        }

        function resetState() {
            state.balance = CONFIG.INITIAL_BALANCE;
            state.equity = CONFIG.INITIAL_BALANCE;
            state.floatingPL = 0;
            state.openPositions = [];
            state.tradeHistory = [];
            state.orderIdCounter = 1;
            state.isPlaying = false;
            state.isEnded = false;
            state.currentIndex = 0;
            state.barAnimationProgress = 0;
            state.triggeredEvents.clear();
            // Reset chart view settings
            state.chart.candleWidth = CONFIG.CANDLE_WIDTH_DEFAULT;
            state.chart.candleSpacing = CONFIG.CANDLE_SPACING;
            state.chart.scrollOffset = 0;
            // Clear DOM overlays
            DOM.chartOverlay.innerHTML = '';
        }

        // éš¨æ©ŸæŠ½å–ä¸€å€‹æœˆçš„æ•¸æ“šå€é–“
        function selectRandomDataSegment() {
            const totalDurationMs = CONFIG.SIMULATION_DURATION_DAYS * 24 * 60 * 60 * 1000;
            
            if (state.rawData.length === 0) return;

            const dataDuration = state.rawData[state.rawData.length - 1].time - state.rawData[0].time;

            if (dataDuration < totalDurationMs) {
                console.warn("æ•¸æ“šç¸½é•·åº¦ä¸è¶³ä»¥æ»¿è¶³æ¨¡æ“¬æœŸé–“ã€‚ä½¿ç”¨æ‰€æœ‰å¯ç”¨æ•¸æ“šã€‚");
                state.gameData = [...state.rawData];
                return;
            }

            // å°‹æ‰¾éš¨æ©Ÿèµ·é»
            const latestStartTime = state.rawData[state.rawData.length - 1].time - totalDurationMs;
            const earliestStartTime = state.rawData[0].time;

            // åœ¨å¯èƒ½çš„æ™‚é–“ç¯„åœå…§éš¨æ©Ÿé¸æ“‡ä¸€å€‹é–‹å§‹æ™‚é–“
            const randomStartTime = earliestStartTime + Math.random() * (latestStartTime - earliestStartTime);

            // æ‰¾åˆ°å°æ‡‰æ­¤æ™‚é–“çš„ç´¢å¼•
            const startIndex = state.rawData.findIndex(d => d.time >= randomStartTime);

            const startTime = state.rawData[startIndex].time;
            const endTime = startTime + totalDurationMs;

            // æå–å€é–“
            state.gameData = state.rawData.filter(d => d.time >= startTime && d.time <= endTime);
            
            console.log(`é¸å–æ•¸æ“šå€é–“: ${state.gameData.length} æ ¹ K æ£’ã€‚å¾ ${new Date(startTime).toLocaleDateString()} é–‹å§‹ã€‚`);
        }

        let lastTickTime = 0;
        let animationFrameId;

        // ä¸»éŠæˆ²å¾ªç’° (ç”± requestAnimationFrame é©…å‹•)
        function gameLoop(timestamp) {
            if (!state.isPlaying || state.isEnded) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // è¨ˆç®—æ™‚é–“é–“éš”å’Œé€²åº¦
            const effectiveInterval = CONFIG.TICK_INTERVAL / state.speedMultiplier;
            const deltaTime = timestamp - lastTickTime;

            // ä½¿ç”¨ deltaTime è¨ˆç®—å‹•ç•«é€²åº¦ï¼Œç¢ºä¿æµæš¢æ€§
             if (deltaTime > 0) { 
                 const progressIncrement = deltaTime / effectiveInterval;
                 state.barAnimationProgress = Math.min(1, state.barAnimationProgress + progressIncrement);
                 
                 // åœ¨å‹•ç•«æœŸé–“æŒçºŒæ›´æ–°æŒå€‰å’Œå¸³æˆ¶
                 updatePositions();
                 updateAccount();
                 updateUI(); 

                 if (state.barAnimationProgress >= 1) {
                    // K æ£’å‹•ç•«å®Œæˆ
                    finalizeCurrentBar();
                    if (!advanceSimulation()) {
                        // éŠæˆ²çµæŸ
                        endGame();
                        return;
                    }
                    // é‡ç½®ä¸‹ä¸€æ ¹ K æ£’çš„ç‹€æ…‹
                    state.barAnimationProgress = 0;
                    checkForEvents();
                    
                    // å¦‚æœç”¨æˆ¶æ­£åœ¨æŸ¥çœ‹æ­·å²æ•¸æ“šï¼ˆscrollOffset > 0ï¼‰ï¼Œä¸è¦è‡ªå‹•æ»¾å‹•åˆ°æœ€æ–°
                    if (state.chart.scrollOffset > 0) {
                        // å¢åŠ æ»¾å‹•åç§»é‡ï¼Œä»¥åŒ¹é…æ–°ç”Ÿæˆçš„ K æ£’ï¼Œä¿æŒè¦–åœ–ä¸è®Š
                        state.chart.scrollOffset++;
                    }
                 }
                 lastTickTime = timestamp;
            }
            
            // ç¹ªåœ–
            draw();
            // ç¹¼çºŒå¾ªç’°
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function finalizeCurrentBar() {
            // ç¢ºä¿æœ€çµ‚æ›´æ–°ä½¿ç”¨æ”¶ç›¤åƒ¹
            state.barAnimationProgress = 1;
            updatePositions();
            updateAccount();
        }

        function advanceSimulation() {
            if (state.currentIndex < state.gameData.length - 1) {
                state.currentIndex++;
                return true;
            }
            return false;
        }

        function endGame() {
            console.log("æŒ‘æˆ°çµæŸã€‚");
            state.isPlaying = false;
            state.isEnded = true;
            cancelAnimationFrame(animationFrameId);
            
            // ä»¥æœ€å¾Œåƒ¹æ ¼å¹³å€‰æ‰€æœ‰å‰©é¤˜è¨‚å–®
            while(state.openPositions.length > 0) {
                const position = state.openPositions[0];
                const closePrice = state.gameData[state.currentIndex].close;
                closeOrder(position.id, closePrice);
            }

            updateAccount();
            updateUI();
            showEndGameModal();
        }

        // ----------------------------------------------------------------------------
        // 4. åœ–è¡¨ç¹ªè£½èˆ‡æ¸²æŸ“ (Chart Drawing & Rendering)
        // ----------------------------------------------------------------------------

        function initChart() {
            state.chart.canvas = DOM.chartCanvas;
            state.chart.ctx = state.chart.canvas.getContext('2d');
            resizeCanvas();
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = DOM.chartWrap.getBoundingClientRect();
            // ç¢ºä¿å¯¬é«˜ç‚ºæ•´æ•¸
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);

            state.chart.canvas.width = width * dpr;
            state.chart.canvas.height = height * dpr;
            // è¨­ç½® CSS å°ºå¯¸
            state.chart.canvas.style.width = `${width}px`;
            state.chart.canvas.style.height = `${height}px`;

            state.chart.ctx.scale(dpr, dpr);
            state.chart.width = width;
            state.chart.height = height;

            // é‡æ–°è¨ˆç®—æ»¾å‹•ä½ç½®ï¼Œé˜²æ­¢å› ç¸®æ”¾å°è‡´è¦–åœ–éŒ¯èª¤
            validateScrollOffset();

            if (!state.isLoading) {
                draw();
            }
        }

        function draw() {
            // ä½¿ç”¨ requestAnimationFrame å°è£ç¹ªåœ–æ“ä½œï¼Œç¢ºä¿ä¸æœƒéåº¦ç¹ªè£½
            // å¦‚æœéŠæˆ²æ­£åœ¨é‹è¡Œï¼ŒgameLoop å·²ç¶“è™•ç†äº† rAFã€‚å¦‚æœæš«åœï¼Œå‰‡æ‰‹å‹•è§¸ç™¼ã€‚
            if (state.isLoading) return;

            const ctx = state.chart.ctx;
            // 1. æ¸…ç©ºç•«å¸ƒ
            ctx.clearRect(0, 0, state.chart.width, state.chart.height);

            // 2. è¨ˆç®—è¦–åœ–ç¯„åœå’Œåƒ¹æ ¼ç¯„åœ
            calculateViewport();

            // 3. ç¹ªè£½åœ–è¡¨å…ƒç´ 
            drawBackground(ctx);
            drawGrid(ctx);
            drawCandles(ctx);
            drawYAxis(ctx);
            drawXAxis(ctx);
            drawCrosshair(ctx);
            drawTradeAnimations(ctx);
            
            // 4. æ›´æ–° DOM ç–ŠåŠ å±¤ (æŒå€‰ç·š)
            updatePositionOverlays();
        }

        function calculateVisibleCandles() {
            const { width, candleWidth, candleSpacing } = state.chart;
            const { left, right } = CONFIG.CHART_PADDING;
            const chartAreaWidth = width - left - right;
            const candleUnitWidth = candleWidth + candleSpacing;
            if (candleUnitWidth <= 0) return 100; // é¿å…é™¤ä»¥é›¶
            return Math.floor(chartAreaWidth / candleUnitWidth);
        }

        function calculateViewport() {
            const visibleCandles = calculateVisibleCandles();

            // æ ¹æ“š currentIndex å’Œ scrollOffset ç¢ºå®šå¯è¦–ç¯„åœ
            // endIndex æ˜¯å¯è¦–ç¯„åœæœ€å³å´çš„ K æ£’ç´¢å¼• (ä¸åŒ…å«)
            let endIndex = state.currentIndex + 1 - state.chart.scrollOffset;
            // startIndex æ˜¯å¯è¦–ç¯„åœæœ€å·¦å´çš„ K æ£’ç´¢å¼•
            let startIndex = endIndex - visibleCandles;

            // é‚Šç•Œæª¢æŸ¥
            if (endIndex > state.currentIndex + 1) {
                endIndex = state.currentIndex + 1;
                startIndex = Math.max(0, endIndex - visibleCandles);
            }
            if (startIndex < 0) {
                startIndex = 0;
                // ç¢ºä¿ endIndex ä¸æœƒè¶…å‡ºç•¶å‰æ•¸æ“šç¯„åœ
                endIndex = Math.min(state.currentIndex + 1, visibleCandles);
            }
            
            state.chart.viewStartIndex = startIndex;
            state.chart.viewEndIndex = endIndex;

            // è¨ˆç®—åƒ¹æ ¼ç¯„åœ
            let minPrice = Infinity;
            let maxPrice = -Infinity;

            for (let i = startIndex; i < endIndex; i++) {
                // ç¢ºä¿ç´¢å¼•åœ¨ gameData ç¯„åœå…§
                if (i >= state.gameData.length) break; 
                const bar = state.gameData[i];

                // å°æ–¼ç•¶å‰æ´»å‹•çš„ K æ£’ï¼Œä¸”è¦–åœ–åœ¨æœ€å³å´æ™‚ï¼Œè€ƒæ…®å‹•ç•«åƒ¹æ ¼
                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    const animatedBar = getAnimatedBar(bar);
                    minPrice = Math.min(minPrice, animatedBar.low);
                    maxPrice = Math.max(maxPrice, animatedBar.high);
                } else {
                    minPrice = Math.min(minPrice, bar.low);
                    maxPrice = Math.max(maxPrice, bar.high);
                }
            }

            // å¢åŠ åƒ¹æ ¼ç¯„åœçš„ç·©è¡
            const priceRange = maxPrice - minPrice;
            if (priceRange <= 0 || !isFinite(priceRange)) {
                const padding = 0.5;
                state.chart.minPrice = (minPrice === Infinity ? 1900 : minPrice) - padding;
                state.chart.maxPrice = (maxPrice === -Infinity ? 1901 : maxPrice) + padding;
            } else {
                const padding = priceRange * 0.1;
                state.chart.minPrice = minPrice - padding;
                state.chart.maxPrice = maxPrice + padding;
            }
        }

        // è¼”åŠ©å‡½å¼ï¼šåƒ¹æ ¼è½‰ Y åº§æ¨™
        function priceToY(price) {
            const { height, minPrice, maxPrice } = state.chart;
            const { top, bottom } = CONFIG.CHART_PADDING;
            const chartAreaHeight = height - top - bottom;
            const priceRange = maxPrice - minPrice;
            
            if (priceRange === 0) return top + chartAreaHeight / 2;

            return top + chartAreaHeight * (1 - (price - minPrice) / priceRange);
        }

        // è¼”åŠ©å‡½å¼ï¼šç´¢å¼•è½‰ X åº§æ¨™
        function indexToX(index) {
            const { viewStartIndex, candleWidth, candleSpacing } = state.chart;
            const { left } = CONFIG.CHART_PADDING;
            const candleUnitWidth = candleWidth + candleSpacing;
            // è¨ˆç®—ç›¸å°æ–¼ viewStartIndex çš„ä½ç½®
            return left + (index - viewStartIndex) * candleUnitWidth + candleWidth / 2;
        }

        function drawBackground(ctx) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg');
            ctx.fillRect(0, 0, state.chart.width, state.chart.height);
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid');
            ctx.lineWidth = 1;

            // æ°´å¹³ç¶²æ ¼ç·š (åŸºæ–¼ Y è»¸åˆ»åº¦)
            const yTicks = calculateYAxisTicks();
            yTicks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.beginPath();
                ctx.moveTo(CONFIG.CHART_PADDING.left, y);
                ctx.lineTo(state.chart.width - CONFIG.CHART_PADDING.right, y);
                ctx.stroke();
            });

            // å‚ç›´ç¶²æ ¼ç·š (åŸºæ–¼ X è»¸åˆ»åº¦)
            const xTicks = calculateXAxisTicks();
            xTicks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= CONFIG.CHART_PADDING.left && x <= state.chart.width - CONFIG.CHART_PADDING.right) {
                    ctx.beginPath();
                    ctx.moveTo(x, CONFIG.CHART_PADDING.top);
                    ctx.lineTo(x, state.chart.height - CONFIG.CHART_PADDING.bottom);
                    ctx.stroke();
                }
            });
        }

        // æ ¸å¿ƒåŠŸèƒ½ï¼šK æ£’å‹•ç•«é‚è¼¯ (é–‹ç›¤ -> å½±ç·š -> å¯¦é«”)
        function getAnimatedBar(bar) {
            const progress = state.barAnimationProgress;
            const open = bar.open;
            
            // 1. å½±ç·š (Wicks) - å‡è¨­å½±ç·šåœ¨å‹•ç•«çš„å‰åŠæ®µ (50%) å½¢æˆ
            const wickProgress = Math.min(1, progress * 2);
            const high = open + (bar.high - open) * wickProgress;
            const low = open + (bar.low - open) * wickProgress;

            // 2. å¯¦é«” (Body/Close) - å¾é–‹ç›¤åƒ¹ç·šæ€§å¢é•·åˆ°æ”¶ç›¤åƒ¹
            const close = open + (bar.close - open) * progress;

            // ç¢ºä¿ High/Low å§‹çµ‚åŒ…å«ç•¶å‰çš„ Open å’Œ Close åƒ¹æ ¼
            const finalHigh = Math.max(high, close, open);
            const finalLow = Math.min(low, close, open);

            return { open, high: finalHigh, low: finalLow, close };
        }

        function drawCandles(ctx) {
            const { viewStartIndex, viewEndIndex, candleWidth } = state.chart;
            const colorBull = getComputedStyle(document.documentElement).getPropertyValue('--color-bull');
            const colorBear = getComputedStyle(document.documentElement).getPropertyValue('--color-bear');

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                 if (i >= state.gameData.length) break;
                const bar = state.gameData[i];
                let displayBar = bar;

                // åƒ…å°ç•¶å‰æ´»å‹•çš„ K æ£’ä¸”è¦–åœ–åœ¨æœ€å³å´æ™‚æ‡‰ç”¨å‹•ç•«
                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    displayBar = getAnimatedBar(bar);
                }

                const x = indexToX(i);
                const openY = priceToY(displayBar.open);
                const highY = priceToY(displayBar.high);
                const lowY = priceToY(displayBar.low);
                const closeY = priceToY(displayBar.close);

                const color = displayBar.close >= displayBar.open ? colorBull : colorBear;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;

                // ç¹ªè£½å½±ç·š
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                // ç¹ªè£½å¯¦é«”
                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(openY - closeY);
                
                // ç¢ºä¿å¯¦é«”è‡³å°‘æœ‰ 1px é«˜åº¦
                const finalHeight = Math.max(1, bodyHeight);

                ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, finalHeight);
            }
        }

        // è¨ˆç®—åˆé©çš„ Y è»¸åˆ»åº¦
        function calculateYAxisTicks() {
            const { minPrice, maxPrice } = state.chart;
            const priceRange = maxPrice - minPrice;
            
            if (priceRange <= 0) return [];

            // å‹•æ…‹èª¿æ•´åˆ»åº¦é–“è·
            let magnitude = Math.pow(10, Math.floor(Math.log10(priceRange)));
            let normalizedRange = priceRange / magnitude;

            let tickSpacing;
            if (normalizedRange > 5) tickSpacing = magnitude;
            else if (normalizedRange > 2) tickSpacing = magnitude * 0.5;
            else tickSpacing = magnitude * 0.2;

            const ticks = [];
            let currentTick = Math.ceil(minPrice / tickSpacing) * tickSpacing;

            while (currentTick <= maxPrice) {
                ticks.push({ price: currentTick });
                currentTick += tickSpacing;
            }
            return ticks;
        }

        function drawYAxis(ctx) {
            const { width, height } = state.chart;
            const { right } = CONFIG.CHART_PADDING;
            const axisX = width - right;

            // ç¹ªè£½è»¸èƒŒæ™¯å’Œé‚Šæ¡†
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg');
            ctx.fillRect(axisX, 0, right, height);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border');
            ctx.beginPath();
            ctx.moveTo(axisX, 0);
            ctx.lineTo(axisX, height);
            ctx.stroke();

            // ç¹ªè£½åˆ»åº¦æ–‡å­—
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary');
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            const ticks = calculateYAxisTicks();
            ticks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.fillText(tick.price.toFixed(2), axisX + 5, y);
            });

            // ç¹ªè£½ç•¶å‰åƒ¹æ ¼æŒ‡ç¤ºå™¨
            if (state.currentIndex < state.gameData.length && state.chart.scrollOffset === 0) {
                const currentPrice = getCurrentPrice();
                const currentY = priceToY(currentPrice);
                
                const color = currentPrice >= state.gameData[state.currentIndex].open 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull')
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-bear');

                ctx.fillStyle = color;
                ctx.fillRect(axisX, currentY - 10, right, 20);
                
                ctx.fillStyle = 'white';
                ctx.fillText(currentPrice.toFixed(2), axisX + 5, currentY);
            }
        }

        // è¨ˆç®—åˆé©çš„ X è»¸åˆ»åº¦
        function calculateXAxisTicks() {
            const { viewStartIndex, viewEndIndex } = state.chart;
            if (viewEndIndex <= viewStartIndex || viewStartIndex >= state.gameData.length) return [];

            // æ ¹æ“šå¯è¦–ç¯„åœæ±ºå®šæ™‚é–“é–“éš”
            const timeDiff = state.gameData[viewEndIndex - 1].time - state.gameData[viewStartIndex].time;

            let intervalMs;
            if (timeDiff < 2 * 3600 * 1000) intervalMs = 15 * 60 * 1000; // 15 åˆ†é˜
            else if (timeDiff < 12 * 3600 * 1000) intervalMs = 60 * 60 * 1000; // 1 å°æ™‚
            else if (timeDiff < 48 * 3600 * 1000) intervalMs = 4 * 3600 * 1000; // 4 å°æ™‚
            else intervalMs = 24 * 3600 * 1000; // 1 å¤©

            const ticks = [];
            let lastTickTime = 0;

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                const time = state.gameData[i].time;
                if (time - lastTickTime >= intervalMs) {
                    ticks.push({ index: i, time: time });
                    lastTickTime = time;
                }
            }
            return ticks;
        }

        function drawXAxis(ctx) {
            const { width, height } = state.chart;
            const { bottom } = CONFIG.CHART_PADDING;
            const axisY = height - bottom;

            // ç¹ªè£½è»¸èƒŒæ™¯å’Œé‚Šæ¡†
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg');
            ctx.fillRect(0, axisY, width, bottom);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border');
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(width - CONFIG.CHART_PADDING.right, axisY);
            ctx.stroke();

            // ç¹ªè£½åˆ»åº¦æ–‡å­—
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary');
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const ticks = calculateXAxisTicks();
            ticks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= CONFIG.CHART_PADDING.left && x <= width - CONFIG.CHART_PADDING.right) {
                    const date = new Date(tick.time);
                    
                    // æ ¹æ“šæ™‚é–“è·¨åº¦æ±ºå®šé¡¯ç¤ºæ ¼å¼
                    const timeDiff = state.gameData[state.chart.viewEndIndex - 1].time - state.gameData[state.chart.viewStartIndex].time;

                    let label;
                    if (timeDiff < 48 * 3600 * 1000) {
                        // é¡¯ç¤ºæ™‚é–“
                        label = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                    } else {
                        // é¡¯ç¤ºæ—¥æœŸ
                        label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' });
                    }
                    
                    ctx.fillText(label, x, axisY + 5);
                }
            });
        }

        function drawCrosshair(ctx) {
            if (!state.mouse.isOverChart || state.chart.isDragging) return;

            const { x, y } = state.mouse;
            const { left, right, top, bottom } = CONFIG.CHART_PADDING;

            if (x < left || x > state.chart.width - right || y < top || y > state.chart.height - bottom) return;

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-crosshair');
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // æ°´å¹³ç·š
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(state.chart.width - right, y);
            ctx.stroke();

            // å‚ç›´ç·š
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, state.chart.height - bottom);
            ctx.stroke();

            ctx.setLineDash([]);
        }

        // æ ¸å¿ƒåŠŸèƒ½ï¼šDOM ç–ŠåŠ å±¤ (æŒå€‰ç·š)
        function updatePositionOverlays() {
            const overlay = DOM.chartOverlay;
            // ä½¿ç”¨ Set ä¾†é«˜æ•ˆè¿½è¹¤éœ€è¦ä¿ç•™çš„ç·šæ¢
            const linesToKeep = new Set();

            state.openPositions.forEach(pos => {
                const entryId = `line-entry-${pos.id}`;
                const slId = `line-sl-${pos.id}`;
                const tpId = `line-tp-${pos.id}`;
                
                // é€²å ´ç·š
                const entryColor = pos.type === 'BUY' ? 'var(--color-bull)' : 'var(--color-bear)';
                createOrUpdatePositionLine(overlay, entryId, pos.entryPrice, entryColor, `Entry ${pos.entryPrice.toFixed(2)}`, pos);
                linesToKeep.add(entryId);

                // SL ç·š
                if (pos.sl) {
                    createOrUpdatePositionLine(overlay, slId, pos.sl, 'var(--color-danger)', `SL ${pos.sl.toFixed(2)}`);
                    linesToKeep.add(slId);
                }

                // TP ç·š
                if (pos.tp) {
                    createOrUpdatePositionLine(overlay, tpId, pos.tp, 'var(--color-success)', `TP ${pos.tp.toFixed(2)}`);
                    linesToKeep.add(tpId);
                }
            });

            // ç§»é™¤ä¸å†éœ€è¦çš„ç·šæ¢
            Array.from(overlay.children).forEach(child => {
                if (child.classList.contains('position-line') && !linesToKeep.has(child.id)) {
                    overlay.removeChild(child);
                }
            });
        }

        function createOrUpdatePositionLine(container, id, price, color, labelText, position = null) {
            let line = document.getElementById(id);
            // å»ºç«‹æ–°å…ƒç´ å¦‚æœä¸å­˜åœ¨
            if (!line) {
                line = document.createElement('div');
                line.id = id;
                line.className = 'position-line';
                
                const dash = document.createElement('div');
                dash.className = 'position-line-dash';
                line.appendChild(dash);

                const label = document.createElement('div');
                label.className = 'position-label';
                line.appendChild(label);

                container.appendChild(line);
            }

            const y = priceToY(price);
            
            // å¦‚æœè¶…å‡ºåœ–è¡¨å¯è¦–ç¯„åœå‰‡éš±è—
            if (y < CONFIG.CHART_PADDING.top || y > state.chart.height - CONFIG.CHART_PADDING.bottom) {
                line.style.opacity = 0;
            } else {
                line.style.opacity = 1;
                line.style.top = `${y - 10}px`; // å‚ç›´å±…ä¸­èª¿æ•´
            }

            // æ›´æ–°æ¨£å¼å’Œå…§å®¹
            const dash = line.querySelector('.position-line-dash');
            dash.style.borderTopColor = color;

            const label = line.querySelector('.position-label');
            label.style.backgroundColor = color;
            label.textContent = labelText;

            // é¡¯ç¤ºå³æ™‚æç›Š (åƒ…é©ç”¨æ–¼é€²å ´ç·š)
            if (position) {
                let plDisplay = line.querySelector('.position-pl');
                if (!plDisplay) {
                    plDisplay = document.createElement('div');
                    plDisplay.className = 'position-pl';
                    // å°‡æç›Šé¡¯ç¤ºåœ¨ç·šæ¢å·¦å´
                    line.insertBefore(plDisplay, dash);
                }
                plDisplay.textContent = `$${position.profit.toFixed(2)}`;
                plDisplay.style.color = position.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger';
            }
        }

        // æ ¸å¿ƒåŠŸèƒ½ï¼šæˆäº¤å‹•ç•«
        const tradeAnimations = [];

        function addTradeAnimation(type, price, index, profit = 0) {
            tradeAnimations.push({
                type,
                price,
                index,
                profit,
                startTime: performance.now(),
                duration: type === 'CLOSE' ? 1500 : 1000,
            });
            // è§¸ç™¼ä¸€æ¬¡é‡ç¹ªä»¥é¡¯ç¤ºå‹•ç•«
            if (!state.isPlaying) {
                draw();
            }
        }

        function drawTradeAnimations(ctx) {
            const now = performance.now();
            
            for (let i = tradeAnimations.length - 1; i >= 0; i--) {
                const anim = tradeAnimations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);
                const opacity = 1 - progress;

                const x = indexToX(anim.index);
                const y = priceToY(anim.price);

                // å¦‚æœå‹•ç•«ä½ç½®åœ¨è¦–åœ–å¤–ï¼Œå‰‡è·³é
                if (x < CONFIG.CHART_PADDING.left || x > state.chart.width - CONFIG.CHART_PADDING.right) {
                     if (progress >= 1) {
                        tradeAnimations.splice(i, 1);
                    }
                    continue;
                }

                ctx.globalAlpha = opacity;

                if (anim.type === 'BUY' || anim.type === 'SELL') {
                    // é–‹å€‰ç®­é ­å‹•ç•«
                    const color = anim.type === 'BUY' ? 'var(--color-bull)' : 'var(--color-bear)';
                    ctx.fillStyle = color;
                    
                    const size = 10 + progress * 3; // è¼•å¾®æ”¾å¤§æ•ˆæœ
                    const offsetY = anim.type === 'BUY' ? 15 : -15;
                    
                    ctx.beginPath();
                    if (anim.type === 'BUY') {
                        // å‘ä¸Šç®­é ­
                        ctx.moveTo(x, y - offsetY);
                        ctx.lineTo(x - size/2, y - offsetY + size);
                        ctx.lineTo(x + size/2, y - offsetY + size);
                    } else {
                        // å‘ä¸‹ç®­é ­
                        ctx.moveTo(x, y - offsetY);
                        ctx.lineTo(x - size/2, y - offsetY - size);
                        ctx.lineTo(x + size/2, y - offsetY - size);
                    }
                    ctx.closePath();
                    ctx.fill();

                } else if (anim.type === 'CLOSE') {
                    // å¹³å€‰æç›Šæ•¸å­—æ¼‚æµ®å‹•ç•«
                    const color = anim.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)';
                    ctx.fillStyle = color;
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    
                    const floatY = y - progress * 50; // å‘ä¸Šæ¼‚æµ®
                    ctx.fillText(`$${anim.profit.toFixed(2)}`, x, floatY);
                }

                ctx.globalAlpha = 1;

                if (progress >= 1) {
                    tradeAnimations.splice(i, 1);
                }
            }

            // å¦‚æœé‚„æœ‰å‹•ç•«æ­£åœ¨é€²è¡Œï¼Œä¸”éŠæˆ²æš«åœäº†ï¼Œç¹¼çºŒè«‹æ±‚ä¸‹ä¸€å¹€ä»¥å®Œæˆå‹•ç•«
            if (tradeAnimations.length > 0 && !state.isPlaying) {
                requestAnimationFrame(draw); 
            }
        }


        // ----------------------------------------------------------------------------
        // 5. äº¤æ˜“é‚è¼¯èˆ‡å¸³æˆ¶ç®¡ç† (Trading Logic & Account Management)
        // ----------------------------------------------------------------------------

        function getCurrentPrice() {
            if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return 0;
            const currentBar = state.gameData[state.currentIndex];
            // ä½¿ç”¨å‹•ç•«çš„å³æ™‚åƒ¹æ ¼
            return getAnimatedBar(currentBar).close;
        }

        function openOrder(type, lots, sl = null, tp = null) {
            if (state.isEnded) return;

            const entryPrice = getCurrentPrice();

            // é¢¨éšªç®¡ç†é©—è­‰
            if (type === 'BUY') {
                if (sl && sl >= entryPrice) {
                    alert("åœæåƒ¹æ ¼å¿…é ˆä½æ–¼è²·å…¥åƒ¹æ ¼ã€‚");
                    return;
                }
                if (tp && tp <= entryPrice) {
                    alert("åœåˆ©åƒ¹æ ¼å¿…é ˆé«˜æ–¼è²·å…¥åƒ¹æ ¼ã€‚");
                    return;
                }
            } else { // SELL
                if (sl && sl <= entryPrice) {
                    alert("åœæåƒ¹æ ¼å¿…é ˆé«˜æ–¼è³£å‡ºåƒ¹æ ¼ã€‚");
                    return;
                }
                if (tp && tp >= entryPrice) {
                    alert("åœåˆ©åƒ¹æ ¼å¿…é ˆä½æ–¼è³£å‡ºåƒ¹æ ¼ã€‚");
                    return;
                }
            }

            const position = {
                id: state.orderIdCounter++,
                type: type,
                lots: lots,
                entryPrice: entryPrice,
                entryTime: state.gameData[state.currentIndex].time,
                sl: sl,
                tp: tp,
                profit: 0,
            };

            state.openPositions.push(position);

            // è§¸ç™¼æˆäº¤å‹•ç•«
            addTradeAnimation(type, entryPrice, state.currentIndex);

            updateUI();
             if (!state.isPlaying) {
                draw();
            }

            // æ–°æ‰‹å°å¼•æ­¥é©Ÿå®Œæˆæª¢æŸ¥
            if (state.tutorialActive) {
                completeTutorialStep();
            }
        }

        function closeOrder(id, closePrice) {
            const index = state.openPositions.findIndex(p => p.id === id);
            if (index === -1) return;

            const position = state.openPositions[index];
            const profit = calculateProfit(position, closePrice);

            state.balance += profit;
            
            const historyEntry = {
                ...position,
                closePrice: closePrice,
                // ç¢ºä¿ä½¿ç”¨ç•¶å‰çš„æ™‚é–“æˆ³
                closeTime: state.gameData[state.currentIndex]?.time || position.entryTime,
                profit: profit,
            };
            state.tradeHistory.push(historyEntry);
            state.openPositions.splice(index, 1);

            // è§¸ç™¼å¹³å€‰å‹•ç•«
            addTradeAnimation('CLOSE', closePrice, state.currentIndex, profit);

            updateAccount();
            updateUI();
            if (!state.isPlaying) {
                draw();
            }
        }

        function calculateProfit(position, currentPrice) {
            let priceDiff = 0;
            if (position.type === 'BUY') {
                priceDiff = currentPrice - position.entryPrice;
            } else {
                priceDiff = position.entryPrice - currentPrice;
            }
            // Profit = Price Difference * Contract Size * Lots
            return priceDiff * CONFIG.CONTRACT_SIZE * position.lots;
        }

        function updatePositions() {
            if (state.currentIndex >= state.gameData.length) return;

            // ä½¿ç”¨å‹•ç•«æœŸé–“çš„ High/Low ä¾†é€²è¡Œæ›´çœŸå¯¦çš„ SL/TP æª¢æŸ¥
            const currentBar = state.gameData[state.currentIndex];
            const animatedBar = getAnimatedBar(currentBar);
            const currentPrice = animatedBar.close;
            const currentHigh = animatedBar.high;
            const currentLow = animatedBar.low;

            const positionsToClose = [];

            state.openPositions.forEach(pos => {
                // æ›´æ–°æµ®å‹•æç›Š (åŸºæ–¼ Close åƒ¹æ ¼)
                pos.profit = calculateProfit(pos, currentPrice);

                // æª¢æŸ¥ SL/TP (åŸºæ–¼ High/Low åƒ¹æ ¼)
                if (pos.type === 'BUY') {
                    if (pos.sl && currentLow <= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } else if (pos.tp && currentHigh >= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                } else { // SELL
                    if (pos.sl && currentHigh >= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } else if (pos.tp && currentLow <= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                }
            });

            // åŸ·è¡Œå¹³å€‰
            positionsToClose.forEach(order => {
                closeOrder(order.id, order.price);
            });
        }

        function updateAccount() {
            state.floatingPL = state.openPositions.reduce((sum, pos) => sum + pos.profit, 0);
            state.equity = state.balance + state.floatingPL;
        }

        // ----------------------------------------------------------------------------
        // 6. UI æ›´æ–°èˆ‡äº’å‹• (UI Updates & Interaction)
        // ----------------------------------------------------------------------------

        function updateUI() {
            updateHUD();
            updatePositionsPanel();
            updateHistoryPanel();
            updateControls();
        }

        function updateHUD() {
            if (state.gameData.length === 0) return;

            let displayIndex = state.currentIndex;
            if (displayIndex >= state.gameData.length) {
                displayIndex = state.gameData.length - 1;
            }

            const currentDate = new Date(state.gameData[displayIndex].time);
            DOM.hudDate.textContent = currentDate.toLocaleString('zh-TW', { hour12: false });
            DOM.hudEquity.textContent = `$${state.equity.toFixed(2)}`;
            DOM.hudPL.textContent = `$${state.floatingPL.toFixed(2)}`;
            
            DOM.hudPL.classList.toggle('positive', state.floatingPL > 0);
            DOM.hudPL.classList.toggle('negative', state.floatingPL < 0);

            const progress = (displayIndex / (state.gameData.length - 1)) * 100;
            DOM.hudProgress.style.width = `${progress}%`;
        }

        function updatePositionsPanel() {
            DOM.positionsList.innerHTML = '';
            DOM.positionsCount.textContent = state.openPositions.length;
            DOM.btnCloseAll.style.display = state.openPositions.length > 0 ? 'block' : 'none';

            state.openPositions.forEach(pos => {
                const item = document.createElement('div');
                item.className = 'trade-item';
                item.innerHTML = `
                    <div class="trade-header">
                        <span class="trade-type ${pos.type}">#${pos.id} ${pos.type} ${pos.lots.toFixed(2)}</span>
                        <span style="color: ${pos.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)'}">$${pos.profit.toFixed(2)}</span>
                    </div>
                    <div class="trade-details">
                        <div>
                            <div class="trade-detail-label">Entry</div>
                            <div>${pos.entryPrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">SL</div>
                            <div>${pos.sl ? pos.sl.toFixed(2) : 'N/A'}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">TP</div>
                            <div>${pos.tp ? pos.tp.toFixed(2) : 'N/A'}</div>
                        </div>
                    </div>
                    <div class="trade-actions">
                        <button class="btn btn-small btn-secondary btn-modify" data-id="${pos.id}">ä¿®æ”¹</button>
                        <button class="btn btn-small btn-danger btn-close" data-id="${pos.id}">å¹³å€‰</button>
                    </div>
                `;
                DOM.positionsList.appendChild(item);
            });

            // ç¶å®šäº‹ä»¶ç›£è½å™¨
            DOM.positionsList.querySelectorAll('.btn-close').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.id);
                    const currentPrice = getCurrentPrice();
                    closeOrder(id, currentPrice);
                });
            });

            DOM.positionsList.querySelectorAll('.btn-modify').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.id);
                    modifyOrder(id);
                });
            });
        }

        function updateHistoryPanel() {
            // åƒ…åœ¨æ­·å²è¨˜éŒ„é•·åº¦æ”¹è®Šæ™‚æ›´æ–°ï¼Œæé«˜æ•ˆç‡
            if (DOM.historyList.children.length === state.tradeHistory.length) return;

            DOM.historyList.innerHTML = '';
            // é¡¯ç¤ºæœ€æ–°çš„äº¤æ˜“åœ¨æœ€ä¸Šé¢
            const sortedHistory = [...state.tradeHistory].reverse();

            sortedHistory.forEach(trade => {
                const item = document.createElement('div');
                item.className = 'trade-item';
                item.innerHTML = `
                    <div class="trade-header">
                        <span class="trade-type ${trade.type}">#${trade.id} ${trade.type} ${trade.lots.toFixed(2)}</span>
                        <span style="color: ${trade.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)'}">$${trade.profit.toFixed(2)}</span>
                    </div>
                    <div class="trade-details">
                        <div>
                            <div class="trade-detail-label">Open</div>
                            <div>${trade.entryPrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">Close</div>
                            <div>${trade.closePrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">Duration</div>
                            <div>${formatDuration(trade.closeTime - trade.entryTime)}</div>
                        </div>
                    </div>
                `;
                DOM.historyList.appendChild(item);
            });
        }

        function updateControls() {
            DOM.btnPlayPause.textContent = state.isPlaying ? 'â¸ï¸ æš«åœ' : 'â–¶ï¸ æ’­æ”¾';
            DOM.btnStepForward.disabled = state.isPlaying || state.isEnded;
            DOM.btnPlayPause.disabled = state.isEnded;
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);

            // Controls
            DOM.btnPlayPause.addEventListener('click', togglePlayPause);
            DOM.btnStepForward.addEventListener('click', stepForward);
            DOM.speedSelector.addEventListener('click', handleSpeedChange);
            document.getElementById('btnZoomIn').addEventListener('click', () => zoomChart(1.2));
            document.getElementById('btnZoomOut').addEventListener('click', () => zoomChart(1/1.2));

            // Trading Panel Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', handleTabSwitch);
            });

            // Order Inputs (Steppers)
            setupInputStepper('lotsUp', 'inputLots', 0.01);
            setupInputStepper('lotsDown', 'inputLots', -0.01);
            setupInputStepper('slUp', 'inputSL', 0.1);
            setupInputStepper('slDown', 'inputSL', -0.1);
            setupInputStepper('tpUp', 'inputTP', 0.1);
            setupInputStepper('tpDown', 'inputTP', -0.1);

            // Trade Buttons
            document.getElementById('btnBuy').addEventListener('click', () => handleTrade('BUY'));
            document.getElementById('btnSell').addEventListener('click', () => handleTrade('SELL'));
            DOM.btnCloseAll.addEventListener('click', closeAllOrders);

            // Chart Interaction
            DOM.chartWrap.addEventListener('mousemove', handleMouseMove);
            DOM.chartWrap.addEventListener('mouseleave', handleMouseLeave);
            DOM.chartWrap.addEventListener('wheel', handleMouseWheel, { passive: false });
            DOM.chartWrap.addEventListener('mousedown', handleDragStart);
            // ä½¿ç”¨ window ç›£è½ mousemove å’Œ mouseup ä»¥ç¢ºä¿æ‹–å‹•è¶…å‡ºåœ–è¡¨ç¯„åœæ™‚ä»èƒ½éŸ¿æ‡‰
            window.addEventListener('mousemove', handleDragging);
            window.addEventListener('mouseup', handleDragEnd);


            // Modal Buttons
            document.getElementById('eventContinueBtn').addEventListener('click', continueFromEvent);
            document.getElementById('restartButton').addEventListener('click', startGame);
        }

        // Event Handlers
        function togglePlayPause() {
            if (state.isEnded) return;
            state.isPlaying = !state.isPlaying;
            
            if (state.isPlaying) {
                lastTickTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                cancelAnimationFrame(animationFrameId);
            }
            updateControls();

            // Tutorial step completion
            if (state.tutorialActive) {
                completeTutorialStep();
            }
        }

        function stepForward() {
            if (state.isPlaying || state.isEnded) return;
            
            finalizeCurrentBar();
            if (!advanceSimulation()) {
                endGame();
            } else {
                state.barAnimationProgress = 1; // ç«‹å³é¡¯ç¤º K æ£’
                updatePositions();
                updateAccount();
                updateUI();
                checkForEvents();
                // å¦‚æœåœ¨æ­·å²è¦–åœ–ä¸­ï¼Œæ‰‹å‹•å‰é€²æ™‚æ‡‰æ¸›å°‘ scrollOffset ä»¥è·Ÿéš¨æœ€æ–° K æ£’
                if (state.chart.scrollOffset > 0) {
                    state.chart.scrollOffset = Math.max(0, state.chart.scrollOffset - 1);
                }
                draw();
            }
        }

        function handleSpeedChange(e) {
            if (e.target.classList.contains('speed-btn')) {
                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.speedMultiplier = parseInt(e.target.dataset.speed);
            }
        }

        function handleTabSwitch(e) {
            const target = e.target.closest('.tab-btn');
            if (!target) return;

            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            target.classList.add('active');
            document.getElementById(target.dataset.target).classList.add('active');

             // Tutorial step completion
            if (state.tutorialActive && target.dataset.target === 'tabPositions') {
                completeTutorialStep();
            }
        }

        function handleTrade(type) {
            const lots = parseFloat(DOM.inputLots.value);
            const sl = DOM.inputSL.value ? parseFloat(DOM.inputSL.value) : null;
            const tp = DOM.inputTP.value ? parseFloat(DOM.inputTP.value) : null;

            if (isNaN(lots) || lots <= 0) {
                alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ‰‹æ•¸ã€‚");
                return;
            }

            openOrder(type, lots, sl, tp);
        }

        function closeAllOrders() {
            if (state.openPositions.length === 0) return;
            const currentPrice = getCurrentPrice();
            // ä½¿ç”¨ while è¿´åœˆç¢ºä¿å…¨éƒ¨é—œé–‰
            while(state.openPositions.length > 0) {
                closeOrder(state.openPositions[0].id, currentPrice);
            }
        }

        function modifyOrder(id) {
            const position = state.openPositions.find(p => p.id === id);
            if (!position) return;

            // ä½¿ç”¨ prompt é€²è¡Œç°¡å–®ä¿®æ”¹ (åœ¨å¯¦éš›æ‡‰ç”¨ä¸­æ‡‰ä½¿ç”¨è‡ªå®šç¾© Modal)
            const newSL = prompt(`ä¿®æ”¹è¨‚å–® #${id} åœæ (SL)ã€‚ç•™ç©ºå‰‡å–æ¶ˆ SLã€‚ç›®å‰: ${position.sl ? position.sl.toFixed(2) : 'N/A'}`, position.sl ? position.sl.toFixed(2) : '');
            const newTP = prompt(`ä¿®æ”¹è¨‚å–® #${id} åœåˆ© (TP)ã€‚ç•™ç©ºå‰‡å–æ¶ˆ TPã€‚ç›®å‰: ${position.tp ? position.tp.toFixed(2) : 'N/A'}`, position.tp ? position.tp.toFixed(2) : '');

            // è™•ç† SL
            if (newSL !== null) {
                const slVal = parseFloat(newSL);
                if (!isNaN(slVal) && slVal > 0) {
                    // é©—è­‰ (åŸºæ–¼é€²å ´åƒ¹)
                    if (position.type === 'BUY' && slVal >= position.entryPrice) {
                        alert("åœæå¿…é ˆä½æ–¼é€²å ´åƒ¹ã€‚");
                    } else if (position.type === 'SELL' && slVal <= position.entryPrice) {
                        alert("åœæå¿…é ˆé«˜æ–¼é€²å ´åƒ¹ã€‚");
                    } else {
                        position.sl = slVal;
                    }
                } else if (newSL === '') {
                    position.sl = null;
                }
            }

            // è™•ç† TP
            if (newTP !== null) {
                const tpVal = parseFloat(newTP);
                if (!isNaN(tpVal) && tpVal > 0) {
                    if (position.type === 'BUY' && tpVal <= position.entryPrice) {
                        alert("åœåˆ©å¿…é ˆé«˜æ–¼é€²å ´åƒ¹ã€‚");
                    } else if (position.type === 'SELL' && tpVal >= position.entryPrice) {
                        alert("åœåˆ©å¿…é ˆä½æ–¼é€²å ´åƒ¹ã€‚");
                    } else {
                        position.tp = tpVal;
                    }
                } else if (newTP === '') {
                    position.tp = null;
                }
            }
            
            updateUI();
            if (!state.isPlaying) {
                draw();
            }
        }

        // Chart Interaction Handlers
        function handleMouseMove(e) {
            const rect = DOM.chartWrap.getBoundingClientRect();
            state.mouse.x = e.clientX - rect.left;
            state.mouse.y = e.clientY - rect.top;
            state.mouse.isOverChart = true;
            if (!state.isPlaying && !state.chart.isDragging) {
                 draw();
            }
        }

        function handleMouseLeave() {
            state.mouse.isOverChart = false;
             if (!state.isPlaying && !state.chart.isDragging) {
                draw();
            }
        }

        function handleMouseWheel(e) {
            e.preventDefault(); // é˜²æ­¢é é¢æ»¾å‹•
            const zoomFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            zoomChart(zoomFactor);
        }

        function zoomChart(factor) {
            const newWidth = state.chart.candleWidth * factor;
            const newSpacing = state.chart.candleSpacing * factor;

            // é™åˆ¶ç¸®æ”¾ç¯„åœ
            if (newWidth < 2 || newWidth > 50) return;

            state.chart.candleWidth = newWidth;
            state.chart.candleSpacing = newSpacing;

            validateScrollOffset();

            if (!state.isPlaying) {
                draw();
            }
        }

        // Panning (Dragging)
        function handleDragStart(e) {
            if (e.button !== 0) return; // åªéŸ¿æ‡‰æ»‘é¼ å·¦éµ
            state.chart.isDragging = true;
            state.chart.dragStartX = e.clientX;
            state.chart.dragStartScroll = state.chart.scrollOffset;
            DOM.chartWrap.style.cursor = 'grabbing';
        }

        function handleDragging(e) {
            if (!state.chart.isDragging) return;

            const dx = e.clientX - state.chart.dragStartX;
            const candleUnitWidth = state.chart.candleWidth + state.chart.candleSpacing;
            
            // è¨ˆç®—æ‹–å‹•äº†å¤šå°‘æ ¹ K æ£’
            const candlesDragged = Math.round(dx / candleUnitWidth);
            
            // æ›´æ–° scrollOffset (å‘å³æ‹–å‹•æ»‘é¼  -> è¦–åœ–å‘å·¦æ»¾å‹• -> scrollOffset å¢åŠ )
            state.chart.scrollOffset = state.chart.dragStartScroll - candlesDragged;

            validateScrollOffset();

            // æ‹–å‹•æ™‚å§‹çµ‚é‡ç¹ª
            draw();
        }

        function handleDragEnd() {
            if (!state.chart.isDragging) return;
            state.chart.isDragging = false;
            DOM.chartWrap.style.cursor = 'crosshair';
             if (!state.isPlaying) {
                draw(); // Final draw to clear potential crosshair remnants
            }
        }

        function validateScrollOffset() {
            const visibleCandles = calculateVisibleCandles();
            // æœ€å¤§åç§»é‡æ˜¯ç”¨æˆ¶å¯ä»¥çœ‹åˆ°æœ€å·¦é‚Šçš„ K æ£’æ™‚
            const maxOffset = Math.max(0, state.currentIndex + 1 - visibleCandles);
            // æœ€å°åç§»é‡æ˜¯ 0 (ä¸èƒ½æ»¾å‹•åˆ°æœªä¾†)
            state.chart.scrollOffset = Math.max(0, Math.min(maxOffset, state.chart.scrollOffset));
        }


        // ----------------------------------------------------------------------------
        // 7. éŠæˆ²åŒ–åŠŸèƒ½ (Gamification Features)
        // ----------------------------------------------------------------------------

        // 7.1 è²¡ç¶“äº‹ä»¶ (Financial Events)
        function checkForEvents() {
            if (state.isEnded || state.gameData.length === 0) return;

            // æ ¹æ“šæ¨¡æ“¬çš„æ—¥æœŸè§¸ç™¼äº‹ä»¶
            const currentDate = new Date(state.gameData[state.currentIndex].time);
            const currentDay = currentDate.getDate();

            const event = state.financialEvents.find(e => e.triggerDay === currentDay);

            // ç¢ºä¿äº‹ä»¶åœ¨ç•¶å‰éŠæˆ²ä¸­åªè§¸ç™¼ä¸€æ¬¡ (åŸºæ–¼æœˆä»½å’Œæ—¥æœŸ)
            const eventKey = `${currentDate.getMonth()}-${currentDay}`;
            if (event && !state.triggeredEvents.has(eventKey)) {
                showEventModal(event);
                state.triggeredEvents.add(eventKey);
            }
        }

        function showEventModal(event) {
            // æš«åœæ¨¡æ“¬
            if (state.isPlaying) {
                state.wasPlayingBeforeEvent = true;
                state.isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                updateControls();
            } else {
                state.wasPlayingBeforeEvent = false;
            }

            document.getElementById('eventTitle').textContent = `âš ï¸ ${event.title}`;
            document.getElementById('eventBody').textContent = event.description;
            DOM.eventModal.classList.add('active');
        }

        function continueFromEvent() {
            DOM.eventModal.classList.remove('active');
            // å¦‚æœäº‹ä»¶å‰æ­£åœ¨æ’­æ”¾ï¼Œå‰‡æ¢å¾©æ’­æ”¾
            if (state.wasPlayingBeforeEvent) {
                togglePlayPause();
            }
        }

        // 7.2 çµæŸç•«é¢ (End Screen)
        function showEndGameModal() {
            const finalRoR = ((state.equity - CONFIG.INITIAL_BALANCE) / CONFIG.INITIAL_BALANCE) * 100;
            
            document.getElementById('finalScore').textContent = `$${state.equity.toFixed(2)}`;
            document.getElementById('finalRoR').textContent = `å›å ±ç‡ (RoR): ${finalRoR.toFixed(2)}%`;
            document.getElementById('finalRoR').style.color = finalRoR >= 0 ? 'var(--color-success)' : 'var(--color-danger)';

            // è¨ˆç®—çµ±è¨ˆæ•¸æ“š
            const totalTrades = state.tradeHistory.length;
            const winningTrades = state.tradeHistory.filter(t => t.profit > 0).length;
            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;

            const statsHTML = `
                <p><strong>äº¤æ˜“çµ±è¨ˆï¼š</strong></p>
                <ul style="list-style-position: inside;">
                    <li>ç¸½äº¤æ˜“æ¬¡æ•¸: ${totalTrades}</li>
                    <li>å‹ç‡: ${winRate.toFixed(2)}%</li>
                    <li>æ¨¡æ“¬æœŸé–“: ç´„ ${CONFIG.SIMULATION_DURATION_DAYS} å¤©</li>
                </ul>
            `;
            document.getElementById('endGameStats').innerHTML = statsHTML;

            DOM.endGameModal.classList.add('active');
        }

        // 7.3 æ–°æ‰‹å°å¼• (Tutorial)
        const TUTORIAL_STEPS = [
            { selector: '.chart-container', message: 'æ­¡è¿ä¾†åˆ°äº¤æ˜“æŒ‘æˆ°ï¼é€™è£¡æ˜¯ K ç·šåœ–è¡¨å€åŸŸï¼Œæ‚¨å°‡åœ¨é€™è£¡è§€å¯Ÿå¸‚å ´èµ°å‹¢ã€‚æ‚¨å¯ä»¥æ‹–æ›³åœ–è¡¨æŸ¥çœ‹æ­·å²ã€‚', action: 'next' },
            { selector: '#btnPlayPause', message: 'é»æ“Šã€Œæ’­æ”¾ã€æŒ‰éˆ•é–‹å§‹æ¨¡æ“¬å¸‚å ´è¡Œæƒ…ã€‚åœ–è¡¨å°‡æœƒå‹•æ…‹æ›´æ–°ã€‚', action: 'click' },
            { selector: '#tabOrder', message: 'é€™è£¡æ˜¯ä¸‹å–®é¢æ¿ã€‚æ‚¨å¯ä»¥è¨­å®šæ‰‹æ•¸ã€åœæ (SL) å’Œåœåˆ© (TP)ã€‚', action: 'next' },
            { selector: '#btnBuy', message: 'é æœŸåƒ¹æ ¼ä¸Šæ¼²ï¼Ÿå˜—è©¦é»æ“Šã€Œè²·å…¥ (BUY)ã€å»ºç«‹æ‚¨çš„ç¬¬ä¸€ç­†å¤šå–®ã€‚', action: 'click' },
            { selector: '[data-target="tabPositions"]', message: 'é»æ“Šã€ŒæŒå€‰ã€åˆ†é ä¾†æŸ¥çœ‹ä¸¦ç®¡ç†æ‚¨ç•¶å‰çš„è¨‚å–®ã€‚', action: 'click' },
            { selector: '.header', message: 'é ‚éƒ¨çš„ HUD æœƒå³æ™‚é¡¯ç¤ºæ‚¨çš„å¸³æˆ¶ç‹€æ…‹å’ŒæŒ‘æˆ°é€²åº¦ã€‚ç¥æ‚¨äº¤æ˜“é †åˆ©ï¼', action: 'next' },
        ];

        let currentTutorialStep = 0;

        function startTutorial() {
            // å°æ–¼ Playable Adï¼Œé€šå¸¸æ¯æ¬¡éƒ½æœƒé¡¯ç¤ºå°å¼•
            state.tutorialActive = true;
            currentTutorialStep = 0;
            showTutorialStep();
        }

        function showTutorialStep() {
            if (currentTutorialStep >= TUTORIAL_STEPS.length) {
                endTutorial();
                return;
            }

            const step = TUTORIAL_STEPS[currentTutorialStep];
            const element = document.querySelector(step.selector);

            // å¥å£¯æ€§æª¢æŸ¥ï¼šç¢ºä¿å…ƒç´ å­˜åœ¨
            if (!element) {
                console.warn("Tutorial element not found:", step.selector);
                // å¦‚æœæ‰¾ä¸åˆ°å…ƒç´ ï¼Œç¨ç­‰ç‰‡åˆ»å†è©¦ï¼Œé˜²æ­¢å›  DOM æœªæº–å‚™å¥½è€Œå¤±æ•—
                setTimeout(showTutorialStep, 100);
                return;
            }

            highlightElement(element);
            DOM.tutorialText.textContent = step.message;

            // æ ¹æ“šè¡Œå‹•é¡å‹æ±ºå®šæ˜¯å¦é¡¯ç¤ºã€Œä¸‹ä¸€æ­¥ã€æŒ‰éˆ•
            if (step.action === 'next') {
                DOM.tutorialNextBtn.classList.remove('hidden');
                DOM.tutorialNextBtn.onclick = completeTutorialStep;
            } else {
                // å¦‚æœæ˜¯ 'click'ï¼Œå‰‡éš±è—æŒ‰éˆ•ï¼Œç­‰å¾…ç”¨æˆ¶é»æ“Šç›®æ¨™å…ƒç´  (åœ¨å°æ‡‰çš„äº‹ä»¶è™•ç†å™¨ä¸­å‘¼å« completeTutorialStep)
                DOM.tutorialNextBtn.classList.add('hidden');
            }
        }

        // ç•¶ç”¨æˆ¶å®Œæˆè¦æ±‚çš„æ“ä½œæ™‚å‘¼å«æ­¤å‡½å¼
        function completeTutorialStep() {
            if (!state.tutorialActive) return;
            
            // é€™è£¡ä¾è³´è§¸ç™¼äº‹ä»¶çš„é‚è¼¯ä¾†æ¨é€²æ­¥é©Ÿã€‚
            // ä¾‹å¦‚ï¼Œç•¶ç”¨æˆ¶é»æ“Šäº† 'Play'ï¼ŒtogglePlayPause æœƒå‘¼å«æ­¤å‡½å¼ã€‚

            currentTutorialStep++;
            showTutorialStep();
        }

        function endTutorial() {
            state.tutorialActive = false;
            DOM.tutorialHighlight.classList.add('hidden');
            DOM.tutorialMessage.classList.add('hidden');
        }

        function highlightElement(element) {
            const rect = element.getBoundingClientRect();
            const padding = 10;

            DOM.tutorialHighlight.classList.remove('hidden');
            // ä½¿ç”¨ window çš„æ»¾å‹•ä½ç½®ä¾†ç¢ºä¿å®šä½æ­£ç¢º
            DOM.tutorialHighlight.style.top = `${rect.top + window.scrollY - padding}px`;
            DOM.tutorialHighlight.style.left = `${rect.left + window.scrollX - padding}px`;
            DOM.tutorialHighlight.style.width = `${rect.width + padding * 2}px`;
            DOM.tutorialHighlight.style.height = `${rect.height + padding * 2}px`;

            // å®šä½è¨Šæ¯æ¡†
            DOM.tutorialMessage.classList.remove('hidden');
            let messageTop = rect.bottom + window.scrollY + padding + 20;
            let messageLeft = rect.left + window.scrollX;

            // é‚Šç•Œæª¢æŸ¥ï¼Œç¢ºä¿è¨Šæ¯æ¡†åœ¨è¢å¹•å…§
            if (messageTop + DOM.tutorialMessage.offsetHeight > window.innerHeight + window.scrollY) {
                messageTop = rect.top + window.scrollY - DOM.tutorialMessage.offsetHeight - padding - 20;
            }
            if (messageLeft + DOM.tutorialMessage.offsetWidth > window.innerWidth + window.scrollX) {
                messageLeft = window.innerWidth + window.scrollX - DOM.tutorialMessage.offsetWidth - 20;
            }
            // é˜²æ­¢è¨Šæ¯æ¡†å®šä½åˆ°è² å€¼
            messageTop = Math.max(10 + window.scrollY, messageTop);
            messageLeft = Math.max(10 + window.scrollX, messageLeft);


            DOM.tutorialMessage.style.top = `${messageTop}px`;
            DOM.tutorialMessage.style.left = `${messageLeft}px`;
        }


        // ----------------------------------------------------------------------------
        // 8. è¼”åŠ©å‡½å¼ (Utility Functions)
        // ----------------------------------------------------------------------------

        function setupInputStepper(buttonId, inputId, step) {
            document.getElementById(buttonId).addEventListener('click', () => {
                const input = document.getElementById(inputId);
                const currentValue = parseFloat(input.value) || 0;
                let newValue = currentValue + step;
                
                // ç²¾åº¦è™•ç†
                const decimalPlaces = (step.toString().split('.')[1] || []).length;
                newValue = parseFloat(newValue.toFixed(decimalPlaces));

                // é‚Šç•Œæª¢æŸ¥
                if (inputId === 'inputLots') {
                     if (newValue < 0.01) newValue = 0.01;
                } else {
                    // SL/TP
                    if (newValue <= 0) {
                        input.value = ''; // æ¸…ç©ºè¼¸å…¥æ¡†
                        return;
                    }
                }
               
                input.value = newValue.toFixed(decimalPlaces);
            });
        }

        function formatDuration(ms) {
            if (ms < 0) ms = 0;
            const minutes = Math.floor(ms / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            return `${minutes}m`;
        }

        // ----------------------------------------------------------------------------
        // å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼ (Bootstrap Application)
        // ----------------------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
