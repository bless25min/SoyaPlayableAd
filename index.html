<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trading Profit Challenge</title>
    <style>
        :root {
            --background-color: #f0f2f5;
            --chart-background: #ffffff;
            --text-color: #1c1e21;
            --border-color: #dce1e6;
            --primary-button-bg: #1877f2;
            --primary-button-text: #ffffff;
            --primary-button-hover: #166fe5;
            --secondary-button-bg: #e4e6eb;
            --secondary-button-text: #050505;
            --secondary-button-hover: #d8dadf;
            --buy-color: #42b72a;
            --sell-color: #f02849;
            --buy-color-light: rgba(66, 183, 42, 0.1);
            --sell-color-light: rgba(240, 40, 73, 0.1);
            --sl-color: #fa3838;
            --tp-color: #26a69a;
            --inactive-tab-bg: #e9eaec;
            --active-tab-bg: #ffffff;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* Dark Theme (optional, can be activated via JS) */
        /*
        :root[data-theme="dark"] {
            --background-color: #18191a;
            --chart-background: #242526;
            --text-color: #e4e6eb;
            --border-color: #3a3b3c;
            --primary-button-bg: #2374e1;
            --primary-button-hover: #3982e4;
            --secondary-button-bg: #3a3b3c;
            --secondary-button-text: #e4e6eb;
            --secondary-button-hover: #4f5051;
            --inactive-tab-bg: #303031;
            --active-tab-bg: #242526;
        }
        */

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        #header {
            padding: 8px 12px;
            background-color: var(--chart-background);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header .info {
            font-size: 14px;
        }

        #header .info span {
            margin-right: 16px;
        }

        #chart-container {
            flex-grow: 1;
            position: relative;
        }

        #chart-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #bottom-panel {
            flex-shrink: 0;
            background-color: var(--background-color);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        #tab-buttons {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-button {
            flex: 1;
            padding: 12px;
            text-align: center;
            background-color: var(--inactive-tab-bg);
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color);
            border-right: 1px solid var(--border-color);
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button.active {
            background-color: var(--active-tab-bg);
            border-bottom: 2px solid var(--primary-button-bg);
            margin-bottom: -1px; /* Overlap border */
        }

        .tab-content {
            display: none;
            padding: 12px;
        }

        .tab-content.active {
            display: block;
        }

        #trade-panel .trade-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        #trade-panel .input-group {
            margin-bottom: 10px;
        }

        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .input-row label {
            width: 80px;
            font-size: 14px;
        }
        
        .input-wrapper {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .input-wrapper input {
            flex-grow: 1;
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
            background-color: var(--chart-background);
            color: var(--text-color);
            -moz-appearance: textfield;
        }
        
        .input-wrapper input::-webkit-outer-spin-button,
        .input-wrapper input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .step-button {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-button-bg);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            color: var(--secondary-button-text);
        }

        #positions-panel table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        #positions-panel th,
        #positions-panel td {
            border: 1px solid var(--border-color);
            padding: 6px;
            text-align: center;
        }

        #positions-panel th {
            background-color: var(--secondary-button-bg);
        }
        
        .close-pos-btn {
            background: none;
            border: none;
            color: var(--sell-color);
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }

        .buy-button, .sell-button {
            flex-grow: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            color: var(--primary-button-text);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .buy-button {
            background-color: var(--buy-color);
        }

        .buy-button:hover {
            background-color: #3aa122;
        }
        
        .sell-button {
            background-color: var(--sell-color);
        }

        .sell-button:hover {
            background-color: #d82341;
        }
        
        #playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #playback-controls button {
            background-color: var(--secondary-button-bg);
            border: 1px solid var(--border-color);
            color: var(--secondary-button-text);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        #playback-controls button:hover {
            background-color: var(--secondary-button-hover);
        }
        #playback-controls select {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        /* Tutorial Overlay */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 999;
            display: none;
        }
        #tutorial-highlight {
            position: absolute;
            border: 3px solid #1877f2;
            border-radius: 8px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            transition: all 0.4s ease-in-out;
            pointer-events: none;
        }
        #tutorial-box {
            position: absolute;
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #tutorial-box p {
            margin: 0 0 15px 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #tutorial-box button {
            background-color: #1877f2;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            float: right;
        }

        /* End Card */
        #end-card {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #end-card-content {
            background: var(--chart-background);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        #end-card-content h2 {
            margin-top: 0;
            font-size: 24px;
        }
        #end-card-content p {
            font-size: 18px;
            margin: 15px 0;
        }
        .final-profit {
            font-weight: bold;
            font-size: 28px;
        }
        .profit-positive {
            color: var(--buy-color);
        }
        .profit-negative {
            color: var(--sell-color);
        }
        #cta-button {
            display: inline-block;
            background-color: var(--buy-color);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            text-decoration: none;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #cta-button:hover {
            background-color: #3aa122;
        }

    </style>
</head>

<body>
    <div id="app-container">
        <div id="header">
            <div id="challenge-info" class="info">
                <span>日期: <span id="current-date">--</span></span>
                <span>淨值: <span id="equity-value">10000.00</span></span>
                <span>總損益: <span id="total-pnl">0.00</span></span>
            </div>
            <div id="playback-controls">
                 <button id="play-pause-btn">▶</button>
                 <button id="next-candle-btn">→</button>
                 <select id="speed-selector">
                    <option value="1000">x1</option>
                    <option value="500">x2</option>
                    <option value="250">x4</option>
                    <option value="100">x8</option>
                </select>
            </div>
        </div>
        <div id="chart-container">
            <canvas id="chart-canvas"></canvas>
        </div>
        <div id="bottom-panel">
            <div id="tab-buttons">
                <button class="tab-button active" data-tab="trade-panel">交易</button>
                <button class="tab-button" data-tab="positions-panel">持倉 (<span id="position-count">0</span>)</button>
            </div>
            <div id="trade-panel" class="tab-content active">
                 <div class="input-row">
                    <label for="sl-input">停損價</label>
                    <div class="input-wrapper">
                        <button class="step-button" data-input="sl-input" data-step="-1">-</button>
                        <input type="number" id="sl-input" step="0.1">
                        <button class="step-button" data-input="sl-input" data-step="1">+</button>
                    </div>
                </div>
                <div class="input-row">
                    <label for="tp-input">停利價</label>
                    <div class="input-wrapper">
                         <button class="step-button" data-input="tp-input" data-step="-1">-</button>
                        <input type="number" id="tp-input" step="0.1">
                        <button class="step-button" data-input="tp-input" data-step="1">+</button>
                    </div>
                </div>
                 <div class="trade-actions">
                    <button id="sell-btn" class="sell-button">賣出</button>
                    <button id="buy-btn" class="buy-button">買入</button>
                </div>
            </div>
            <div id="positions-panel" class="tab-content">
                <table id="positions-table">
                    <thead>
                        <tr>
                            <th>類型</th>
                            <th>價格</th>
                            <th>SL</th>
                            <th>TP</th>
                            <th>損益</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div id="tutorial-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-box">
            <p id="tutorial-text"></p>
            <button id="tutorial-next-btn">下一步</button>
        </div>
    </div>

    <div id="end-card">
        <div id="end-card-content">
            <h2>挑戰結束！</h2>
            <p>您的最終淨值為：</p>
            <p id="final-equity" class="final-profit profit-positive">$10,523.45</p>
            <a id="cta-button" href="https://www.google.com" target="_blank">了解更多</a>
        </div>
    </div>

    <script>
        // =================================================================================
        // MAIN APPLICATION LOGIC
        // =================================================================================
        
        // --- CLASSES ---

        class TradingChart {
            // ... (The rest of your class implementation)
            // No changes needed inside the class itself.
             constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.ohlcData = [];
                this.animations = [];

                this.candleWidth = 8;
                this.candleSpacing = 4;
                this.zoom = 1.0;
                this.panX = 0;

                this.minPrice = Infinity;
                this.maxPrice = -Infinity;

                this.isDragging = false;
                this.lastMouseX = 0;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.onMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.onMouseUp());
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
             }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.ctx.scale(dpr, dpr);
                this.draw();
            }

            setData(data, visibleCandles) {
                this.ohlcData = data;
                this.visibleCandles = visibleCandles;
                this.calculatePriceRange();
                this.draw();
            }
             
            updateData(newData) {
                this.visibleCandles = newData;
                this.calculatePriceRange();
                this.draw();
            }

            calculatePriceRange() {
                if (this.visibleCandles.length === 0) return;

                let min = Infinity, max = -Infinity;
                for(const candle of this.visibleCandles) {
                    min = Math.min(min, candle.low);
                    max = Math.max(max, candle.high);
                }

                // Add some padding
                const padding = (max - min) * 0.1;
                this.minPrice = min - padding;
                this.maxPrice = max + padding;
            }

            draw() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawDateSeparators();
                this.drawCandles();
                this.drawPriceAxis();
                this.drawPositions();
                this.drawAnimations();
            }
            
            drawPositions() {
                positions.forEach(pos => {
                    this.drawPositionLine(pos.entryPrice, 'blue', pos.pnl);
                    if (pos.sl) this.drawPositionLine(pos.sl, 'red');
                    if (pos.tp) this.drawPositionLine(pos.tp, 'green');
                });
            }

            drawPositionLine(price, color, pnl = null) {
                const y = this.priceToY(price);
                this.ctx.beginPath();
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeStyle = color;
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.clientWidth, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                if (pnl !== null) {
                    const pnlText = pnl.toFixed(2);
                    const pnlColor = pnl >= 0 ? 'green' : 'red';
                    this.ctx.fillStyle = pnlColor;
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(pnlText, 10, y - 5);
                }
            }


            drawDateSeparators() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#888';

                let lastDate = null;

                for (let i = 0; i < this.visibleCandles.length; i++) {
                    const candle = this.visibleCandles[i];
                    const date = new Date(candle.time * 1000);
                    const candleDate = date.toDateString();

                    if (lastDate && candleDate !== lastDate) {
                        const x = this.getXPosition(i);
                        
                        this.ctx.beginPath();
                        this.ctx.setLineDash([4, 4]);
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.clientHeight);
                        this.ctx.stroke();
                        
                        this.ctx.setLineDash([]);
                        
                        this.ctx.fillText(date.toLocaleDateString(), x + 5, this.canvas.clientHeight - 10);
                    }
                    lastDate = candleDate;
                }
            }


            getXPosition(index) {
                const totalCandleWidth = (this.candleWidth + this.candleSpacing) * this.zoom;
                return this.canvas.clientWidth - (this.visibleCandles.length - index) * totalCandleWidth - this.panX;
            }

            drawCandles() {
                const totalCandleWidth = (this.candleWidth + this.candleSpacing) * this.zoom;
                
                this.visibleCandles.forEach((candle, i) => {
                    const x = this.getXPosition(i);
                     if (x < -totalCandleWidth || x > this.canvas.clientWidth + totalCandleWidth) {
                        return; // Don't draw off-screen candles
                    }

                    const openY = this.priceToY(candle.open);
                    const closeY = this.priceToY(candle.close);
                    const highY = this.priceToY(candle.high);
                    const lowY = this.priceToY(candle.low);
                    
                    const isBullish = candle.close >= candle.open;
                    this.ctx.strokeStyle = isBullish ? 'green' : 'red';
                    this.ctx.fillStyle = isBullish ? 'green' : 'red';
                    
                    // Draw wick
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + (this.candleWidth * this.zoom) / 2, highY);
                    this.ctx.lineTo(x + (this.candleWidth * this.zoom) / 2, lowY);
                    this.ctx.stroke();

                    // Draw body
                    const bodyHeight = Math.abs(openY - closeY);
                    const bodyY = Math.min(openY, closeY);
                    
                    if (bodyHeight < 1) { // If body is very small, draw a line
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, openY);
                        this.ctx.lineTo(x + this.candleWidth * this.zoom, openY);
                        this.ctx.stroke();
                    } else {
                        this.ctx.fillRect(x, bodyY, this.candleWidth * this.zoom, bodyHeight);
                    }
                });
            }

            drawPriceAxis() {
                const axisWidth = 50;
                const clientWidth = this.canvas.clientWidth;
                const clientHeight = this.canvas.clientHeight;
                
                this.ctx.fillStyle = '#f0f2f5';
                this.ctx.fillRect(clientWidth - axisWidth, 0, axisWidth, clientHeight);
                this.ctx.strokeStyle = '#dce1e6';
                this.ctx.beginPath();
                this.ctx.moveTo(clientWidth - axisWidth, 0);
                this.ctx.lineTo(clientWidth - axisWidth, clientHeight);
                this.ctx.stroke();

                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                
                const priceRange = this.maxPrice - this.minPrice;
                const numTicks = 8;
                for (let i = 0; i <= numTicks; i++) {
                    const price = this.minPrice + (i / numTicks) * priceRange;
                    const y = this.priceToY(price);
                    
                    this.ctx.fillText(price.toFixed(2), clientWidth - axisWidth + 5, y + 4);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(clientWidth - axisWidth, y);
                    this.ctx.lineTo(clientWidth - axisWidth - 5, y);
                    this.ctx.stroke();
                }
            }
             
            addOpenPositionAnimation(price, type) {
                const y = this.priceToY(price);
                const x = this.canvas.clientWidth - 55; // Right edge minus axis width
                this.animations.push({ type: 'arrow', x, y, dir: type === 'buy' ? 1 : -1, life: 60 });
            }

            addClosePositionAnimation(price, pnl) {
                const y = this.priceToY(price);
                const x = this.canvas.clientWidth - 100; // A bit to the left of the axis
                this.animations.push({ type: 'pnl', x, y, pnl, life: 90, startY: y });
            }
            
            drawAnimations() {
                this.ctx.save();
                for (let i = this.animations.length - 1; i >= 0; i--) {
                    const anim = this.animations[i];
                    anim.life--;

                    if (anim.type === 'arrow') {
                        this.ctx.fillStyle = anim.dir === 1 ? 'green' : 'red';
                        this.ctx.globalAlpha = anim.life / 60;
                        this.ctx.beginPath();
                        if (anim.dir === 1) { // Buy arrow
                            this.ctx.moveTo(anim.x, anim.y + 10);
                            this.ctx.lineTo(anim.x + 10, anim.y);
                            this.ctx.lineTo(anim.x + 20, anim.y + 10);
                        } else { // Sell arrow
                            this.ctx.moveTo(anim.x, anim.y - 10);
                            this.ctx.lineTo(anim.x + 10, anim.y);
                            this.ctx.lineTo(anim.x + 20, anim.y - 10);
                        }
                        this.ctx.fill();
                    } else if (anim.type === 'pnl') {
                        const pnlText = (pnl > 0 ? '+' : '') + pnl.toFixed(2);
                        this.ctx.fillStyle = pnl > 0 ? 'rgba(0, 128, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                        this.ctx.font = 'bold 14px Arial';
                        anim.y -= 0.5; // Float up
                        this.ctx.globalAlpha = anim.life / 90;
                        this.ctx.fillText(pnlText, anim.x, anim.y);
                    }

                    if (anim.life <= 0) {
                        this.animations.splice(i, 1);
                    }
                }
                 this.ctx.restore();
            }


            priceToY(price) {
                const priceRange = this.maxPrice - this.minPrice;
                if (priceRange === 0) return this.canvas.clientHeight / 2;
                return (1 - (price - this.minPrice) / priceRange) * this.canvas.clientHeight;
            }

            onMouseDown(e) {
                this.isDragging = true;
                this.lastMouseX = e.clientX;
            }

            onMouseMove(e) {
                if (this.isDragging) {
                    const dx = e.clientX - this.lastMouseX;
                    this.panX -= dx;
                    this.lastMouseX = e.clientX;
                    this.draw();
                }
            }

            onMouseUp() {
                this.isDragging = false;
            }

            onWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                this.zoom *= zoomFactor;
                this.zoom = Math.max(0.1, Math.min(10, this.zoom));
                this.draw();
            }
        }

        // --- GLOBAL STATE ---
        let ohlcData = [];
        let currentIndex = 0;
        let visibleCandles = [];
        let isPlaying = false;
        let gameInterval;
        let candleSpeed = 500;
        let chart;
        let positions = [];
        let nextPositionId = 1;
        let account = {
            balance: 10000,
            equity: 10000
        };
        const VISIBLE_CANDLE_COUNT = 60; // Number of candles to display initially
        let tutorialStep = 0;

        // --- CORE FUNCTIONS ---

        async function loadDataAndStart() {
            try {
                const response = await fetch('XAUUSD_M15.csv');
                const csvText = await response.text();
                const parsedData = parseCSV(csvText);
                ohlcData = selectRandomMonth(parsedData);
                resetChallenge();
            } catch (error) {
                console.error("Failed to load or parse CSV data:", error);
            }
        }
        
        function parseCSV(text) {
            const lines = text.split('\n').slice(1); // Skip header
            return lines.map(line => {
                const [time, open, high, low, close] = line.split(',');
                if (!time) return null;
                return {
                    time: parseInt(time),
                    open: parseFloat(open),
                    high: parseFloat(high),
                    low: parseFloat(low),
                    close: parseFloat(close)
                };
            }).filter(Boolean);
        }

        function selectRandomMonth(data) {
            const months = {};
            data.forEach(d => {
                const date = new Date(d.time * 1000);
                const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                if (!months[monthKey]) {
                    months[monthKey] = [];
                }
                months[monthKey].push(d);
            });
            const monthKeys = Object.keys(months);
            const randomMonthKey = monthKeys[Math.floor(Math.random() * monthKeys.length)];
            console.log("Selected data for:", randomMonthKey);
            return months[randomMonthKey];
        }


        function resetChallenge() {
            currentIndex = VISIBLE_CANDLE_COUNT;
            visibleCandles = ohlcData.slice(0, VISIBLE_CANDLE_COUNT);
            chart.setData(ohlcData, visibleCandles);
            updateUI();
            showTutorialStep(0);
        }

        function nextCandle() {
            if (currentIndex >= ohlcData.length -1) {
                pauseGame();
                showEndCard();
                console.log("End of data reached.");
                return;
            }
            currentIndex++;
            const newCandle = ohlcData[currentIndex];
            visibleCandles.push(newCandle);
            if (visibleCandles.length > VISIBLE_CANDLE_COUNT * 2) { // Keep DOM light
                visibleCandles.shift();
            }
            
            updatePositions(newCandle.close);
            chart.updateData(ohlcData.slice(Math.max(0, currentIndex - VISIBLE_CANDLE_COUNT), currentIndex + 1));
            updateUI();
        }

        function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('play-pause-btn').textContent = isPlaying ? '❚❚' : '▶';
            if (isPlaying) {
                gameInterval = setInterval(nextCandle, candleSpeed);
            } else {
                clearInterval(gameInterval);
            }
        }
        
        function pauseGame() {
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('play-pause-btn').textContent = '▶';
                clearInterval(gameInterval);
            }
        }

        function setSpeed(speed) {
            candleSpeed = parseInt(speed);
            if (isPlaying) {
                clearInterval(gameInterval);
                gameInterval = setInterval(nextCandle, candleSpeed);
            }
        }

        // --- UI FUNCTIONS ---
        
        function updateUI() {
            const currentCandle = ohlcData[currentIndex];
            if (!currentCandle) return;
            
            const currentDate = new Date(currentCandle.time * 1000).toLocaleString();
            document.getElementById('current-date').textContent = currentDate;
            
            const totalPnl = positions.reduce((sum, pos) => sum + pos.pnl, 0);
            account.equity = account.balance + totalPnl;

            document.getElementById('equity-value').textContent = account.equity.toFixed(2);
            document.getElementById('total-pnl').textContent = totalPnl.toFixed(2);
            
            updatePositionsTable();
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));

            document.getElementById(tabName).classList.add('active');
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        }

        // --- TRADE FUNCTIONS ---

        function openPosition(type) {
            const currentPrice = ohlcData[currentIndex].close;
            const slInput = document.getElementById('sl-input');
            const tpInput = document.getElementById('tp-input');

            const sl = parseFloat(slInput.value) || null;
            const tp = parseFloat(tpInput.value) || null;

            if (type === 'buy') {
                if (sl && sl >= currentPrice) { alert('Buy Stop Loss must be below entry price.'); return; }
                if (tp && tp <= currentPrice) { alert('Buy Take Profit must be above entry price.'); return; }
            } else { // sell
                if (sl && sl <= currentPrice) { alert('Sell Stop Loss must be above entry price.'); return; }
                if (tp && tp >= currentPrice) { alert('Sell Take Profit must be below entry price.'); return; }
            }
            
            const newPosition = {
                id: nextPositionId++,
                type: type,
                entryPrice: currentPrice,
                sl: sl,
                tp: tp,
                pnl: 0,
            };
            
            positions.push(newPosition);
            chart.addOpenPositionAnimation(currentPrice, type);
            updateUI();
        }

        function closePosition(positionId) {
            const posIndex = positions.findIndex(p => p.id === positionId);
            if (posIndex > -1) {
                const pos = positions[posIndex];
                account.balance += pos.pnl;
                chart.addClosePositionAnimation(ohlcData[currentIndex].close, pos.pnl);
                positions.splice(posIndex, 1);
                updateUI();
            }
        }

        function updatePositions(currentPrice) {
            let positionsClosed = false;
            for (let i = positions.length - 1; i >= 0; i--) {
                const pos = positions[i];
                if (pos.type === 'buy') {
                    pos.pnl = (currentPrice - pos.entryPrice) * 100; // Simplified PnL
                    if ((pos.sl && currentPrice <= pos.sl) || (pos.tp && currentPrice >= pos.tp)) {
                        closePosition(pos.id);
                        positionsClosed = true;
                    }
                } else { // sell
                    pos.pnl = (pos.entryPrice - currentPrice) * 100; // Simplified PnL
                     if ((pos.sl && currentPrice >= pos.sl) || (pos.tp && currentPrice <= pos.tp)) {
                        closePosition(pos.id);
                        positionsClosed = true;
                    }
                }
            }
            if (!positionsClosed) {
                updateUI();
            }
        }
        
        function updatePositionsTable() {
            const tableBody = document.getElementById('positions-table').querySelector('tbody');
            tableBody.innerHTML = '';
            document.getElementById('position-count').textContent = positions.length;

            positions.forEach(pos => {
                const row = document.createElement('tr');
                const pnlColor = pos.pnl >= 0 ? 'var(--buy-color)' : 'var(--sell-color)';
                row.innerHTML = `
                    <td style="color: ${pos.type === 'buy' ? 'var(--buy-color)' : 'var(--sell-color)'}">${pos.type.toUpperCase()}</td>
                    <td>${pos.entryPrice.toFixed(2)}</td>
                    <td>${pos.sl ? pos.sl.toFixed(2) : '--'}</td>
                    <td>${pos.tp ? pos.tp.toFixed(2) : '--'}</td>
                    <td style="color: ${pnlColor}">${pos.pnl.toFixed(2)}</td>
                    <td><button class="close-pos-btn" data-id="${pos.id}">X</button></td>
                `;
                tableBody.appendChild(row);
            });
            
            // Add event listeners to new close buttons
            tableBody.querySelectorAll('.close-pos-btn').forEach(btn => {
                btn.addEventListener('click', () => closePosition(parseInt(btn.dataset.id)));
            });
        }
        
        function handleStepButtonClick(e) {
            const target = e.target;
            if (!target.classList.contains('step-button')) return;
            
            const inputId = target.dataset.input;
            const step = parseFloat(target.dataset.step);
            const input = document.getElementById(inputId);
            
            if (input) {
                let currentValue = parseFloat(input.value) || ohlcData[currentIndex].close;
                // Simplified step value for price
                const priceStep = 0.5;
                input.value = (currentValue + step * priceStep).toFixed(2);
            }
        }

        // --- TUTORIAL FUNCTIONS ---
        const tutorialSteps = [
            { id: 'challenge-info', text: '這裡是您的帳戶資訊，目標是透過交易來增加淨值。' },
            { id: 'chart-canvas', text: '這是黃金(XAUUSD)的走勢圖，您可以拖曳平移、滾輪縮放。' },
            { id: 'playback-controls', text: '您可以使用這些按鈕來控制時間流逝，播放、暫停或加速。' },
            { id: 'bottom-panel', text: '這是交易面板。點擊「下一步」來學習如何下單。' },
            { id: 'sell-btn', text: '如果您認為價格會下跌，點擊「賣出」。' },
            { id: 'buy-btn', text: '如果您認為價格會上漲，點擊「買入」。祝您好運！' }
        ];

        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) {
                document.getElementById('tutorial-overlay').style.display = 'none';
                return;
            }
            tutorialStep = stepIndex;
            const step = tutorialSteps[stepIndex];
            const element = document.getElementById(step.id);
            if (!element) {
                // Add a small delay and retry, as DOM might not be ready
                setTimeout(() => {
                    const elementRetry = document.getElementById(step.id);
                    if (!elementRetry) {
                         console.error(`Tutorial Error: Element with ID "${step.id}" not found.`);
                         // Skip to next step or end tutorial
                         showTutorialStep(stepIndex + 1);
                         return;
                    }
                    positionTutorial(elementRetry, step.text);
                }, 100);
                return;
            }
            positionTutorial(element, step.text);
        }
        
        function positionTutorial(element, text) {
            document.getElementById('tutorial-overlay').style.display = 'block';
            
            const rect = element.getBoundingClientRect();
            const highlight = document.getElementById('tutorial-highlight');
            const box = document.getElementById('tutorial-box');

            highlight.style.top = `${rect.top - 5}px`;
            highlight.style.left = `${rect.left - 5}px`;
            highlight.style.width = `${rect.width + 10}px`;
            highlight.style.height = `${rect.height + 10}px`;

            document.getElementById('tutorial-text').textContent = text;
            
            // Position the box
            const boxTop = rect.bottom + 15;
            const boxLeft = rect.left;
            
            box.style.top = `${boxTop}px`;
            box.style.left = `${boxLeft}px`;
            
            // Adjust if box is off-screen
            if (boxTop + box.offsetHeight > window.innerHeight) {
                 box.style.top = `${rect.top - box.offsetHeight - 15}px`;
            }
            if (boxLeft + box.offsetWidth > window.innerWidth) {
                box.style.left = `${window.innerWidth - box.offsetWidth - 15}px`;
            }
        }
        
        function showEndCard() {
            const endCard = document.getElementById('end-card');
            const finalEquityEl = document.getElementById('final-equity');
            
            finalEquityEl.textContent = `$${account.equity.toFixed(2)}`;
            if (account.equity >= account.balance) {
                finalEquityEl.className = 'final-profit profit-positive';
            } else {
                finalEquityEl.className = 'final-profit profit-negative';
            }
            endCard.style.display = 'flex';
        }


        // =================================================================================
        // INITIALIZATION
        // This is the main entry point of the application.
        // It waits for the DOM to be fully loaded before running any code.
        // =================================================================================
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. Initialize Chart ---
            chart = new TradingChart('chart-canvas');

            // --- 2. Setup Event Listeners ---
            document.getElementById('play-pause-btn').addEventListener('click', playPause);
            document.getElementById('next-candle-btn').addEventListener('click', () => {
                pauseGame();
                nextCandle();
            });
            document.getElementById('speed-selector').addEventListener('change', (e) => setSpeed(e.target.value));
            
            document.getElementById('buy-btn').addEventListener('click', () => openPosition('buy'));
            document.getElementById('sell-btn').addEventListener('click', () => openPosition('sell'));
            
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => switchTab(button.dataset.tab));
            });
            
            document.getElementById('trade-panel').addEventListener('click', handleStepButtonClick);

            document.getElementById('tutorial-next-btn').addEventListener('click', () => showTutorialStep(tutorialStep + 1));
            
            document.getElementById('cta-button').addEventListener('click', (e) => {
                e.preventDefault();
                // In a real Playable Ad, this would call the ad network's specific exit function.
                // For a web version, a simple window.open is fine.
                window.open('https://www.google.com', '_blank');
            });
            
            // --- 3. Load Data and Start Simulation ---
            // This will also trigger the tutorial after data is ready.
            loadDataAndStart();
        });

    </script>
</body>

</html>
