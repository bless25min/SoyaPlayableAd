<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>‰∫§ÊòìÁç≤Âà©ÊåëÊà∞Ë≥Ω</title>
<style>
:root {
  --bg: #f4f7fc;
  --panel: #ffffff;
  --panel-soft: #f9fafc;
  --text: #1a1e2b;
  --muted: #6b7280;
  --border-color: #e5e7eb;
  --accent: #4a72ff;
  --good: #10b981;
  --danger: #ef4444;
  --warning: #f59e0b;
  --purple: #8b5cf6;
  --grid: rgba(0, 0, 0, 0.05);
  --chart-bg: #ffffff;
  --chart-text: #6b7280;
  --chart-up: #10b981;
  --chart-down: #ef4444;
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0; padding: 0; height: 100%; width: 100%;
  overflow: hidden; background-color: var(--bg); color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex; flex-direction: column; height: 100%; width: 100%;
  max-width: 420px; margin: 0 auto; background-color: var(--panel);
  box-shadow: 0 0 20px rgba(0,0,0,0.05);
}

.header {
  padding: 8px 16px; border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; text-align: center;
}
.header .stats { display: flex; justify-content: space-around; font-size: 14px; }
.header .stats div { display: flex; flex-direction: column; }
.header .stats .label { font-size: 12px; color: var(--muted); }
.header .stats .value { font-weight: bold; }
.header .pnl-up { color: var(--good); }
.header .pnl-down { color: var(--danger); }
.progress-bar { width: 100%; height: 4px; background: var(--border-color); border-radius: 2px; margin-top: 8px; overflow: hidden; }
.progress-bar-inner { width: 0%; height: 100%; background: var(--accent); transition: width 0.2s linear; }

#chartWrap {
  flex-grow: 1; position: relative; background: var(--chart-bg);
  min-height: 0; cursor: grab;
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }

.price-axis {
    position: absolute; right: 0; top: 0; bottom: 0; width: 60px;
    pointer-events: none; border-left: 1px solid var(--border-color);
}
.price-axis-tick {
    position: absolute; width: 100%; padding-right: 5px; font-size: 12px;
    color: var(--chart-text); transform: translateY(-50%); text-align: right;
}
.price-line {
    position: absolute; left: 0; right: 60px; height: 1px;
    pointer-events: none; border-top: 1px dashed var(--muted);
}
.price-line-label {
    position: absolute; right: 60px; padding: 2px 6px; font-size: 12px;
    color: #ffffff; border-radius: 4px; transform: translate(100%, -50%);
}

.actions-panel {
  flex-shrink: 0; background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.tabs { display: flex; border-bottom: 1px solid var(--border-color); }
.tab-btn {
  flex: 1; padding: 12px; background: none; border: none;
  color: var(--muted); cursor: pointer; border-bottom: 2px solid transparent;
  font-size: 14px;
}
.tab-btn.active { color: var(--text); border-bottom-color: var(--accent); font-weight: bold; }

.tab-content { display: none; padding: 12px; }
.tab-content.active { display: block; }

#trade-panel-content {
    display: grid; grid-template-areas: "sl lots tp" "sell close buy";
    gap: 8px; align-items: center;
}
#trade-sl-group { grid-area: sl; }
#trade-lots-group { grid-area: lots; }
#trade-tp-group { grid-area: tp; }
#btnSell { grid-area: sell; }
#btnCloseAll { grid-area: close; background-color: var(--muted); color: white; }
#btnBuy { grid-area: buy; }

.btn { padding: 12px; font-size: 16px; font-weight: bold; border-radius: 8px; border: none; cursor: pointer; transition: transform 0.1s ease, filter 0.1s ease; }
.btn.buy { background: var(--good); color: white; }
.btn.sell { background: var(--danger); color: white; }
.btn:active { transform: scale(0.96); filter: brightness(0.9); }

.playback-controls {
    display: flex; justify-content: center; align-items: center;
    gap: 8px; padding: 8px 0;
}
.playback-controls .btn {
    background: var(--panel-soft); color: var(--text);
    border: 1px solid var(--border-color); padding: 8px 10px; font-size: 12px;
}
.playback-controls .btn.active { background: var(--accent); color: white; border-color: var(--accent); }

.input-group { display: flex; flex-direction: column; text-align: center;}
.input-group label { font-size: 12px; color: var(--muted); margin-bottom: 4px; }

.input-stepper {
    display: flex; align-items: center; background: var(--bg);
    border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden;
}
.input-stepper input {
    border: none; background: transparent; flex-grow: 1; padding: 8px;
    width: 50px; text-align: center; color: var(--text);
}
.stepper-btns { display: flex; flex-direction: column; align-self: stretch; }
.stepper-btn {
    background: transparent; border: none; cursor: pointer; padding: 0 8px;
    color: var(--muted); flex: 1; display: flex; align-items: center;
    justify-content: center; border-left: 1px solid var(--border-color);
    transition: background-color 0.1s ease;
}
.stepper-btn:first-child { border-bottom: 1px solid var(--border-color); }
.stepper-btn:active { background: #e0e2e7; }

input[type=number]::-webkit-inner-spin-button, 
input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
input[type=number] { -moz-appearance: textfield; }

#positions-list, #journal-list { max-height: 25vh; overflow-y: auto; }
.position-item { 
    background: var(--panel-soft); padding: 10px; border-radius: 8px; margin-bottom: 8px; 
    display: grid; grid-template-columns: 1fr 1fr; grid-template-areas: "info pnl" "sl tp" "actions actions";
    gap: 8px; align-items: center;
}
.position-item-info { grid-area: info; }
.position-item-pnl { grid-area: pnl; text-align: right; font-weight: bold; }
.position-item-sl { grid-area: sl; }
.position-item-tp { grid-area: tp; }
.position-item-actions { grid-area: actions; display: flex; gap: 8px; }

.position-item .side-buy { color: var(--good); font-weight: bold; }
.position-item .side-sell { color: var(--danger); font-weight: bold; }
.position-item .pnl-up { color: var(--good); }
.position-item .pnl-down { color: var(--danger); }
.position-item .close-btn, .position-item .modify-btn { flex: 1; padding: 6px; font-size: 12px; }
.position-item .close-btn { background: var(--danger); color: white; }
.position-item .modify-btn { background: var(--accent); color: white; }
.position-item .input-group { margin-bottom: 0; }
.position-item .input-group input { padding: 6px; font-size: 12px; }

.journal-item {
    background: var(--panel-soft); padding: 10px; border-radius: 8px; margin-bottom: 8px; 
    display: grid; grid-template-columns: 1fr auto; gap: 4px 16px; font-size: 12px;
}
.journal-item-info { grid-column: 1 / 2; }
.journal-item-pnl { grid-column: 2 / 3; grid-row: 1 / 3; text-align: right; font-weight: bold; font-size: 14px; align-self: center; }
.journal-item-time { grid-column: 1 / 2; color: var(--muted); }
.journal-item .pnl-up { color: var(--good); }
.journal-item .pnl-down { color: var(--danger); }

.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.5);
  backdrop-filter: blur(4px); z-index: 9997; display: flex; justify-content: center;
  align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: min(90vw, 380px); background: var(--panel); border: 1px solid var(--border-color);
  border-radius: 16px; padding: 24px; text-align: center; transform: scale(0.9);
  transition: transform 0.3s ease; box-shadow: 0 10px 30px rgba(0,0,0,0.1);
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-header { font-weight: bold; margin-bottom: 16px; font-size: 20px; }
.event-modal-icon { font-size: 48px; margin-bottom: 12px; }
.event-modal-desc { color: var(--muted); margin-bottom: 20px; text-align: left; line-height: 1.6; }

#tutorial-overlay { z-index: 10000; background: none; backdrop-filter: none; pointer-events: all; }
#tutorial-highlight {
    position: absolute; border-radius: 8px; box-shadow: 0 0 0 9999px rgba(0,0,0,0.7);
    transition: all 0.3s ease-in-out; pointer-events: none;
}
#tutorial-box {
    position: absolute; background: var(--panel); padding: 16px; border-radius: 12px;
    width: 280px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: all 0.3s ease-in-out;
}
#tutorial-text { margin-bottom: 16px; line-height: 1.6; }
#tutorial-nav { display: flex; justify-content: space-between; align-items: center; }
#tutorial-dots { display: flex; gap: 6px; }
.tutorial-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border-color); }
.tutorial-dot.active { background: var(--accent); }

.glowing-btn { animation: glowing 1.5s infinite; }
@keyframes glowing {
    0% { box-shadow: 0 0 5px var(--accent); }
    50% { box-shadow: 0 0 20px var(--accent); }
    100% { box-shadow: 0 0 5px var(--accent); }
}

.end-game-stats { display: flex; justify-content: space-around; margin: 24px 0; text-align: center; }
.end-game-stats .label { font-size: 14px; color: var(--muted); }
.end-game-stats .value { font-size: 24px; font-weight: bold; display: block; margin-top: 4px; }
#endGameModal .btn { width: 100%; margin-top: 8px; }
#endGameModal .cta-btn { background-color: var(--accent); color: white; text-decoration: none; display: inline-block; line-height: 1.5; }

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <div class="stats">
        <div><span class="label">Ê®°Êì¨Êó•Êúü</span><span class="value" id="current-date">--</span></div>
        <div><span class="label">Â∏≥Êà∂Ê∑®ÂÄº</span><span class="value" id="equity">$10000.00</span></div>
        <div><span class="label">Á∏ΩÊêçÁõä</span><span class="value" id="total-pnl">$0.00</span></div>
    </div>
    <div class="progress-bar"><div id="progress-bar-inner" class="progress-bar-inner"></div></div>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div id="price-lines-container"></div>
    <div class="price-axis" id="price-axis"></div>
  </div>
  <div class="actions-panel">
    <div class="tabs">
        <button class="tab-btn active" data-tab="trade-panel">‰∫§Êòì</button>
        <button class="tab-btn" data-tab="positions-panel">ÊåÅÂÄâ</button>
        <button class="tab-btn" data-tab="journal-panel">Á¥ÄÈåÑ</button>
    </div>
    <div id="trade-panel" class="tab-content active">
        <div id="trade-panel-content">
            <div id="trade-sl-group" class="input-group">
                <label for="trade-sl">ÂÅúÊêç SL</label>
                <div class="input-stepper">
                    <input id="trade-sl" type="number" placeholder="ÂÉπÊ†º" data-step="0.5">
                    <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-sl" data-direction="up">‚ñ≤</button>
                        <button class="stepper-btn" data-target="trade-sl" data-direction="down">‚ñº</button>
                    </div>
                </div>
            </div>
            <div id="trade-lots-group" class="input-group">
                <label for="trade-lots">ÊâãÊï∏</label>
                <div class="input-stepper">
                    <input id="trade-lots" type="number" value="0.1" step="0.01" min="0.01">
                    <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-lots" data-direction="up">‚ñ≤</button>
                        <button class="stepper-btn" data-target="trade-lots" data-direction="down">‚ñº</button>
                    </div>
                </div>
            </div>
            <div id="trade-tp-group" class="input-group">
                <label for="trade-tp">ÂÅúÂà© TP</label>
                <div class="input-stepper">
                     <input id="trade-tp" type="number" placeholder="ÂÉπÊ†º" data-step="0.5">
                     <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-tp" data-direction="up">‚ñ≤</button>
                        <button class="stepper-btn" data-target="trade-tp" data-direction="down">‚ñº</button>
                    </div>
                </div>
            </div>
            <button class="btn sell" id="btnSell">Sell</button>
            <button class="btn" id="btnCloseAll">Âπ≥ÂÄâ</button>
            <button class="btn buy" id="btnBuy">Buy</button>
        </div>
    </div>
    <div id="positions-panel" class="tab-content">
        <div id="positions-list"></div>
    </div>
    <div id="journal-panel" class="tab-content">
        <div id="journal-list"></div>
    </div>
    <div class="playback-controls" id="playback-controls">
        <button class="btn" id="play-pause-btn">‚ñ∂</button>
        <button class="btn" id="step-btn">ÈÄêK ‚Üí</button>
        <div id="speed-controls">
            <button class="btn speed-btn" data-speed="400">0.25x</button>
            <button class="btn speed-btn" data-speed="200">0.5x</button>
            <button class="btn speed-btn active" data-speed="100">1x</button>
            <button class="btn speed-btn" data-speed="50">2x</button>
            <button class="btn speed-btn" data-speed="10">5x</button>
        </div>
        <button class="btn" id="zoom-out">-</button>
        <button class="btn" id="zoom-in">+</button>
    </div>
  </div>
</div>

<div id="eventModal" class="modal-overlay">
    <div class="modal-content event-modal-content">
      <div class="event-modal-icon">üì∞</div>
      <h2 class="modal-header" id="event-title"></h2>
      <p class="event-modal-desc" id="event-desc"></p>
      <button class="btn" id="event-continue-btn">ÁπºÁ∫å</button>
    </div>
</div>

<div id="tutorial-overlay" class="modal-overlay">
    <div id="tutorial-highlight"></div>
    <div id="tutorial-box">
        <p id="tutorial-text"></p>
        <div id="tutorial-nav">
            <button class="btn" id="tutorial-skip">Áï•ÈÅé</button>
            <div id="tutorial-dots"></div>
            <button class="btn" id="tutorial-next">‰∏ã‰∏ÄÊ≠•</button>
        </div>
    </div>
</div>

<div id="endGameModal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-header">ÊåëÊà∞ÁµêÊùüÔºÅ</h2>
      <div class="end-game-stats">
          <div>
              <span class="label">ÊúÄÁµÇÊ∑®ÂÄº</span>
              <span class="value" id="final-equity">$0.00</span>
          </div>
          <div>
              <span class="label">Á∏ΩÊêçÁõä</span>
              <span class="value" id="final-pnl">$0.00</span>
          </div>
      </div>
      <a href="https://www.google.com/" target="_blank" class="btn cta-btn" id="cta-btn">Áû≠Ëß£Â¶Ç‰ΩïÂèñÂæóÈ´òÂàÜ</a>
      <button class="btn" id="restart-btn">ÂÜçÊ¨°ÊåëÊà∞</button>
    </div>
</div>

<script>
'use strict';

const EVENTS = {
  "2025-01-03": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "‰øóÁ®±„ÄåÈùûËæ≤„ÄçÁöÑÁæéÂúãÂ∞±Ê•≠Êï∏ÊìöÊòØÂ∏ÇÂ†¥ÊúÄÈóúÊ≥®ÁöÑÊåáÊ®ô‰πã‰∏Ä„ÄÇÊï∏ÊìöÂ•ΩÂ£ûÂ∞áÂäáÁÉàÂΩ±ÈüøÈªÉÈáëÂÉπÊ†ºÔºåÂ∏ÇÂ†¥Â±èÊÅØ‰ª•ÂæÖÔºÅ" },
  "2025-01-20": { time: "12:00", title: "üá∫üá∏ ÁæéÂúãÁ∏ΩÁµ±Â∞±ËÅ∑ÂÖ∏Á¶Æ", desc: "Êñ∞‰ªªÁæéÂúãÁ∏ΩÁµ±Â∞áÊñºËèØÁõõÈ†ìÁâπÂçÄÂÆ£Ë™ìÂ∞±ËÅ∑„ÄÇÂ∞±ËÅ∑ÊºîË™™ÈÄöÂ∏∏ÊúÉÊ¶ÇËø∞Êñ∞ÊîøÂ∫úÁöÑÊñΩÊîøËóçÂúñÔºåÂÖßÂÆπÂèØËÉΩÊ∂âÂèäÂúãÂÖßÂ§ñÊîøÁ≠ñ„ÄÅÁ∂ìÊøüÊñπÂêëÁ≠âÔºåÈÄô‰∫õÈÉΩÂèØËÉΩÊàêÁÇ∫Â∏ÇÂ†¥ÈóúÊ≥®ÁöÑÁÑ¶Èªû„ÄÇ" },
  "2025-01-30": { time: "20:45", title: "üá™üá∫ Ê≠êÊ¥≤Â§ÆË°å (ECB) Âà©ÁéáÊ±∫Á≠ñÊúÉË≠∞", desc: "Ê≠êÊ¥≤Â§ÆË°åÁÆ°ÁêÜÂßîÂì°ÊúÉÂ∞áÂè¨ÈñãË≤®Âπ£ÊîøÁ≠ñÊúÉË≠∞‰∏¶ÁôºÂ∏ÉÂà©ÁéáÊ±∫Á≠ñËÅ≤Êòé„ÄÇÂ∏ÇÂ†¥Â∞áÈóúÊ≥®ÂÖ∂Â∞çÊ≠êÂÖÉÂå∫Á∂ìÊøüÂâçÊôØÂíåÈÄöËÜ®Ë∑ØÂæëÁöÑÊúÄÊñ∞Ë©ï‰º∞„ÄÇ" },
  "2025-02-07": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "Êú¨ÊúàÈùûËæ≤Êï∏ÊìöÂÖ¨Â∏ÉÔºåÂ∞áÂÜçÊ¨°ËÄÉÈ©óÂ∏ÇÂ†¥Â∞çÁæéÂúãÁ∂ìÊøüÂæ©Áî¶ÂäõÂ∫¶ÁöÑ‰ø°ÂøÉ„ÄÇ" },
  "2025-03-05": { time: "10:00", title: "üá®üá≥ ‰∏≠ÂúãÂÖ®Âúã‰∫∫Ê∞ë‰ª£Ë°®Â§ßÊúÉÂπ¥ÊúÉÈñãÂπï", desc: "‰∏≠ÂúãÂ∞áÂÖ¨Â∏ÉÁï∂Âπ¥Â∫¶ÁöÑGDPÂ¢ûÈï∑ÁõÆÊ®ô„ÄÅË≤°ÊîøÈ†êÁÆóÁ≠â‰∏ªË¶ÅÁ∂ìÊøüÊåáÊ®ôÔºå‰∏¶Èó°Ëø∞Áõ∏ÈóúÊîøÁ≠ñÊñπÂêë„ÄÇ" },
  "2025-03-07": { time: "21:30", title: "üá∫ÔøΩ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "ÈÄ£Á∫åÁ¨¨‰∏âÂÄãÊúàÁöÑÈùûËæ≤Êï∏ÊìöÔºåÂ∏ÇÂ†¥Â∞áÂ∞ãÊâæÂãûÂãïÂäõÂ∏ÇÂ†¥ÊòØÂê¶ÊåÅÁ∫åÁ©©ÂÆöÁöÑÁ∑öÁ¥¢„ÄÇ" },
  "2025-03-19": { time: "03:00", title: "üá∫üá∏ ËÅØÊ∫ñÊúÉÂà©ÁéáÊ±∫Á≠ñ (FOMC)", desc: "ËÅØÊ∫ñÊúÉÂ∞áÁôºÂ∏ÉÂà©ÁéáÊ±∫Á≠ñÔºåÊúÉË≠∞Â∞áÂåÖÂê´ÊúÄÊñ∞ÁöÑÁ∂ìÊøüÈ†êÊ∏¨ÊëòË¶Å (SEP) Âíå„ÄåÈªûÈô£Âúñ„ÄçÔºåÊè≠Á§∫Êú™‰æÜÂà©ÁéáË∑ØÂæëÈ†êÊúü„ÄÇ" },
  "2025-04-04": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "Á¨¨‰∫åÂ≠£Â∫¶ÁöÑÈ¶ñÊ¨°ÈùûËæ≤Â†±ÂëäÔºåÂ∞áÁÇ∫Â∏ÇÂ†¥Â∞ç‰∏äÂçäÂπ¥ÁöÑÁ∂ìÊøüÈ†êÊ∏¨ÂÆö‰∏ãÂü∫Ë™ø„ÄÇ" },
  "2025-04-10": { time: "20:45", title: "üá™üá∫ Ê≠êÊ¥≤Â§ÆË°å (ECB) Âà©ÁéáÊ±∫Á≠ñÊúÉË≠∞", desc: "Âú®Á¨¨‰∏ÄÂ≠£Á∂ìÊøüÊï∏ÊìöÂÖ¨Â∏É‰πãÂæåÔºåÂ∏ÇÂ†¥Â∞áÈóúÊ≥®Ê≠êÊ¥≤Â§ÆË°åÊòØÂê¶ÊúÉÊ†πÊìöÊúÄÊñ∞Êï∏ÊìöË™øÊï¥ÂÖ∂Ë≤®Âπ£ÊîøÁ≠ñÁ´ãÂ†¥„ÄÇ" },
  "2025-04-21": { time: "09:00", title: "IMF „Ää‰∏ñÁïåÁ∂ìÊøüÂ±ïÊúõ„ÄãÂ†±Âëä", desc: "ÂúãÈöõË≤®Âπ£Âü∫ÈáëÁµÑÁπîÂ∞áÊõ¥Êñ∞Â∞çÂÖ®ÁêÉ‰∏ªË¶ÅÁ∂ìÊøüÈ´îÁöÑÂ¢ûÈï∑È†êÊ∏¨Ôºå‰∏¶ÂàÜÊûêÂÖ®ÁêÉÈù¢Ëá®ÁöÑÊΩõÂú®È¢®Èö™„ÄÇ" },
  "2025-05-02": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "Êò•Â≠£ÁöÑÂ∞±Ê•≠Â∏ÇÂ†¥Ë°®ÁèæÂ¶Ç‰ΩïÔºüÊú¨Ê¨°ÈùûËæ≤Êï∏ÊìöÂ∞áÊèê‰æõÈóúÈçµÁ≠îÊ°à„ÄÇ" },
  "2025-05-09": { time: "15:00", title: "üá∑üá∫ ‰øÑÁæÖÊñØÂãùÂà©Êó•Èñ±ÂÖµ", desc: "‰øÑÁæÖÊñØÁ∏ΩÁµ±ÈÄöÂ∏∏ÊúÉÁôºË°®ÊºîË™™ÔºåÂ∏ÇÂ†¥ÊúÉÈóúÊ≥®ÂÖ∂ÁôºË®ÄÊòØÂê¶ÂåÖÂê´‰ªª‰ΩïÊñ∞ÁöÑÂú∞Á∑£ÊîøÊ≤ª‰ø°Ëôü„ÄÇ" },
  "2025-06-06": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "Â§èÂ≠£ÂâçÁöÑÊúÄÂæå‰∏ÄÊ¨°ÈáçË¶ÅÂ∞±Ê•≠Â†±ÂëäÔºåÂèØËÉΩÂΩ±ÈüøËÅØÊ∫ñÊúÉ‰∏ãÂçäÂπ¥ÁöÑÊîøÁ≠ñÈ†êÊúü„ÄÇ" },
  "2025-06-13": { time: "14:00", title: "G7 È†òË¢ñÂ≥∞ÊúÉÈñãÂπï", desc: "‰∏ÉÂúãÈõÜÂúòÂ≥∞ÊúÉÂú®Âä†ÊãøÂ§ßËàâË°åÔºåÊúÉË≠∞Ë≠∞Á®ãÊ∂µËìãÂÖ®ÁêÉÁ∂ìÊøü„ÄÅÊ∞£ÂÄôËÆäÈÅ∑„ÄÅÂú∞Á∑£ÊîøÊ≤ªÁ≠âÂ§öÈ†ÖË≠∞È°å„ÄÇ" },
  "2025-07-01": { time: "10:00", title: "üá®üá≥ ‰∏≠ÂúãÂÖ±Áî¢Èª®ÊàêÁ´ãÈÄ±Âπ¥Á¥ÄÂøµÊó•", desc: "Áõ∏ÈóúÊ¥ªÂãïÂíåËÅ≤ÊòéÂèØËÉΩÊúÉÂÇ≥ÈÅîÈóúÊñº‰∏≠ÂúãÊú™‰æÜÁôºÂ±ïÊñπÂêëÁöÑ‰ø°Ëôü„ÄÇ" },
  "2025-07-03": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "Âõ†7Êúà4Êó•ÁÇ∫ÁæéÂúãÁç®Á´ãÊó•ÂÅáÊúüÔºåÊú¨ÊúàÈùûËæ≤Êï∏ÊìöÊèêÂâçËá≥ÈÄ±ÂõõÂÖ¨Â∏É„ÄÇ" },
  "2025-07-30": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÁ¨¨‰∫åÂ≠£GDPÂàùÂÄº", desc: "Ë©≤Êï∏ÊìöÊòØË°°ÈáèÁæéÂúãÁ∂ìÊøüÂÅ•Â∫∑ÁãÄÊ≥ÅÁöÑÈáçË¶ÅÊåáÊ®ôÔºåÂ∞áÊèê‰æõÂ∞çÁ¨¨‰∫åÂ≠£Â∫¶Á∂ìÊøüÊ¥ªÂãïÁöÑÂàùÊ≠•Ë©ï‰º∞„ÄÇ" },
  "2025-08-01": { time: "21:30", title: "üá∫üá∏ ÁæéÂúãÈùûËæ≤Â∞±Ê•≠Êï∏Êìö (NFP)", desc: "ÂÖ´ÊúàÁöÑÈùûËæ≤Â†±ÂëäÔºåÂ∞áÁÇ∫Â§èÊú´ÁöÑÂ∏ÇÂ†¥ÊÉÖÁ∑íÂÆöË™ø„ÄÇ" },
  "2025-08-15": { time: "12:00", title: "üáÆüá≥ Âç∞Â∫¶Áç®Á´ãÁ¥ÄÂøµÊó•", desc: "Âç∞Â∫¶Á∏ΩÁêÜÂ∞áÁôºË°®ÊºîË™™ÔºåÈó°Ëø∞Êú™‰æÜÊîøÂ∫úÁöÑÊñΩÊîøÈáçÈªûÔºåÂ∞§ÂÖ∂ÊòØÂú®Á∂ìÊøüÁôºÂ±ïÂíåÂ§ñ‰∫§ÊîøÁ≠ñÊñπÈù¢„ÄÇ" }
};

const CONFIG = {
  gameDurationMonths: 1,
  minBarsInView: 20,
  maxBarsInView: 200,
  initialBalance: 10000,
  timeAxisHeight: 25,
};

let state = {};
const el = id => document.getElementById(id);
let canvas, ctx, chartWrap;
let CHART_COLORS = {};
let hasPlayedOnce = false;
let animationFrameId;

// --- Data Handling ---
function loadData() {
  return new Promise(async (resolve) => {
    try {
      const response = await fetch('https://raw.githubusercontent.com/bless25min/SoyaPlayableAd/main/XAUUSD_M15.csv');
      if (!response.ok) throw new Error('Network response was not ok');
      const text = await response.text();
      state.fullDataset = parseData(text);
      resolve(true);
    } catch (error) {
      console.error("ÁÑ°Ê≥ïËºâÂÖ•ÊàñËß£ÊûêÊï∏Êìö:", error);
      el('current-date').textContent = "Êï∏ÊìöÈåØË™§";
      resolve(false);
    }
  });
}

function parseData(text) {
    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
    if (lines.length < 2) return [];
    const header = lines.shift() || '';
    const dataLines = lines;
    const isTimestampFormat = header.startsWith('time,') || /^\d{10,}/.test(dataLines[0]);
    
    console.log(isTimestampFormat ? "ÂÅµÊ∏¨Âà∞Ê†ºÂºè: Unix ÊôÇÈñìÊà≥ + ÈÄóËôüÂàÜÈöî" : "ÂÅµÊ∏¨Âà∞Ê†ºÂºè: Êó•ÊúüÊôÇÈñìÂ≠ó‰∏≤ + Á©∫Ê†º/Tab ÂàÜÈöî");
    
    return dataLines.map(line => {
        let p = null;
        try {
            if (isTimestampFormat) {
                const parts = line.split(',');
                if (parts.length < 5) return null;
                p = { 
                    date: new Date(parseInt(parts[0], 10) * 1000),
                    o: parseFloat(parts[1]), h: parseFloat(parts[2]),
                    l: parseFloat(parts[3]), c: parseFloat(parts[4])
                };
            } else {
                const parts = line.trim().split(/\s+/);
                if (parts.length < 6) return null;
                const dateStr = parts[0].replace(/\./g, '-');
                const timeStr = parts[1];
                p = {
                    date: new Date(`${dateStr}T${timeStr}`),
                    o: parseFloat(parts[2]), h: parseFloat(parts[3]),
                    l: parseFloat(parts[4]), c: parseFloat(parts[5]),
                };
            }
            if (Object.values(p).some(val => val === null || (val instanceof Date && isNaN(val.getTime())) || (typeof val === 'number' && isNaN(val)))) {
                return null;
            }
            return p;
        } catch(e) {
            return null;
        }
    }).filter(Boolean);
}

// --- Game Flow ---
function startGame() {
  if (!state.fullDataset || state.fullDataset.length < 200) {
      el('current-date').textContent = "Êï∏ÊìöÈåØË™§"; return;
  }
  
  state = {
    ...state,
    gameData: [], currentBarIndex: 0, positions: [], journal: [],
    chartAnimations: [], account: { balance: CONFIG.initialBalance, equity: CONFIG.initialBalance },
    isPaused: true, gameTimer: null, animationSpeed: 100,
    view: { barsInView: 100, offset: 0 },
    pan: { isPanning: false, startX: 0, startOffset: 0 },
    lastDrawTime: 0
  };
  
  document.querySelectorAll('.speed-btn.active').forEach(b => b.classList.remove('active'));
  document.querySelector('.speed-btn[data-speed="100"]').classList.add('active');

  const minStartDate = new Date('2025-01-01T00:00:00');
  const maxStartDate = new Date('2025-07-15T00:00:00');
  const minStartIndex = state.fullDataset.findIndex(b => b.date >= minStartDate);
  const maxStartIndex = state.fullDataset.findIndex(b => b.date >= maxStartDate);

  if (minStartIndex === -1 || maxStartIndex === -1) {
    console.error("Âú®Êï∏ÊìöÈõÜ‰∏≠Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑÊó•ÊúüÁØÑÂúç"); return;
  }

  const randomStartIndex = Math.floor(Math.random() * (maxStartIndex - minStartIndex + 1)) + minStartIndex;
  const startDate = state.fullDataset[randomStartIndex].date;
  let endDate = new Date(startDate);
  endDate.setMonth(endDate.getMonth() + CONFIG.gameDurationMonths);

  let endIndex = state.fullDataset.findIndex(b => b.date >= endDate);
  if (endIndex === -1) endIndex = state.fullDataset.length;
  
  state.gameData = state.fullDataset.slice(randomStartIndex, endIndex);
  state.currentBarIndex = 0;
  state.view.offset = state.currentBarIndex - state.view.barsInView;
  clampOffset();

  updateHUD();
  updatePositionsList();
  updateJournalList();
  
  if (!hasPlayedOnce) {
    startTutorial();
    hasPlayedOnce = true;
  }
  
  el('play-pause-btn').textContent = '‚ñ∂';
  el('play-pause-btn').disabled = false;
  el('step-btn').disabled = false;
}

function gameLoop() {
    if (state.isPaused) return;
    
    if (state.currentBarIndex >= state.gameData.length - 1) {
        pauseGame();
        showEndScreen();
        return;
    }
    
    const bar = state.gameData[state.currentBarIndex];
    if (bar) {
        const dateStr = bar.date.toISOString().slice(0, 10);
        const event = EVENTS[dateStr];
        const eventTime = event ? parseInt(event.time.split(':')[0]) * 60 + parseInt(event.time.split(':')[1]) : null;
        if (event && !event.triggered && (bar.date.getHours() * 60 + bar.date.getMinutes() >= eventTime)) {
            pauseGame();
            showEventModal(event);
            event.triggered = true;
            return;
        }
    }
    
    state.currentBarIndex++;
    updatePositions();
    updateHUD();
    if (state.view.offset + state.view.barsInView < state.currentBarIndex + 10) {
        state.view.offset = state.currentBarIndex - state.view.barsInView + 10;
        clampOffset();
    }
}

function stepForward() {
    pauseGame();
    gameLoop();
}

function pauseGame() {
    state.isPaused = true;
    clearInterval(state.gameTimer);
    el('play-pause-btn').classList.remove('active');
    el('play-pause-btn').textContent = '‚ñ∂';
}

function resumeGame() {
    state.isPaused = false;
    clearInterval(state.gameTimer);
    state.gameTimer = setInterval(gameLoop, state.animationSpeed);
    el('play-pause-btn').classList.add('active');
    el('play-pause-btn').textContent = '‚ùö‚ùö';
}

function openOrder(side) {
    const lots = parseFloat(el('trade-lots').value);
    const sl = parseFloat(el('trade-sl').value) || null;
    const tp = parseFloat(el('trade-tp').value) || null;

    if (!lots || lots <= 0) return;
    const currentBar = state.gameData[state.currentBarIndex];
    const entryPrice = currentBar.c;
    
    state.positions.push({ id: Date.now(), side, entryPrice, entryTime: currentBar.date, lots, sl, tp, pnl: 0 });
    
    addChartAnimation(entryPrice, side, 'open');
    updatePositionsList();
}

function closePosition(positionId) {
    const index = state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;

    const position = state.positions[index];
    const currentBar = state.gameData[state.currentBarIndex];
    const exitPrice = currentBar.c;
    const finalPnl = (exitPrice - position.entryPrice) * (position.side === 'buy' ? 1 : -1) * position.lots * 100;
    
    logTransaction(position, exitPrice, currentBar.date, finalPnl);
    addChartAnimation(exitPrice, position.side, 'close', finalPnl);

    state.account.balance += finalPnl;
    state.positions.splice(index, 1);
    
    updatePositionsList();
    updateHUD();
}

function closeAllPositions() {
    if (state.positions.length === 0) return;
    [...state.positions].forEach(p => closePosition(p.id));
}

function modifyPosition(positionId) {
    const position = state.positions.find(p => p.id === positionId);
    if (!position) return;

    const slInput = el(`pos-sl-${positionId}`);
    const tpInput = el(`pos-tp-${positionId}`);

    position.sl = parseFloat(slInput.value) || null;
    position.tp = parseFloat(tpInput.value) || null;
    
    const itemEl = slInput.closest('.position-item');
    itemEl.style.transition = 'none';
    itemEl.style.backgroundColor = 'var(--accent)';
    setTimeout(() => {
        itemEl.style.transition = 'background-color 0.5s ease';
        itemEl.style.backgroundColor = '';
    }, 100);
}

function updatePositions() {
    if (!state.gameData || state.currentBarIndex >= state.gameData.length) return;
    const currentBar = state.gameData[state.currentBarIndex];
    let totalPnl = 0;
    
    for (let i = state.positions.length - 1; i >= 0; i--) {
        const p = state.positions[i];
        const direction = p.side === 'buy' ? 1 : -1;
        p.pnl = (currentBar.c - p.entryPrice) * direction * p.lots * 100;
        totalPnl += p.pnl;
        
        const hitSL = (p.sl && ((p.side === 'buy' && currentBar.l <= p.sl) || (p.side === 'sell' && currentBar.h >= p.sl)));
        const hitTP = (p.tp && ((p.side === 'buy' && currentBar.h >= p.tp) || (p.side === 'sell' && currentBar.l <= p.tp)));
        
        if (hitSL || hitTP) {
            closePosition(p.id);
        }
    }
    state.account.equity = state.account.balance + totalPnl;
}

function logTransaction(position, exitPrice, exitTime, pnl) {
    state.journal.unshift({ ...position, exitPrice, exitTime, pnl });
    updateJournalList();
}

function updateHUD() {
    const currentDate = state.gameData[state.currentBarIndex]?.date;
    if(currentDate) el('current-date').textContent = currentDate.toISOString().slice(0, 10);
    el('equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - state.account.balance;
    const pnlEl = el('total-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = `value ${totalPnl >= 0 ? 'pnl-up' : 'pnl-down'}`;
    const progress = (state.currentBarIndex + 1) / state.gameData.length * 100;
    el('progress-bar-inner').style.width = `${progress}%`;
}

function updatePositionsList() {
    const listEl = el('positions-list');
    if (state.positions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">ÁõÆÂâçÊ≤íÊúâÊåÅÂÄâ</p>';
        return;
    }
    listEl.innerHTML = state.positions.map(p => {
        const pnlClass = p.pnl >= 0 ? 'pnl-up' : 'pnl-down';
        const sideClass = p.side === 'buy' ? 'side-buy' : 'side-sell';
        const sideText = p.side === 'buy' ? 'Ë≤∑ÂÖ•' : 'Ë≥£Âá∫';
        
        return `
        <div class="position-item">
            <div class="position-item-info">
                <span class="${sideClass}">${sideText}</span> ${p.lots} Êâã @ ${p.entryPrice.toFixed(2)}
            </div>
            <div class="position-item-pnl ${pnlClass}">
                ${p.pnl.toFixed(2)}
            </div>
            <div class="position-item-sl input-group">
                <label for="pos-sl-${p.id}">ÂÅúÊêç SL</label>
                <input id="pos-sl-${p.id}" type="number" placeholder="ÁÑ°" value="${p.sl || ''}">
            </div>
            <div class="position-item-tp input-group">
                <label for="pos-tp-${p.id}">ÂÅúÂà© TP</label>
                <input id="pos-tp-${p.id}" type="number" placeholder="ÁÑ°" value="${p.tp || ''}">
            </div>
            <div class="position-item-actions">
                <button class="btn modify-btn" onclick="modifyPosition(${p.id})">‰øÆÊîπ</button>
                <button class="btn close-btn" onclick="closePosition(${p.id})">Âπ≥ÂÄâ</button>
            </div>
        </div>`;
    }).join('');
}

function updateJournalList() {
    const listEl = el('journal-list');
    if (state.journal.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">Ê≤íÊúâ‰∫§ÊòìÁ¥ÄÈåÑ</p>';
        return;
    }
    listEl.innerHTML = state.journal.map(j => {
        const pnlClass = j.pnl >= 0 ? 'pnl-up' : 'pnl-down';
        const sideText = j.side === 'buy' ? 'Ë≤∑ÂÖ•' : 'Ë≥£Âá∫';
        const pnlText = `${j.pnl >= 0 ? '+' : ''}${j.pnl.toFixed(2)}`;
        const timeFormat = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const entryTimeStr = j.entryTime.toLocaleTimeString('en-GB', timeFormat);
        const exitTimeStr = j.exitTime.toLocaleTimeString('en-GB', timeFormat);

        return `
        <div class="journal-item">
            <div class="journal-item-info">
                ${sideText} ${j.lots} Êâã @ ${j.entryPrice.toFixed(2)} ‚Üí ${j.exitPrice.toFixed(2)}
            </div>
            <div class="journal-item-time">
                ${entryTimeStr} ‚Üí ${exitTimeStr}
            </div>
            <div class="journal-item-pnl ${pnlClass}">
                ${pnlText}
            </div>
        </div>`;
    }).join('');
}

function showEventModal(event) {
    el('event-title').textContent = event.title;
    el('event-desc').textContent = event.desc;
    el('eventModal').classList.add('visible');
}

function showEndScreen() {
    el('final-equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - CONFIG.initialBalance;
    const pnlEl = el('final-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = `value ${totalPnl >= 0 ? 'pnl-up' : 'pnl-down'}`;
    
    el('endGameModal').classList.add('visible');
    el('play-pause-btn').disabled = true;
    el('step-btn').disabled = true;
}

function drawPriceAxis(yMin, yMax, chartH) {
    const priceAxisEl = el('price-axis');
    priceAxisEl.innerHTML = '';
    const numTicks = Math.max(2, Math.floor(chartH / 50));

    for (let i = 0; i <= numTicks; i++) {
        const price = yMin + (i / numTicks) * (yMax - yMin);
        const yPos = chartH - (i / numTicks) * chartH;
        if (yPos < 0 || yPos > chartH) continue;
        const tick = document.createElement('div');
        tick.className = 'price-axis-tick';
        tick.style.top = `${yPos}px`;
        tick.textContent = price.toFixed(2);
        priceAxisEl.appendChild(tick);
    }
}

function drawCurrentPriceLine(y) {
    const priceLinesContainer = el('price-lines-container');
    priceLinesContainer.innerHTML = '';
    if (!state.gameData || !state.gameData[state.currentBarIndex]) return;
    const currentPrice = state.gameData[state.currentBarIndex].c;
    const yPos = y(currentPrice);
    if (yPos < 0 || yPos > canvas.getBoundingClientRect().height - CONFIG.timeAxisHeight) return;

    const isUp = state.currentBarIndex > 0 && currentPrice >= state.gameData[state.currentBarIndex - 1].c;
    const color = isUp ? CHART_COLORS.up : CHART_COLORS.down;

    const line = document.createElement('div');
    line.className = 'price-line';
    line.style.top = `${yPos}px`;
    
    const label = document.createElement('div');
    label.className = 'price-line-label';
    label.style.top = `${yPos}px`;
    label.style.backgroundColor = color;
    label.textContent = currentPrice.toFixed(2);

    priceLinesContainer.appendChild(line);
    priceLinesContainer.appendChild(label);
}

function drawTimeAxis(ctx, W, H, startIdx, endIdx, barWidth, offset) {
    ctx.fillStyle = CHART_COLORS.text;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const labelMod = Math.ceil(state.view.barsInView / (W / 100));
    let lastDateStr = '';
    for (let i = Math.floor(startIdx); i < endIdx; i++) {
        if (i < 0 || i >= state.gameData.length) continue;
        
        const bar = state.gameData[i];
        const x = (i - offset) * barWidth + barWidth / 2;
        const date = bar.date;
        const dateStr = date.toISOString().slice(5, 10);
        
        if (dateStr !== lastDateStr && i % labelMod < 1) {
            ctx.fillText(dateStr, x, H - CONFIG.timeAxisHeight + 5);
            lastDateStr = dateStr;
        }
    }
}

function addChartAnimation(price, side, type, pnl) {
    state.chartAnimations.push({ price, side, type, pnl, startTime: performance.now(), duration: 800 });
}

function draw() {
    animationFrameId = requestAnimationFrame(draw);
    if (!ctx || !state.gameData) return;
    
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
    }
    const W = rect.width;
    const H = rect.height;
    const chartH = H - CONFIG.timeAxisHeight;
  
    ctx.fillStyle = CHART_COLORS.bg;
    ctx.fillRect(0, 0, W, H);

    if (state.gameData.length === 0) return;
    
    const startIdx = Math.floor(state.view.offset);
    const endIdx = startIdx + Math.ceil(state.view.barsInView);
    const dataInView = state.gameData.slice(Math.max(0, startIdx), Math.min(state.currentBarIndex + 1, endIdx));
    if (dataInView.length === 0) return;
  
    const hi = Math.max(...dataInView.map(b => b.h));
    const lo = Math.min(...dataInView.map(b => b.l));
    const pad = (hi - lo) * 0.1 || 1;
    const yMax = hi + pad, yMin = lo - pad;
    const barWidth = W / state.view.barsInView;
    const y = v => chartH - ((v - yMin) / (yMax - yMin) * chartH);
  
    drawPriceAxis(yMin, yMax, chartH);
    drawCurrentPriceLine(y);
    drawTimeAxis(ctx, W, H, startIdx, endIdx, barWidth, state.view.offset);

    const now = performance.now();
    if (!state.lastDrawTime) state.lastDrawTime = now;
    const elapsed = now - state.lastDrawTime;
    if (elapsed >= state.animationSpeed && !state.isPaused) {
        state.lastDrawTime = now;
    }
    const progress = state.isPaused ? 1 : elapsed / state.animationSpeed;

    for (let i = 0; i < dataInView.length; i++) {
        const barIndex = startIdx + i;
        const b = dataInView[i];
        const x = (barIndex - state.view.offset) * barWidth + barWidth / 2;
        const isLastBar = barIndex === state.currentBarIndex;
        
        const p = isLastBar ? progress : 1;
        const up = b.c >= b.o;
        const color = up ? CHART_COLORS.up : CHART_COLORS.down;
        ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 1.5;
        
        const wickProgress = Math.min(1, p / 0.5);
        const bodyProgress = Math.min(1, Math.max(0, (p - 0.5) / 0.5));
        
        const wickH = y(b.o + (b.h - b.o) * wickProgress);
        const wickL = y(b.o + (b.l - b.o) * wickProgress);
        const bodyC = y(b.o + (b.c - b.o) * bodyProgress);

        ctx.beginPath(); ctx.moveTo(x, wickH); ctx.lineTo(x, wickL); ctx.stroke();
        
        const w = Math.max(2, barWidth * 0.7);
        const bodyY = Math.min(y(b.o), bodyC);
        const bodyH = Math.max(1, Math.abs(y(b.o) - bodyC));
        ctx.fillRect(x - w / 2, bodyY, w, bodyH);
    }
  
    state.positions.forEach(p => {
        ctx.font = 'bold 12px sans-serif'; ctx.textBaseline = 'middle';
        
        [{price: p.entryPrice, color: p.side === 'buy' ? CHART_COLORS.up : CHART_COLORS.down, dash: [2,4], label: 'ENTRY'},
         {price: p.sl, color: 'var(--warning)', dash: [5,5]},
         {price: p.tp, color: 'var(--purple)', dash: [5,5]}
        ].forEach(line => {
            if(!line.price) return;
            const lineY = y(line.price);
            if(lineY <= chartH && lineY >= 0){
                ctx.strokeStyle = line.color; ctx.setLineDash(line.dash); ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(0, lineY); ctx.lineTo(W - 60, lineY); ctx.stroke();
                if(line.label === 'ENTRY'){
                    const pnlText = `${p.pnl >= 0 ? '+' : ''}${p.pnl.toFixed(2)}`;
                    const labelText = `${p.side.toUpperCase()} @ ${p.entryPrice.toFixed(2)} (${pnlText})`;
                    ctx.textAlign = 'left';
                    const bgColor = p.pnl >= 0 ? CHART_COLORS.up : CHART_COLORS.down;
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(5, lineY - 10, textWidth + 8, 20);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(labelText, 9, lineY);
                }
            }
        });
        ctx.setLineDash([]);
    });

    state.chartAnimations = state.chartAnimations.filter(anim => {
        const elapsed = now - anim.startTime;
        if (elapsed > anim.duration) return false;

        const progress = elapsed / anim.duration;
        const x = (state.currentBarIndex - state.view.offset) * barWidth + barWidth / 2;
        const animY = y(anim.price);
        
        ctx.globalAlpha = 1 - progress;
        const color = anim.side === 'buy' ? CHART_COLORS.up : CHART_COLORS.down;

        if (anim.type === 'open') {
            const arrowSize = 10 + progress * 10;
            ctx.fillStyle = color; ctx.beginPath();
            if (anim.side === 'buy') {
                ctx.moveTo(x, animY - arrowSize); ctx.lineTo(x - arrowSize/2, animY); ctx.lineTo(x + arrowSize/2, animY);
            } else {
                ctx.moveTo(x, animY + arrowSize); ctx.lineTo(x - arrowSize/2, animY); ctx.lineTo(x + arrowSize/2, animY);
            }
            ctx.closePath(); ctx.fill();
        } else {
            ctx.font = `bold ${14 + progress * 8}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = anim.pnl >= 0 ? CHART_COLORS.up : CHART_COLORS.down;
            const pnlText = `${anim.pnl >= 0 ? '+' : ''}${anim.pnl.toFixed(2)}`;
            ctx.fillText(pnlText, x, animY - 15 - (progress * 30));
        }
        ctx.globalAlpha = 1;
        return true;
    });
}

function setupInteraction() {
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);
    chartWrap.addEventListener('wheel', e => { e.preventDefault(); handleZoom(e.deltaY < 0 ? 1 : -1); }, { passive: false });
    const startPan = (x) => { state.pan.isPanning = true; state.pan.startX = x; state.pan.startOffset = state.view.offset; };
    const movePan = (x) => { if (!state.pan.isPanning) return; const dx = x - state.pan.startX; const barWidth = chartWrap.clientWidth / state.view.barsInView; state.view.offset = state.pan.startOffset - dx / barWidth; clampOffset(true); };
    const endPan = () => { state.pan.isPanning = false; };
    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);
    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5) : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    clampOffset(true);
}
function clampOffset(isUserAction = false) {
    const maxOffset = state.gameData.length - (isUserAction ? state.view.barsInView * 0.8 : 5);
    state.view.offset = Math.max(-state.view.barsInView * 0.2, Math.min(state.view.offset, maxOffset));
}

function setupSteppers() {
    el('trade-panel-content').addEventListener('click', e => {
        const button = e.target.closest('.stepper-btn');
        if (!button) return;

        const targetInputId = button.dataset.target;
        const direction = button.dataset.direction;
        const input = el(targetInputId);
        if (!input) return;

        let currentValue = parseFloat(input.value);
        const step = parseFloat(input.step || input.dataset.step || 1);
        
        if (['trade-sl', 'trade-tp'].includes(targetInputId) && isNaN(currentValue)) {
            if (state.gameData && state.gameData[state.currentBarIndex]) {
                const currentPrice = state.gameData[state.currentBarIndex].c;
                input.value = currentPrice.toFixed(2);
                return;
            }
        }
        if (isNaN(currentValue)) currentValue = 0;
        let newValue = direction === 'up' ? currentValue + step : currentValue - step;
        if (targetInputId === 'trade-lots') {
            const min = parseFloat(input.min);
            if (!isNaN(min) && newValue < min) newValue = min;
        }
        const decimals = (String(step).split('.')[1] || '').length;
        input.value = newValue.toFixed(Math.max(2, decimals));
    });
}

let tutorialStep = 0;
const tutorialSteps = [
    { text: 'Ê≠°Ëøé‰æÜÂà∞‰∫§ÊòìÊåëÊà∞Ë≥ΩÔºÅÊÇ®ÁöÑÁõÆÊ®ôÊòØÂú®‰∏ÄÂÄãÊúàÁöÑÊ®°Êì¨ÊôÇÈñìÂÖßÔºåÁõ°ÂèØËÉΩÂú∞Áç≤Âà©„ÄÇ' },
    { elementId: 'chartWrap', text: 'ÈÄôË£°ÊòØÂ∏ÇÂ†¥Ëµ∞Âã¢Âúñ„ÄÇÁ∂†Ëâ≤ K Ê£í‰ª£Ë°®‰∏äÊº≤ÔºåÁ¥ÖËâ≤ K Ê£í‰ª£Ë°®‰∏ãË∑å„ÄÇÊÇ®ÂèØ‰ª•ÊãñÊõ≥Êàñ‰ΩøÁî®ÊªæËº™Á∏ÆÊîæ„ÄÇ', position: 'bottom' },
    { elementId: 'trade-panel-content', text: 'Âú®ÈÄôË£°Ë®≠ÂÆöÊâãÊï∏„ÄÅÂÅúÊêçËàáÂÅúÂà©ÔºåÁÑ∂ÂæåÈªûÊìä„ÄåBuy„ÄçÊàñ„ÄåSell„Äç‰æÜ‰∏ãÂñÆ„ÄÇ', position: 'top' },
    { elementId: 'playback-controls', text: '‰ΩøÁî®ÈÄô‰∫õÊåâÈàï‰æÜÊéßÂà∂ÊôÇÈñì„ÄÇÈªûÊìä„Äå‚ñ∂„ÄçËÆìÂ∏ÇÂ†¥Ëá™ÂãïÂâçÈÄ≤ÔºåÊàñÈªûÊìä„ÄåÈÄêK‚Üí„Äç‰∏ÄÊ†π‰∏ÄÊ†πÂú∞ËßÄÁúã„ÄÇ', position: 'top' }
];

function showTutorialStep(stepIndex) {
    const step = tutorialSteps[stepIndex];
    const overlay = el('tutorial-overlay'), highlight = el('tutorial-highlight'), box = el('tutorial-box');
    const text = el('tutorial-text'), nextBtn = el('tutorial-next'), dots = el('tutorial-dots');
    
    const target = step.elementId ? el(step.elementId) : null;
    if (step.elementId && !target) {
        console.error(`Tutorial Error: Element with ID "${step.elementId}" not found. Skipping.`);
        if (++tutorialStep < tutorialSteps.length) showTutorialStep(tutorialStep); else endTutorial();
        return;
    }

    text.textContent = step.text;
    dots.innerHTML = tutorialSteps.map((_, i) => `<div class="tutorial-dot ${i === stepIndex ? 'active' : ''}"></div>`).join('');

    if (target) {
        const rect = target.getBoundingClientRect();
        highlight.style.left = `${rect.left - 5}px`; highlight.style.top = `${rect.top - 5}px`;
        highlight.style.width = `${rect.width + 10}px`; highlight.style.height = `${rect.height + 10}px`;
        box.style.transform = '';
        if (step.position === 'top') {
            box.style.top = `${rect.top - box.offsetHeight - 15}px`;
            box.style.left = `${rect.left + rect.width / 2 - box.offsetWidth / 2}px`;
        } else {
            box.style.top = `${rect.bottom + 15}px`;
            box.style.left = `${rect.left + rect.width / 2 - box.offsetWidth / 2}px`;
        }
    } else { 
        highlight.style.width = '0px'; highlight.style.height = '0px';
        highlight.style.left = '50%'; highlight.style.top = '50%';
        box.style.top = `50%`; box.style.left = `50%`; box.style.transform = 'translate(-50%, -50%)';
    }
    nextBtn.textContent = stepIndex === tutorialSteps.length - 1 ? 'ÈñãÂßãÊåëÊà∞ÔºÅ' : '‰∏ã‰∏ÄÊ≠•';
    overlay.classList.add('visible');
}

function endTutorial() {
    el('tutorial-overlay').classList.remove('visible');
    el('play-pause-btn').classList.add('glowing-btn');
    setTimeout(() => el('play-pause-btn').classList.remove('glowing-btn'), 3000);
}

function startTutorial() { tutorialStep = 0; showTutorialStep(tutorialStep); }

async function init() {
  canvas = el('chart'); ctx = canvas.getContext('2d', { alpha: false }); chartWrap = el('chartWrap');
  
  const dataLoaded = await loadData();
  
  if (dataLoaded) {
    const style = getComputedStyle(document.documentElement);
    CHART_COLORS.up = style.getPropertyValue('--chart-up').trim();
    CHART_COLORS.down = style.getPropertyValue('--chart-down').trim();
    CHART_COLORS.bg = style.getPropertyValue('--chart-bg').trim();
    CHART_COLORS.text = style.getPropertyValue('--chart-text').trim();

    el('btnBuy').onclick = () => openOrder('buy');
    el('btnSell').onclick = () => openOrder('sell');
    el('btnCloseAll').onclick = closeAllPositions;
    
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.onclick = () => {
            if(btn.dataset.tab === 'positions-panel') { pauseGame(); updatePositionsList(); }
            else if (btn.dataset.tab === 'journal-panel') { pauseGame(); updateJournalList(); }
            document.querySelector('.tab-btn.active').classList.remove('active');
            document.querySelector('.tab-content.active').classList.remove('active');
            btn.classList.add('active'); el(btn.dataset.tab).classList.add('active');
        };
    });
    
    el('eventModal').onclick = e => { if (e.target === el('eventModal') || e.target.id === 'event-continue-btn') { el('eventModal').classList.remove('visible'); resumeGame(); } };
    el('play-pause-btn').onclick = () => { el('play-pause-btn').classList.remove('glowing-btn'); state.isPaused ? resumeGame() : pauseGame(); };
    el('step-btn').onclick = () => { el('play-pause-btn').classList.remove('glowing-btn'); stepForward(); };
    el('speed-controls').onclick = e => {
        if (e.target.classList.contains('speed-btn')) {
            document.querySelector('.speed-btn.active').classList.remove('active');
            e.target.classList.add('active');
            state.animationSpeed = parseInt(e.target.dataset.speed);
            if (!state.isPaused) resumeGame();
        }
    };
    el('tutorial-next').onclick = () => { if (++tutorialStep >= tutorialSteps.length) endTutorial(); else showTutorialStep(tutorialStep); };
    el('tutorial-skip').onclick = endTutorial;
    el('restart-btn').onclick = () => { el('endGameModal').classList.remove('visible'); startGame(); };

    setupInteraction();
    setupSteppers(); 
    startGame();
    animationFrameId = requestAnimationFrame(draw);
  }
}

document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
