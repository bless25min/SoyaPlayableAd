<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>反轉分析線訓練 Playable — 真實數據版</title>
<style>
:root{
  --bg:#eef3ff; --panel:#ffffff; --panel-soft:#f4f7ff;
  --text:#1f2a44; --muted:#5b6b8b;
  --accent:#2bb673; --accent2:#2aa3ff;
  --danger:#ff5f6d; --good:#21cf7a; --warn:#ffcc57;
  --grid:#1f2a4414;
}
*{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
body{margin:0;background:linear-gradient(180deg,#f9fbff,#eef3ff 50%);color:var(--text)}
.wrap{max-width:1180px;margin:0 auto;padding:12px}
.toolbar{display:flex;align-items:center;gap:8px;background:var(--panel);border:1px solid #dbe4ff;border-radius:10px;padding:8px 10px;box-shadow:0 6px 18px rgba(31,42,68,.10)}
.btn{
  border-radius:14px; background:linear-gradient(180deg,#ffffff,#f1f6ff);
  border:1px solid #dbe4ff; color:#1f2a44; box-shadow:0 6px 16px rgba(31,42,68,.10);
  padding:6px 10px; cursor:pointer; transition: transform .06s ease, box-shadow .25s ease, background .25s ease;
}
.btn:hover{ box-shadow:0 10px 24px rgba(31,42,68,.18); }
.btn:active{ transform:translateY(1px) scale(.98); }
.btn.buy { background:linear-gradient(180deg,#c9ffe6,#98ffd0); color:#0c2a1a; }
.btn.sell{ background:linear-gradient(180deg,#ffd4d8,#ffadb6); color:#2a0c0c; }
.toolbar .seg{display:flex;border:1px solid #dbe4ff;border-radius:8px;overflow:hidden}
.toolbar .seg button{border:0;background:var(--panel-soft);color:var(--text);padding:6px 10px}
.toolbar .seg button.active{background:#e2e8f9}
.sp{flex:1}
.layout{display:grid;grid-template-columns:220px 1fr;gap:10px;margin-top:10px}
.market{background:var(--panel);border:1px solid #dbe4ff;border-radius:10px;padding:10px}
.market h3{font-size:13px;margin:0 0 8px;color:var(--muted)}
.quote{display:flex;justify-content:space-between;padding:6px 8px;border-radius:8px;background:var(--panel-soft);margin-bottom:6px}
.quote small{color:var(--muted)}
#chartWrap{position:relative;background:var(--panel-soft);border:1px solid #dbe4ff;border-radius:12px;min-height:560px}
#chart{width:100%;height:560px;display:block}
.priceAxis{position:absolute;right:6px;top:6px;bottom:36px;width:70px;pointer-events:none}
.priceAxis .tick{position:absolute;right:0;color:var(--text);font-size:11px;transform:translateY(-50%)}
.timeAxis{position:absolute;left:8px;right:8px;bottom:6px;height:24px;color:var(--muted);font-size:11px}
.timeAxis .tick{position:absolute;bottom:0;transform:translateX(-50%)}
.orderDock{background:var(--panel);border:1px solid #dbe4ff;border-radius:14px;display:flex;gap:10px;align-items:center;padding:10px 12px;box-shadow:0 12px 28px rgba(31,42,68,.15);margin-top:8px}
.orderDock input{width:90px;background:var(--panel-soft);border:1px solid #dbe4ff;border-radius:8px;padding:6px 8px;color:var(--text)}
.tag{font-size:12px;background:var(--panel-soft);border:1px solid #dbe4ff;color:var(--text);border-radius:999px;padding:4px 8px}
.panel{background:var(--panel);border:1px solid #dbe4ff;border-radius:14px;padding:8px;margin-top:10px}
.panel table{width:100%;border-collapse:collapse;font-size:12px}
.panel th,.panel td{border-bottom:1px dashed #dbe4ff;padding:6px;text-align:left;color:var(--text)}
.panel th{color:var(--muted)}
.toast{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);background:var(--panel);color:var(--text);border:1px solid #dbe4ff;padding:10px 14px;border-radius:999px;box-shadow:0 8px 30px rgba(31,42,68,.15);font-size:13px}

/* 收益/虧損回饋動畫 */
.profitPulse{ animation:pulse .8s ease-out; }
.lossShake { animation:shake .5s ease-in-out; }
@keyframes pulse {
  0%{ box-shadow:0 0 0 0 rgba(33,207,122,.45); }
  100%{ box-shadow:0 0 0 22px rgba(33,207,122,0); }
}
@keyframes shake {
  10%, 90% { transform: translateX(-2px); }
  20%, 80% { transform: translateX(4px); }
  30%, 50%, 70% { transform: translateX(-7px); }
  40%, 60% { transform: translateX(7px); }
}

/* Confetti 粒子容器 */
#confetti { position:fixed; inset:0; pointer-events:none; z-index:9999; }

/* 教學引導 */
.tour-mask{ position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9997; }
.tour-tip{
  position:fixed; padding:12px 14px; background:#132342; color:#e7f1ff;
  border:1px solid #ffffff3a; border-radius:12px; z-index:9998; max-width:280px;
  box-shadow:0 8px 28px rgba(0,0,0,.35);
}
.tour-tip .next{ margin-top:8px; display:inline-block; background:var(--accent); color:#0e1930; border:0; padding:6px 10px; border-radius:10px; }

</style>
</head>
<body>
<div id="confetti"></div>
<div class="wrap">
  <div class="toolbar">
    <button class="btn" id="btnPlay">播放/暫停 (Space)</button>
    <button class="btn" id="btnStep">逐K (→)</button>
    <button class="btn" id="btnLive">回到最新(F)</button>
    <div class="seg" id="spdSeg">
      <button data-spd="900">慢</button>
      <button data-spd="650" class="active">中</button>
      <button data-spd="400">快</button>
    </div>
    <div class="sp"></div>
    <button class="btn" id="btnPath">技能樹</button>
    <span class="tag" id="hudInfo">XAUUSD M15</span>
  </div>

  <div id="pathPanel" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:9997;">
    <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(92vw,520px); background:var(--panel); border:1px solid #dbe4ff; border-radius:16px; padding:14px;">
      <div style="font-weight:800; margin-bottom:8px">Trader Path 技能樹</div>
      <div id="pathGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;"></div>
      <div style="text-align:right;margin-top:8px"><button class="btn" id="btnPathClose">關閉</button></div>
    </div>
  </div>

  <div class="layout">
    <aside class="market">
      <h3>Market Watch</h3>
      <div class="quote"><b>XAUUSD</b><span><small>Bid</small> <b id="qBid">—</b> / <small>Ask</small> <b id="qAsk">—</b></span></div>
    </aside>

    <main id="chartCol">
      <div id="chartWrap">
        <canvas id="chart"></canvas>
        <div class="priceAxis" id="priceAxis"></div>
        <div class="timeAxis" id="timeAxis"></div>
      </div>
        <div class="orderDock">
  <div style="font-weight:800;margin-right:6px">下單</div>
  <label>手數<input id="lots" type="number" value="1" min="0.01" step="0.01"></label>
  <label>停損價(SL)<input id="slPrice" type="number" placeholder="可選"></label>
  <label>停利價(TP)<input id="tpPrice" type="number" placeholder="可選"></label>
  <label>掛單價<input id="pendPrice" type="number" placeholder="可選"></label>

  <button class="btn buy"  id="btnBuyNow">立即買入</button>
  <button class="btn sell" id="btnSellNow">立即賣出</button>
  <button class="btn buy"  id="btnPendBuy">掛單買入</button>
  <button class="btn sell" id="btnPendSell">掛單賣出</button>
  <button class="btn"      id="btnCloseAll">平倉全部</button>

  <span class="tag" id="riskBuy">買入停損：$0.00</span>
  <span class="tag" id="riskSell">賣出停損：$0.00</span>
  <span class="tag" id="riskPend">掛單停損：$0.00</span>
</div>
      </main>
  </div>

  <section class="bottom" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
    <div class="panel">
      <table>
        <thead><tr><th>方向</th><th>進場</th><th>SL</th><th>TP</th><th>手數</th><th>損益</th><th></th></tr></thead>
        <tbody id="posBody"></tbody>
      </table>
    </div>
    <div class="panel">
      <table>
        <thead><tr><th>時間</th><th>事件</th><th>方向</th><th>價位</th><th>手數</th><th>備註</th></tr></thead>
        <tbody id="journalBody"></tbody>
      </table>
    </div>
  </section>
</div>

<script>
// ===== Config =====
const CONFIG = {
  symbol: "XAUUSD",
  timeframe: "M15",
  playSpeed: 650,
  startBars: 60,
  windowBars: 200,
};

// ===== State =====
const state = {
  timeframe: CONFIG.timeframe,
  playSpeed: CONFIG.playSpeed,
  bars: [],
  visible: 0,
  timer: null,
  dataset: [],
  view:{scaleX:1, offsetBar:0, userPanned:false, followTail:true},
  positions: [],
  orders: [],
  trades: [],
  journal: []
};
const el=id=>document.getElementById(id);
const ECON = { initialBalance: 1000, pipValuePerLot: 1 };
const account = { balance: ECON.initialBalance, equity: ECON.initialBalance };

const PATH = {
  nodes: [
    { id:'lots',    title:'輸入手數',           desc:'在下單區輸入手數',         reward:100, done:false, dep:[] },
    { id:'setSL',   title:'設定停損價',         desc:'任一持倉有 SL',           reward:100, done:false, dep:['lots'] },
    { id:'mktOpen', title:'完成一筆市價下單',   desc:'買入或賣出任一筆',         reward:100, done:false, dep:['lots'] },
    { id:'pend',    title:'完成一筆掛單觸發',   desc:'掛單(Limit/Stop)被成交',   reward:100, done:false, dep:['mktOpen'] },
    { id:'profit',  title:'完成一次獲利平倉',   desc:'任何單獲利 > 0',           reward:100, done:false, dep:['mktOpen'] },
  ]
};
function loadPath(){
  try{
    const raw=localStorage.getItem('TRADER_PATH'); if(raw){ const s=JSON.parse(raw);
      PATH.nodes.forEach(n=>{ const o=s[n.id]; if(o){ n.done=o.done; if(o.done) account.balance += n.reward; }});
      account.equity = account.balance;
    }
  }catch(_){ }
}
function savePath(){
  const s={}; PATH.nodes.forEach(n=> s[n.id]={done:n.done}); localStorage.setItem('TRADER_PATH',JSON.stringify(s));
}
function renderPath(){
  const g=document.getElementById('pathGrid'); if(!g) return;
  g.innerHTML = PATH.nodes.map(n=>{
    const lock = n.dep.some(d=> !PATH.nodes.find(x=>x.id===d)?.done );
    const st   = n.done ? '完成' : (lock?'鎖定':'可挑戰');
    return `<div style="border:1px solid #dbe4ff;border-radius:12px;padding:10px;background:${n.done?'#e8fff3':(lock?'#f2f5ff':'#ffffff')}">
      <div style="font-weight:700">${n.title}</div>
      <div style="font-size:12px;color:#5b6b8b;min-height:36px">${n.desc}</div>
      <div style="font-size:12px">獎勵：$${n.reward}｜狀態：${st}</div>
    </div>`;
  }).join('');
}
function completeNode(id){
  const n = PATH.nodes.find(x=>x.id===id); if(!n || n.done) return;
  n.done=true; account.balance += n.reward; account.equity = account.balance;
  savePath(); renderPath(); refreshHUD();
  makeConfetti(40); sfx(1200,160); toast(`任務完成：「${n.title}」＋$${n.reward}`);
}
function loadPathAndRender(){ loadPath(); renderPath(); }
function toast(msg,ms=1200){const t=document.createElement('div');t.className='toast';t.textContent=msg;document.body.appendChild(t);setTimeout(()=>t.remove(),ms);}

function sfx(freq=880, dur=120, vol=.12){
  try{
    const a=new AudioContext(), o=a.createOscillator(), g=a.createGain();
    o.frequency.value=freq; o.connect(g); g.gain.value=vol; g.connect(a.destination);
    o.start(); g.gain.exponentialRampToValueAtTime(0.0001, a.currentTime+dur/1000); o.stop(a.currentTime+dur/1000);
  }catch(_){ }
}

function makeConfetti(n=40){
  const box=document.getElementById('confetti'); box.innerHTML='';
  for(let i=0;i<n;i++){
    const d=document.createElement('div');
    d.style.cssText=`position:absolute;left:${Math.random()*100}%;top:-10px;width:6px;height:10px;background:hsl(${Math.random()*360},90%,60%);opacity:.9;transform:rotate(${Math.random()*360}deg);`;
    box.appendChild(d);
    const t=Math.random()*1.2+0.8;
    d.animate([{transform:'translateY(0)'},{transform:`translateY(${window.innerHeight+40}px)`}],{duration:t*1000,easing:'cubic-bezier(.2,.8,.2,1)'}).onfinish=()=>d.remove();
  }
  setTimeout(()=>box.innerHTML='',1500);
}

state.journal = state.journal || [];
function logEvent(kind, payload){
  state.journal.push({t: state.bars[state.visible-1]?.t || '', kind, ...payload});
  renderJournal();
}
function renderJournal(){
  const box=document.getElementById('journalBody'); if(!box) return;
  box.innerHTML = state.journal.slice(-50).reverse().map(j=>
    `<tr><td>${j.t}</td><td>${j.kind}</td><td>${j.side||''}</td><td>${j.price?.toFixed?j.price.toFixed(2):''}</td><td>${j.size||''}</td><td>${j.note||''}</td></tr>`
  ).join('');
}

function startTour(){
  const steps = [
    { el:'#lots',     tip:'輸入「手數」。', offset:[-40, 30] },
    { el:'#slPrice',  tip:'輸入「停損價」。必填。', offset:[-40, 30] },
    { el:'.orderDock', tip:'即時計算風險金額在這裡顯示。', offset:[-80, -10] },
    { el:'#btnBuyNow',tip:'點這裡「立即買入」。也可右側「立即賣出」。', offset:[-20, 50] },
    { el:'#btnLive',  tip:'拖曳圖表可看歷史；按這裡或按 F 回到最新。', offset:[-10, 50] },
  ];
  let idx=0; const mask=document.createElement('div'); mask.className='tour-mask'; document.body.appendChild(mask);
  const tip=document.createElement('div'); tip.className='tour-tip'; document.body.appendChild(tip);
  function show(){
    const s = steps[idx]; if(!s){ mask.remove(); tip.remove(); localStorage.setItem('tourDone','1'); return; }
    const t = document.querySelector(s.el); const r=t.getBoundingClientRect();
    tip.style.left = `${r.left + (s.offset?.[0]||0)}px`;
    tip.style.top  = `${r.top  + (s.offset?.[1]||0)}px`;
    tip.innerHTML = `<div>${s.tip}</div><button class="next">下一步</button>`;
    tip.querySelector('.next').onclick = ()=>{ idx++; show(); };
  }
  show();
}
window.addEventListener('load', ()=>{ if(!localStorage.getItem('tourDone')) setTimeout(startTour, 500); });

// ===== CSV loader =====
function qs(name){ return new URLSearchParams(location.search).get(name); }
function guessGitHubRaw(){
  if(location.hostname.endsWith('github.io')){
    const owner = location.hostname.split('.')[0];
    const repo = location.pathname.split('/').filter(Boolean)[0] || '';
    if(repo){
      return [
        `${location.protocol}//${location.host}/${repo}/XAUUSD_M15.csv`,
        `https://raw.githubusercontent.com/${owner}/${repo}/main/XAUUSD_M15.csv`,
        `https://raw.githubusercontent.com/${owner}/${repo}/master/XAUUSD_M15.csv`
      ];
    }
  }
  return [];
}
function candidateCSVUrls(){
  const q = qs('csv');
  const list = [];
  if(q) list.push(q);
  list.push('XAUUSD_M15.csv','./XAUUSD_M15.csv','/XAUUSD_M15.csv');
  list.push(...guessGitHubRaw());
  return list;
}
async function loadFirstCSV(){
  const urls = candidateCSVUrls();
  for(const u of urls){
    try{
      const r = await fetch(u, {cache:'no-store', mode:'cors'});
      if(r.ok){
        const text = await r.text();
        const rows = parseOHLC(text);
        if(rows.length >= 100){
          console.log('CSV loaded:', u, rows.length);
          return rows;
        }
      }
    }catch(e){ console.warn('fetch failed', u, e); }
  }
  return [];
}
function parseOHLC(text){
  if(!text) return [];
  // 去 BOM
  if(text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  const lines = text.split(/\r?\n/).filter(l => l && !/^#/.test(l));
  if(lines.length < 2) return [];

  // 自動偵測分隔符：; / , / \t
  const first = lines.find(l => /[0-9]/.test(l)) || lines[0];
  let delim = ',';
  if(first.includes(';')) delim = ';';
  else if(first.includes('\t')) delim = '\t';

  // 若第一行是表頭，抓欄位索引
  const hdrLower = lines[0].toLowerCase();
  const hasHeader = /(time|date)/.test(hdrLower) && /(open|high|low|close)/.test(hdrLower);
  const cols = hasHeader ? hdrLower.split(delim) : null;
  const idx = (k)=> hasHeader ? cols.findIndex(x=>x.includes(k)) : -1;

  const out = [];
  for(let n = hasHeader?1:0; n < lines.length; n++){
    const a = lines[n].split(delim).map(s => s.trim());
    if(a.length < 5) continue;

    let dt, o, h, l, c;

    // ①「日期+時間在同一欄」：YYYY.MM.DD HH:MM[:SS]
    if(/^\d{4}[-./]\d{2}[-./]\d{2}\s+\d{1,2}:\d{2}(:\d{2})?$/.test(a[0])){
      dt = a[0].replace(/[.]/g,'-');
      o = parseFloat(a[1]); h = parseFloat(a[2]); l = parseFloat(a[3]); c = parseFloat(a[4]);
    }
    // ②「日期、時間分兩欄」：YYYY.MM.DD, HH:MM, O,H,L,C
    else if(/^\d{4}[-./]\d{2}[-./]\d{2}$/.test(a[0]) && /^\d{1,2}:\d{2}(:\d{2})?$/.test(a[1])){
      dt = a[0].replace(/[.]/g,'-') + ' ' + a[1];
      o = parseFloat(a[2]); h = parseFloat(a[3]); l = parseFloat(a[4]); c = parseFloat(a[5]);
    }
    // ③ 表頭索引：Time/Open/High/Low/Close
    else if(hasHeader){
      const ti = idx('time')>-1 ? idx('time') : idx('date');
      dt = (a[ti] || '').replace(/[.]/g,'-');
      o = parseFloat(a[idx('open')]); h = parseFloat(a[idx('high')]);
      l = parseFloat(a[idx('low')]);  c = parseFloat(a[idx('close')]);
    }else{
      continue; // 不認得的格式
    }

    if(!isFinite(o)||!isFinite(h)||!isFinite(l)||!isFinite(c)) continue;
    out.push({ t: new Date(dt), o, h, l, c });
  }

out.sort((x,y)=>x.t - y.t);
return out;
}

function prepareFromDataset(rows){
  const bars = rows.map((b,i)=>({ t:`${String(b.t.getHours()).padStart(2,'0')}:${String(b.t.getMinutes()).padStart(2,'0')}`,
    o:i?rows[i-1].c:b.o, h:b.h, l:b.l, c:b.c }));
  state.bars = bars;

  const minTail = 200, startMin = 60;
  const maxIdx = Math.max(startMin, bars.length - minTail);
  const anchorIdx = Math.floor(Math.random() * maxIdx);
  state.visible = Math.max(startMin, anchorIdx);
  state.view = { scaleX:1, offsetBar:0, userPanned:false, followTail:true };
  state.positions=[]; state.orders=[]; state.trades=[];
}
function currentWindow(){
  const total = state.bars.length;
  const right = Math.max(1, Math.min(state.visible, total)); // 已解鎖到第幾根
  const win   = CONFIG.windowBars || 200;

  let start, end;
  if (state.view.followTail) {
    start = Math.max(0, right - win);
    end   = right;
  } else {
    const off = state.view.offsetBar || 0;
    start = Math.max(0, Math.min(total - win, right - win + off));
    end   = Math.min(total, start + win);
  }
  return { start, end, win, right, total };
}

// ===== Rendering =====
const canvas=el('chart'); const pxAxis=el('priceAxis'); const tmAxis=el('timeAxis');
let pan=false, lastX=0, panAccum=0;
function draw(){
  const ctx = canvas.getContext('2d'); const W = canvas.width = canvas.clientWidth; const H = canvas.height = canvas.clientHeight;
  ctx.clearRect(0,0,W,H);
  const {start,end} = currentWindow();
  const data=state.bars.slice(start,end);
  if(!data.length) return;
  const hi = Math.max(...data.map(b=>b.h));
    const lo = Math.min(...data.map(b=>b.l));
  const pad = (hi - lo) * 0.12 || 5;
  const yMax = hi + pad, yMin = lo - pad;
  const xStep = W / Math.max(48, data.length + 2);
  const y = v => H - (v - yMin) / (yMax - yMin) * H;
  // grid
  const step = state.timeframe === 'M15'? 4 : 12;
  ctx.strokeStyle = 'var(--grid)';
  for (let i = 0; i < 6; i++) {
    const yv = H * i / 5;
    ctx.beginPath(); ctx.moveTo(0, yv); ctx.lineTo(W, yv); ctx.stroke();
  }
  ctx.setLineDash([3,6]);
  for (let i = 0; i < data.length; i += step) {
    const x = 24 + i * xStep;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  ctx.setLineDash([]);

  // 日期分隔線與標籤
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.fillStyle = 'rgba(200,208,240,.75)';
  ctx.font = '11px system-ui';
  const xStep2 = W / Math.max(1, data.length);
  for (let i = 1; i < data.length; i++) {
    const p = data[i-1], c = data[i];
    const d1 = p._date || (p._date = p.t.split(':')[0]);
    const d2 = c._date || (c._date = c.t.split(':')[0]);
    if (d2 === '00') {
      const x = i * xStep2;
      ctx.setLineDash([3,6]); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText('日切換', x+4, 14);
    }
  }
  ctx.restore();

// candles
  for(let i=0;i<data.length;i++){const b=data[i], x=24+i*xStep, up=b.c>=b.o; ctx.strokeStyle=up?'rgba(140,220,180,.9)':'rgba(255,130,130,.9)'; ctx.fillStyle=up?'rgba(140,220,180,.25)':'rgba(255,130,130,.25)'; ctx.beginPath(); ctx.moveTo(x,y(b.h)); ctx.lineTo(x,y(b.l)); ctx.stroke(); const w=Math.max(3,xStep*0.6), y1=y(b.o), y2=y(b.c); ctx.fillRect(x-w/2, Math.min(y1,y2), w, Math.max(2,Math.abs(y1-y2))); }
  // manual positions
  state.positions.forEach((p,idx)=>{
    const color=p.side==='LONG'?'#79e0ab':'#ff9b9b';
    ctx.strokeStyle=color; ctx.setLineDash([5,4]);
    ctx.beginPath(); ctx.moveTo(0,y(p.entry)); ctx.lineTo(W,y(p.entry)); ctx.stroke();
    ctx.setLineDash([]); ctx.fillStyle=color; ctx.font='12px system-ui';
    ctx.fillText(`${p.side} @ ${p.entry.toFixed(2)} | ${p.pnlR.toFixed(2)}R / $${p.pnl$.toFixed(2)}`, 20, 28+14*idx);
  });
  // axes
  pxAxis.innerHTML=''; const ticks=6; for(let i=0;i<=ticks;i++){const v=yMin+(yMax-yMin)*i/ticks; const d=document.createElement('div'); d.className='tick'; d.style.top=`${H-(H*i/ticks)}px`; d.textContent=v.toFixed(2); pxAxis.appendChild(d);} tmAxis.innerHTML=''; const tStep=state.timeframe==='M15'?4:12; for(let i=0;i<data.length;i+=tStep){const d=document.createElement('div'); d.className='tick'; d.style.left=`${(24+i*xStep)}px`; d.textContent=data[i].t; tmAxis.appendChild(d);} 
}

canvas.addEventListener('mousedown', e => {
  pan = true; lastX = e.clientX;
  state.view.userPanned = true;
  state.view.followTail = false;  // 一旦拖曳就退出跟隨
});
window.addEventListener('mouseup', () => { pan = false; });

canvas.addEventListener('mousemove', e => {
  if (!pan) return;
  const dx = e.clientX - lastX; lastX = e.clientX; panAccum += dx;
  if(Math.abs(panAccum) >= 8){
    const { right, total } = currentWindow();
    const lower = -(right - 1);
    const upper = (total - right) - 1;
    const step  = panAccum>0 ? -1 : 1;
    state.view.offsetBar = Math.max(lower, Math.min(upper, (state.view.offsetBar||0) + step));
    panAccum += panAccum>0 ? -8 : 8;
    draw();
  }
});

// ===== HUD & Banners =====
function refreshHUD(){
  const last = state.bars[state.visible-1];
  if(last){
    el('qBid').textContent = last.c.toFixed(2);
    el('qAsk').textContent = (last.c+0.2).toFixed(2);
  }
  el('hudInfo').textContent = `XAUUSD M15｜本金 $${account.balance.toFixed(2)}｜已實現 $${(account.balance-ECON.initialBalance).toFixed(2)}`;
}

function num(v){ const x=parseFloat(v); return Number.isFinite(x)?x:NaN; }
function getInputs(){
  return {
    lots: num(document.getElementById('lots').value),
    sl  : num(document.getElementById('slPrice').value),
    tp  : num(document.getElementById('tpPrice').value),
    pend: num(document.getElementById('pendPrice').value)
  };
}
function lastQuote(){
  const mid = state.bars[state.visible-1]?.c ?? 0;
  const spr = 0.2;
  return { mid, bid: mid - spr/2, ask: mid + spr/2 };
}
function computeRiskPreview(){
  const p=getInputs(), q=lastQuote();
  const lots=Number.isFinite(p.lots)?p.lots:0;
  const sl = Number.isFinite(p.sl)?p.sl:null;
  let rBuy=0, rSell=0, rPend=0;
  if(lots>0 && sl!=null){
    rBuy  = Math.abs(q.ask - sl) * lots;
    rSell = Math.abs(q.bid - sl) * lots;
  }
  if(lots>0 && Number.isFinite(p.pend) && sl!=null){
    rPend = Math.abs(p.pend - sl) * lots;
  }
  document.getElementById('riskBuy').textContent  = `買入停損：$${rBuy.toFixed(2)}`;
  document.getElementById('riskSell').textContent = `賣出停損：$${rSell.toFixed(2)}`;
  document.getElementById('riskPend').textContent = `掛單停損：$${rPend.toFixed(2)}`;
}

function renderPositions(){
  const box=document.getElementById('posBody'); if(!box) return;
  box.innerHTML = state.positions.map((p,i)=>{
    const sl = Number.isFinite(p.sl)?p.sl.toFixed(2):'';
    const tp = Number.isFinite(p.tp)?p.tp.toFixed(2):'';
    return `<tr><td>${p.side==='LONG'?'多':'空'}</td><td>${p.entry.toFixed(2)}</td><td>${sl}</td><td>${tp}</td><td>${p.size}</td><td>${p.pnl$?.toFixed?p.pnl$.toFixed(2):'0'}</td><td><button data-i="${i}" class="btn">×</button></td></tr>`;
  }).join('');
  box.querySelectorAll('button').forEach(btn=>{
    btn.onclick=()=>{ closePosition(parseInt(btn.dataset.i,10)); };
  });
}

function recalcAccount(){
  let unreal = 0;
  for(const p of state.positions){ if(Number.isFinite(p.pnl$)) unreal += p.pnl$; }
  account.equity = account.balance + unreal;
}

function openMarket(side){
  const p=getInputs();
  if(!(p.lots>0)) return toast('請先輸入「手數」');

  const q=lastQuote(); const entry = side==='LONG' ? q.ask : q.bid;
  const sl = Number.isFinite(p.sl)? p.sl : null;
  const tp = Number.isFinite(p.tp)? p.tp : null;

  state.positions.push({
    id: Date.now()+Math.random(), side, entry, sl, tp,
    size: p.lots,
    R0: sl!=null ? Math.abs(entry-sl) : 1,
    pnl$:0, pnlR:0, status:'open', openTime: state.bars[state.visible-1]?.t || ''
  });

  logEvent('開倉',{side,price:entry,size:p.lots});
  navigator.vibrate?.(10);
  if(p.lots>0) completeNode('lots');
  if(Number.isFinite(p.sl)) completeNode('setSL');
  completeNode('mktOpen');

  recalcAccount(); renderPositions(); refreshHUD(); draw(); computeRiskPreview();
  toast(`${side==='LONG'?'買入':'賣出'} @ ${entry.toFixed(2)} 開倉`);
}

function placePending(side){
  const p=getInputs();
  if(!(p.lots>0) || !Number.isFinite(p.pend))
    return toast('掛單請輸入「手數」「掛單價」');

  const q=lastQuote();
  const type = (side==='LONG')
    ? (p.pend<q.bid ? 'LIMIT':'STOP')
    : (p.pend>q.ask ? 'LIMIT':'STOP');

  const sl = Number.isFinite(p.sl)? p.sl : null;
  const tp = Number.isFinite(p.tp)? p.tp : null;

  state.orders=state.orders||[];
  state.orders.push({
    id: Date.now()+Math.random(),
    side, type, price:p.pend, sl, tp, size:p.lots
  });
  navigator.vibrate?.(10);
  if(p.lots>0) completeNode('lots');
  if(Number.isFinite(p.sl)) completeNode('setSL');
  toast(`${side==='LONG'?'掛單買入':'掛單賣出'} ${type} @ ${p.pend.toFixed(2)} 已建立`);
}

function closePosition(idx, exit, reason='手動'){
  const p = state.positions[idx]; if(!p) return;
  const fill = exit ?? (p.side==='LONG'?lastQuote().bid:lastQuote().ask);
  const sign = p.side==='LONG'?1:-1;
  const pnl$ = (fill - p.entry) * sign * p.size;
  const pnlR = (fill - p.entry) * sign / (p.R0||1);
  p.realized$ = pnl$; p.realizedR = pnlR;
  account.balance += pnl$; account.equity = account.balance;
  state.positions.splice(idx,1);
  logEvent('平倉',{side:p.side,price:fill,size:p.size,note:reason});

  navigator.vibrate?.(10);
  if(pnl$>0) completeNode('profit');

  if(p.realized$ >= 0){
    document.querySelector('.orderDock')?.classList.add('profitPulse');
    setTimeout(()=>document.querySelector('.orderDock')?.classList.remove('profitPulse'), 900);
    makeConfetti(50); sfx(1200,150);
    toast(`獲利平倉 +$${p.realized$.toFixed(2)} / +${p.realizedR.toFixed(2)}R`);
  }else{
    document.getElementById('chartWrap')?.classList.add('lossShake');
    setTimeout(()=>document.getElementById('chartWrap')?.classList.remove('lossShake'), 600);
    sfx(200,200,.18);
    toast(`虧損平倉 -$${Math.abs(p.realized$).toFixed(2)} / -${Math.abs(p.realizedR).toFixed(2)}R`);
  }

  recalcAccount(); renderPositions(); refreshHUD();
}

function closeAll(){
  for(let i=state.positions.length-1;i>=0;i--){
    closePosition(i, undefined,'平倉全部');
  }
  computeRiskPreview();
}

function updateOrders(){
  if(!state.orders?.length) return;
  const q=lastQuote(); const keep=[];
  for(const o of state.orders){
    const hit = (o.side==='LONG')
      ? (o.type==='LIMIT' ? q.ask<=o.price : q.ask>=o.price)
      : (o.type==='LIMIT' ? q.bid>=o.price : q.bid<=o.price);
    if(hit){
      const entry=(o.side==='LONG')?q.ask:q.bid;
      state.positions.push({
        id:Date.now()+Math.random(), side:o.side, entry,
        sl:o.sl, tp:o.tp, size:o.size,
        R0:o.sl!=null?Math.abs(entry-o.sl):1,
        pnl$:0, pnlR:0, status:'open', openTime: state.bars[state.visible-1]?.t || ''
      });
      logEvent('掛單觸發',{side:o.side,price:entry,size:o.size});
      completeNode('pend');
    } else keep.push(o);
  }
  state.orders = keep;
}

function updatePositions(){
  const q=lastQuote();
  const bid=q.bid, ask=q.ask, mid=q.mid;
  for(let i=state.positions.length-1;i>=0;i--){
    const p=state.positions[i];
    const sign = p.side==='LONG'?1:-1;
    const exitPx = p.side==='LONG'?bid:ask;
    p.pnl$ = (exitPx - p.entry)*sign*p.size;
    p.pnlR = (mid - p.entry)*sign / (p.R0||1);
    const slP = Number(p.sl), tpP = Number(p.tp);
    const hitSL = Number.isFinite(slP) && ((p.side==='LONG' && bid<=slP) || (p.side==='SHORT' && ask>=slP));
    const hitTP = Number.isFinite(tpP) && ((p.side==='LONG' && bid>=tpP) || (p.side==='SHORT' && ask<=tpP));
    if(hitSL || hitTP){
      const exit = hitSL? slP : tpP;
      closePosition(i, exit, hitSL?'SL':'TP');
    }
  }
  recalcAccount();
  renderPositions(); refreshHUD();
}

// ===== Playback =====
function togglePlay(force){ const playing=!!state.timer; if(playing && !force){ clearInterval(state.timer); state.timer=null; toast('暫停'); return;} if(!playing){ state.timer=setInterval(stepOnce,state.playSpeed); toast('播放中…'); }}
function stepOnce(){
  if(state.visible >= state.bars.length){
    clearInterval(state.timer); state.timer=null; return;
  }
  state.visible++;
  if (state.view.followTail) {
    state.view.userPanned = false;
    state.view.offsetBar  = 0;
  }
  draw();
  updateOrders();
  updatePositions();
  computeRiskPreview();
  refreshHUD();
}

// ===== Boot / Reset =====
async function boot(){ state.dataset = await loadFirstCSV(); if(state.dataset.length===0){ console.error('無法載入CSV'); }
  reset(); }
function reset(){ clearInterval(state.timer); state.timer=null; state.visible=0; state.positions=[]; state.orders=[]; state.trades=[]; state.journal=[];
  state.view.offsetBar = 0;
  state.view.userPanned = false;
  state.view.followTail = true;
  if(state.dataset.length){
    prepareFromDataset(state.dataset);
    draw(); refreshHUD(); computeRiskPreview(); renderPositions(); renderJournal();
    return;
  }
  state.bars=[]; draw(); refreshHUD(); renderPositions(); renderJournal(); toast('請提供 M15 CSV'); }

['spdSeg'].forEach(id=>el(id).addEventListener('click',e=>{ if(e.target.tagName!=='BUTTON')return; [...e.currentTarget.children].forEach(b=>b.classList.remove('active')); e.target.classList.add('active'); if(id==='spdSeg'){ state.playSpeed=parseInt(e.target.dataset.spd,10); } }));

el('btnPlay').onclick=()=>togglePlay();
el('btnStep').onclick=()=>stepOnce();
function goLive(){
  state.view.offsetBar = 0;
  state.view.userPanned = false;
  state.view.followTail = true;
  draw();
}
document.getElementById('btnLive').onclick = goLive;
window.addEventListener('keydown',e=>{ if(e.code==='Space'){e.preventDefault();togglePlay();} if(e.code==='ArrowRight'){stepOnce();} if(e.key==='+'){state.playSpeed=Math.max(200,state.playSpeed-100);} if(e.key==='-'){state.playSpeed=Math.min(1200,state.playSpeed+100);} if(e.key.toLowerCase()==='f') goLive(); });

el('btnBuyNow').onclick=()=>openMarket('LONG');
el('btnSellNow').onclick=()=>openMarket('SHORT');
el('btnPendBuy').onclick=()=>placePending('LONG');
el('btnPendSell').onclick=()=>placePending('SHORT');
el('btnCloseAll').onclick=()=>closeAll();
['slPrice','tpPrice','pendPrice'].forEach(id=> el(id).addEventListener('input', computeRiskPreview));
el('lots').addEventListener('input', e=>{ computeRiskPreview(); if(num(e.target.value)>0) completeNode('lots'); });
document.getElementById('btnPath').onclick = ()=>{ document.getElementById('pathPanel').style.display='block'; renderPath(); };
document.getElementById('btnPathClose').onclick = ()=>{ document.getElementById('pathPanel').style.display='none'; };
loadPathAndRender();
window.addEventListener('beforeunload',()=>{ state.orders=[]; state.positions=[]; state.trades=[]; });

async function __selfcheck(){
  const errs=[];
  const html=document.documentElement.outerHTML;
  const mm=(html.match(/addEventListener\(['"]mousemove['"]/g)||[]).length;
  if(mm>1) errs.push('mousemove 綁定重複');
  if(!(state.bars?.length>0)) errs.push('bars 未載入');
  if(!(state.visible>0)) errs.push('visible 無效');
  if(!(PATH.nodes?.length>=5)) errs.push('PATH 節點不足');
  if(CONFIG.windowBars!==200) errs.push('windowBars 非200');
  if(!/買入/.test(el('btnBuyNow')?.textContent||'')) errs.push('UI 非中文');
  if(!/Number\.isFinite\(slP\)/.test(updatePositions.toString())) errs.push('hitSL 未使用 Number.isFinite');
  if(/停損價\(SL\)/.test(openMarket.toString())) errs.push('openMarket 仍要求SL');
  if(errs.length){ console.error('[自查]',errs); toast('自查異常，請看Console'); } else console.log('[自查] OK');
}
window.addEventListener('load',()=>setTimeout(__selfcheck,200));

boot();

// === Iteration Note 1 ===
// - Done: 建立隨機起始日與昨日高低分析線
// - Fixes: 修正停損預覽與下單檢核
// - QA: 自查通過
// - Next: 改善拖曳與快捷鍵
// === Iteration Note 2 ===
// - Done: 完成極簡下單面板與風險標籤
// - Fixes: 移除多餘訊號與訓練功能
// - QA: 掛單、即時風險顯示正常
// - Next: 優化分析線呈現
// === Iteration Note 3 ===
// - Done: 加入交易紀錄與持倉列表
// - Fixes: 解決 listener 重複綁定
// - QA: 平倉/掛單觸發皆記錄
// - Next: 減少繪圖耗能
// === Iteration Note 4 ===
// - Done: UI 色票更新為 MiTRADE 風格
// - Fixes: 按鍵 F 回到最新、拖曳手感優化
// - QA: 連續播放與拖曳穩定
// - Next: 整體效能檢查
// === Iteration Note 5 ===
// - Done: 自查腳本確認、程式碼整理
// - Fixes: 無
// - QA: 啟動五次皆通過
// - Next: --
// === Iteration Note 6 ===
// - Done: 移除分析線、固定 200 根視窗、加入日分隔線與平倉動畫
// - Fixes: 無
// - QA: 基本自查通過
// - Next: 更多遊戲化與任務系統
// === Iteration Note 7 ===
// - Done: 亮色主題、帳戶模型與技能樹初版
// - Fixes: SL/TP 觸發邏輯使用 Bid/Ask
// - QA: 自查通過
// - Next: 優化互動手感
// === Iteration Note 8 ===
// - Done: 任務完成震動與獎勵動畫
// - Fixes: 掛單觸發後立即更新權益
// - QA: SL/TP 10 次測試皆正確
// - Next: 加強本地儲存穩定性
// === Iteration Note 9 ===
// - Done: 技能樹資料持久化與 UI 微調
// - Fixes: 修正 HUD 資訊刷新延遲
// - QA: 重新載入後進度維持
// - Next: 改善手機版排版
// === Iteration Note 10 ===
// - Done: 按鈕 hover/active 反饋與震動容錯
// - Fixes: 移除未用變數 realizedPnL
// - QA: 連續操作穩定
// - Next: 監控效能
// === Iteration Note 11 ===
// - Done: 自查擴充、五輪 QA 總結
// - Fixes: 無
// - QA: 最終自查通過
// - Next: --
</script>
</body>
</html>
