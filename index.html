<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交易獲利挑戰賽</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-main: #131722;
            --bg-panel: #1e222d;
            --text-primary: #d1d4dc;
            --text-secondary: #787b86;
            --border-color: #2a2e39;
            --green: #26a69a;
            --red: #ef5350;
            --blue: #2962ff;
            --yellow: #ffeb3b;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        body {
            background-color: var(--bg-main);
            color: var(--text-primary);
            font-family: var(--font-family);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* 防止移動端瀏覽器默認的觸控行為 */
        }
        .hud-item {
            background-color: var(--bg-panel);
            border: 1px solid var(--border-color);
        }
        .tab-button {
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            color: var(--yellow);
            border-bottom-color: var(--yellow);
        }
        .btn {
            transition: all 0.2s ease;
            transform: translateZ(0); /* 啟用 GPU 加速 */
        }
        .btn:active {
            transform: scale(0.95) translateZ(0);
        }
        .btn-buy { background-color: var(--green); }
        .btn-buy:hover { background-color: #2bb7a9; }
        .btn-sell { background-color: var(--red); }
        .btn-sell:hover { background-color: #fa6a67; }
        .btn-close { background-color: var(--blue); }
        .btn-close:hover { background-color: #4275ff; }
        .input-number {
            background-color: var(--border-color);
            border: 1px solid var(--text-secondary);
        }
        .input-number::-webkit-inner-spin-button,
        .input-number::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .stepper-btn {
            background-color: var(--text-secondary);
            color: var(--bg-main);
        }
        .progress-bar-inner {
            background: linear-gradient(90deg, var(--blue) 0%, var(--yellow) 100%);
        }
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }
        .tutorial-highlight {
            position: absolute;
            border: 3px solid var(--yellow);
            border-radius: 8px;
            box-shadow: 0 0 20px var(--yellow);
            transition: all 0.3s ease-in-out;
            pointer-events: none;
        }
        .tutorial-tooltip {
            position: absolute;
            background-color: var(--bg-panel);
            border: 1px solid var(--yellow);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease-in-out;
            opacity: 0;
            transform: translateY(10px);
        }
        .tutorial-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .glowing-border {
            animation: glowing 1.5s infinite;
        }
        @keyframes glowing {
            0% { box-shadow: 0 0 5px var(--yellow); }
            50% { box-shadow: 0 0 20px var(--yellow); }
            100% { box-shadow: 0 0 5px var(--yellow); }
        }
    </style>
</head>
<body>

<div id="app-container" class="w-full max-w-md h-full sm:h-[90vh] sm:max-h-[800px] bg-black sm:rounded-2xl shadow-2xl flex flex-col overflow-hidden">
    
    <!-- 1. 頂部 HUD -->
    <div id="hud" class="p-2 grid grid-cols-3 gap-2 text-xs text-center">
        <div class="hud-item p-1 rounded-md">
            <div class="text-text-secondary">日期</div>
            <div id="hud-date" class="font-bold text-sm">-</div>
        </div>
        <div class="hud-item p-1 rounded-md">
            <div class="text-text-secondary">帳戶淨值</div>
            <div id="hud-equity" class="font-bold text-sm">10000.00</div>
        </div>
        <div class="hud-item p-1 rounded-md">
            <div class="text-text-secondary">總浮動損益</div>
            <div id="hud-pl" class="font-bold text-sm">0.00</div>
        </div>
        <div class="col-span-3 mt-1">
            <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div id="progress-bar" class="progress-bar-inner h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- 2. 圖表區域 -->
    <div class="flex-grow relative bg-black">
        <canvas id="chart-canvas" class="w-full h-full"></canvas>
    </div>

    <!-- 3. 底部面板 -->
    <div id="bottom-panel" class="bg-bg-panel flex flex-col">
        <!-- 播放控制 -->
        <div id="playback-controls" class="p-2 flex items-center justify-between border-b border-border-color">
            <button id="play-pause-btn" class="p-2 rounded-md hover:bg-border-color">
                <!-- Play/Pause icon will be injected by JS -->
            </button>
            <button id="step-forward-btn" class="p-2 rounded-md hover:bg-border-color">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M15.5 3.5a.5.5 0 0 0-1 0V7.248l-6.267-3.636C7.692 3.29 7 3.67 7 4.304v7.384c0 .63.692 1.01 1.233.697L14.5 8.752V12a.5.5 0 0 0 1 0V4a.5.5 0 0 0-.5-.5z"/></svg>
            </button>
            <div class="flex items-center space-x-2 text-sm">
                <label for="speed-control">速度:</label>
                <select id="speed-control" class="bg-border-color rounded-md p-1">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                </select>
            </div>
        </div>

        <!-- 頁籤 -->
        <div class="flex">
            <button data-tab="trade" class="tab-button flex-1 py-2 text-center font-bold active">交易</button>
            <button data-tab="positions" class="tab-button flex-1 py-2 text-center font-bold">持倉 (<span id="positions-count">0</span>)</button>
            <button data-tab="journal" class="tab-button flex-1 py-2 text-center font-bold">紀錄</button>
        </div>

        <!-- 頁籤內容 -->
        <div class="p-2">
            <!-- A. 交易面板 -->
            <div id="tab-content-trade" class="tab-content">
                <div class="grid grid-cols-3 gap-2 text-sm mb-2">
                    <div>
                        <label class="text-text-secondary">手數</label>
                        <div class="flex items-center mt-1">
                            <button data-input="lots" data-step="-0.01" class="stepper-btn p-1 rounded-l-md">-</button>
                            <input id="input-lots" type="number" value="0.1" step="0.01" min="0.01" class="input-number w-full text-center p-1">
                            <button data-input="lots" data-step="0.01" class="stepper-btn p-1 rounded-r-md">+</button>
                        </div>
                    </div>
                    <div>
                        <label class="text-text-secondary">停損 (SL)</label>
                        <div class="flex items-center mt-1">
                            <button data-input="sl" data-step="-1" class="stepper-btn p-1 rounded-l-md">-</button>
                            <input id="input-sl" type="number" placeholder="價格" class="input-number w-full text-center p-1">
                            <button data-input="sl" data-step="1" class="stepper-btn p-1 rounded-r-md">+</button>
                        </div>
                    </div>
                    <div>
                        <label class="text-text-secondary">停利 (TP)</label>
                        <div class="flex items-center mt-1">
                            <button data-input="tp" data-step="-1" class="stepper-btn p-1 rounded-l-md">-</button>
                            <input id="input-tp" type="number" placeholder="價格" class="input-number w-full text-center p-1">
                            <button data-input="tp" data-step="1" class="stepper-btn p-1 rounded-r-md">+</button>
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button id="btn-sell" class="btn btn-sell w-full p-3 rounded-md font-bold">賣出</button>
                    <button id="btn-buy" class="btn btn-buy w-full p-3 rounded-md font-bold">買入</button>
                </div>
            </div>
            <!-- B. 持倉面板 -->
            <div id="tab-content-positions" class="tab-content hidden h-32 overflow-y-auto">
                <!-- Position items will be injected here -->
                <div id="positions-list"></div>
                 <button id="btn-close-all" class="btn btn-close w-full p-2 mt-2 rounded-md font-bold text-sm hidden">一鍵平倉</button>
            </div>
            <!-- C. 紀錄面板 -->
            <div id="tab-content-journal" class="tab-content hidden h-32 overflow-y-auto">
                <!-- Journal items will be injected here -->
            </div>
        </div>
    </div>
</div>


<!-- 彈出式視窗 (通用) -->
<div id="modal-container" class="modal-overlay fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
    <div class="bg-bg-panel rounded-lg shadow-xl w-full max-w-sm text-center p-6">
        <h3 id="modal-title" class="text-xl font-bold mb-2"></h3>
        <p id="modal-body" class="text-text-secondary mb-6"></p>
        <div id="modal-actions" class="flex justify-center gap-4">
            <!-- Modal buttons will be injected here -->
        </div>
    </div>
</div>

<!-- 新手導引 -->
<div id="tutorial-container" class="fixed inset-0 z-40 hidden">
    <div class="tutorial-highlight"></div>
    <div class="tutorial-tooltip p-4 rounded-lg max-w-xs w-full">
        <p id="tutorial-text" class="mb-4"></p>
        <div class="flex justify-between items-center">
            <span id="tutorial-step" class="text-sm text-text-secondary"></span>
            <button id="tutorial-next-btn" class="btn bg-yellow-500 text-black px-4 py-2 rounded-md font-bold">下一步</button>
        </div>
    </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM 元素獲取 ---
    const canvas = document.getElementById('chart-canvas');
    const ctx = canvas.getContext('2d');
    const appContainer = document.getElementById('app-container');

    // HUD
    const hudDate = document.getElementById('hud-date');
    const hudEquity = document.getElementById('hud-equity');
    const hudPl = document.getElementById('hud-pl');
    const progressBar = document.getElementById('progress-bar');
    
    // Playback
    const playPauseBtn = document.getElementById('play-pause-btn');
    const stepForwardBtn = document.getElementById('step-forward-btn');
    const speedControl = document.getElementById('speed-control');

    // Tabs
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    const positionsCount = document.getElementById('positions-count');

    // Trade Panel
    const inputLots = document.getElementById('input-lots');
    const inputSl = document.getElementById('input-sl');
    const inputTp = document.getElementById('input-tp');
    const btnBuy = document.getElementById('btn-buy');
    const btnSell = document.getElementById('btn-sell');
    const stepperBtns = document.querySelectorAll('.stepper-btn');

    // Positions Panel
    const positionsList = document.getElementById('positions-list');
    const btnCloseAll = document.getElementById('btn-close-all');

    // Journal Panel
    const journalList = document.getElementById('tab-content-journal');

    // Modals & Tutorial
    const modalContainer = document.getElementById('modal-container');
    const modalTitle = document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');
    const modalActions = document.getElementById('modal-actions');
    const tutorialContainer = document.getElementById('tutorial-container');
    const tutorialHighlight = tutorialContainer.querySelector('.tutorial-highlight');
    const tutorialTooltip = tutorialContainer.querySelector('.tutorial-tooltip');
    const tutorialText = document.getElementById('tutorial-text');
    const tutorialStep = document.getElementById('tutorial-step');
    const tutorialNextBtn = document.getElementById('tutorial-next-btn');

    const ICONS = {
        PLAY: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>`,
        PAUSE: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>`
    };
    
    // --- 全域狀態管理 (State Object) ---
    let state = {};

    function initState() {
        state = {
            fullDataset: [], // 完整數據集
            gameData: [], // 本局遊戲使用的數據
            currentBarIndex: 0, // 當前 K 棒索引
            
            account: {
                balance: 10000,
                equity: 10000,
            },
            
            positions: [], // 當前持倉
            journal: [], // 歷史紀錄
            
            gameLoopInterval: null,
            isPaused: true,
            gameSpeed: 1000, // ms per bar
            
            view: { // 圖表視圖狀態
                firstBarIndex: 0,
                barsOnScreen: 100,
                priceMin: 0,
                priceMax: 0,
                isDragging: false,
                lastMouseX: 0,
                lastMouseY: 0,
                zoom: 1,
            },

            animation: { // K棒動畫
                isAnimating: false,
                targetClose: 0,
                currentY: 0,
                startTime: 0,
                duration: 500, // ms
            },
            
            needsRedraw: true, // 是否需要重繪
        };
    }

    // --- 財經事件系統 ---
    const financialEvents = [
        { day: 3, title: "美國非農就業數據公布", body: "數據遠超預期，市場波動性可能急劇增加，請謹慎操作。" },
        { day: 10, title: "聯準會利率決議", body: "主席鮑威爾發表鷹派講話，暗示未來可能升息，美元走強。" },
        { day: 18, title: "歐洲央行會議", body: "維持利率不變，但對經濟前景表示擔憂，歐元承壓。" },
    ];

    // --- 核心邏輯分離 ---

    /**
     * 1. 初始化函式 (程式進入點)
     */
    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        initState();
        bindPermanentEventListeners();
        
        playPauseBtn.innerHTML = ICONS.PLAY;

        showModal(
            "歡迎來到交易挑戰賽",
            "您的目標是在一個月的模擬交易中，盡可能地提高您的帳戶淨值。準備好開始了嗎？",
            [{ text: "開始挑戰", className: "btn-buy", callback: () => {
                hideModal();
                loadData();
            }}]
        );
    }

    /**
     * 2. 數據處理模組
     */
    async function loadData() {
        showModal("載入中...", "正在從伺服器獲取市場數據，請稍候...", []);
        try {
            const dataUrl = 'https://raw.githubusercontent.com/bless25min/SoyaPlayableAd/refs/heads/main/XAUUSD_M15.csv';
            const response = await fetch(dataUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            parseData(text);
            hideModal();
            
            const hasSeenTutorial = localStorage.getItem('trading_challenge_tutorial_seen');
            if (!hasSeenTutorial) {
                startTutorial();
            } else {
                startGame();
            }

        } catch (error) {
            console.error('Data loading failed:', error);
            showModal("錯誤", "數據載入失敗，請檢查您的網路連線或檔案路徑是否正確。", [{text: "重試", className: "btn-buy", callback: loadData}]);
        }
    }

    function parseData(text) {
        const lines = text.trim().split('\n');
        const data = [];
        for (let i = 1; i < lines.length; i++) { // Skip header
            try {
                let parts;
                if (lines[i].includes(',')) {
                    parts = lines[i].split(',');
                    if (parts.length < 5) continue;
                    const o = parseFloat(parts[1]);
                    if (isNaN(o)) continue;
                    data.push({
                        time: parseInt(parts[0], 10) * 1000,
                        o: o,
                        h: parseFloat(parts[2]),
                        l: parseFloat(parts[3]),
                        c: parseFloat(parts[4]),
                    });
                } else {
                    parts = lines[i].trim().split(/\s+/);
                    if (parts.length < 6) continue;
                    const o = parseFloat(parts[2]);
                    if (isNaN(o)) continue;
                    
                    // [FIXED] 更強健的日期解析邏輯
                    const dateParts = parts[0].split('.');
                    const timeParts = parts[1].split(':');
                    if (dateParts.length < 3 || timeParts.length < 3) continue;
                    
                    const year = parseInt(dateParts[0], 10);
                    const month = parseInt(dateParts[1], 10) - 1; // JavaScript 的月份是 0-11
                    const day = parseInt(dateParts[2], 10);
                    const hour = parseInt(timeParts[0], 10);
                    const minute = parseInt(timeParts[1], 10);
                    const second = parseInt(timeParts[2], 10);

                    const time = new Date(year, month, day, hour, minute, second).getTime();
                    if (isNaN(time)) continue; // 如果日期無效，跳過此行

                    data.push({
                        time: time,
                        o: o,
                        h: parseFloat(parts[3]),
                        l: parseFloat(parts[4]),
                        c: parseFloat(parts[5]),
                    });
                }
            } catch (e) {
                console.warn(`Skipping invalid line ${i}: ${lines[i]}`);
            }
        }
        state.fullDataset = data.filter(d => !isNaN(d.time) && !isNaN(d.o));
        console.log(`成功解析 ${state.fullDataset.length} 筆數據`);
    }

    /**
     * 3. 遊戲流程模組
     */
    function startGame() {
        initState();
        
        const dataPointsPerMonth = 30 * 24 * 4;
        if (state.fullDataset.length <= dataPointsPerMonth) {
            state.gameData = state.fullDataset;
        } else {
            const startIndex = Math.floor(Math.random() * (state.fullDataset.length - dataPointsPerMonth));
            state.gameData = state.fullDataset.slice(startIndex, startIndex + dataPointsPerMonth);
        }

        if (state.gameData.length === 0) {
            showModal("錯誤", "沒有有效的市場數據可供模擬。", []);
            return;
        }

        const historyRatio = 0.25;
        const potentialStartPoint = Math.floor(state.gameData.length * historyRatio);
        const minRequiredHistory = 50;

        state.currentBarIndex = Math.max(minRequiredHistory, potentialStartPoint);
        
        if (state.currentBarIndex >= state.gameData.length) {
            state.currentBarIndex = Math.max(0, state.gameData.length - 20);
        }

        state.view.firstBarIndex = Math.max(0, state.currentBarIndex - state.view.barsOnScreen);
        
        updateAllUI();
        requestRedraw();
    }

    function gameLoop() {
        if (state.isPaused) return;

        if (state.currentBarIndex < state.gameData.length - 1) {
            state.currentBarIndex++;
            updatePositionsPL();
            checkSLTP();
            checkFinancialEvent();
            updateAllUI();
            startCandleAnimation();
        } else {
            endGame();
        }
    }

    function togglePlayPause() {
        state.isPaused = !state.isPaused;
        if (state.isPaused) {
            clearInterval(state.gameLoopInterval);
            playPauseBtn.innerHTML = ICONS.PLAY;
        } else {
            state.gameLoopInterval = setInterval(gameLoop, state.gameSpeed);
            playPauseBtn.innerHTML = ICONS.PAUSE;
            gameLoop();
        }
    }
    
    function stepForward() {
        if (!state.isPaused) togglePlayPause();
        if (state.currentBarIndex < state.gameData.length - 1) {
            state.currentBarIndex++;
            updatePositionsPL();
            checkSLTP();
            checkFinancialEvent();
            updateAllUI();
            startCandleAnimation();
        } else {
            endGame();
        }
    }

    function changeSpeed(speedMultiplier) {
        state.gameSpeed = 1000 / speedMultiplier;
        if (!state.isPaused) {
            clearInterval(state.gameLoopInterval);
            state.gameLoopInterval = setInterval(gameLoop, state.gameSpeed);
        }
    }

    function checkFinancialEvent() {
        if (!state.gameData[state.currentBarIndex]) return;
        const currentDate = new Date(state.gameData[state.currentBarIndex].time);
        const dayOfMonth = currentDate.getDate();
        const event = financialEvents.find(e => e.day === dayOfMonth);
        
        if (event && !event.triggered) {
            if (!state.isPaused) togglePlayPause();
            event.triggered = true;
            showModal(event.title, event.body, [{text: "繼續", className: "btn-buy", callback: hideModal}]);
        }
    }

    function endGame() {
        if (!state.isPaused) togglePlayPause();
        closeAllPositions();
        showModal(
            "挑戰結束！",
            `恭喜您完成本次交易挑戰！<br>您的最終淨值為：<strong class="text-yellow-400 text-lg">$${state.account.equity.toFixed(2)}</strong>`,
            [
                {text: "再次挑戰", className: "btn-close", callback: () => { hideModal(); startGame(); }},
                {text: "前往官網", className: "btn-buy glowing-border", callback: () => { window.open('https://www.google.com', '_blank'); }}
            ]
        );
    }
    
    /**
     * 4. 交易與帳戶系統
     */
    function executeTrade(type) {
        if (!state.gameData[state.currentBarIndex]) return;
        const lots = parseFloat(inputLots.value);
        const sl = parseFloat(inputSl.value);
        const tp = parseFloat(inputTp.value);
        const currentPrice = state.gameData[state.currentBarIndex].c;

        if (isNaN(lots) || lots <= 0) {
            showModal("輸入無效", "請輸入有效的手數。", [{text: "好的", className: "btn-buy", callback: hideModal}]);
            return;
        }

        const position = {
            id: Date.now(),
            type: type,
            lots: lots,
            entryPrice: currentPrice,
            entryTime: state.gameData[state.currentBarIndex].time,
            sl: isNaN(sl) || sl === 0 ? null : sl,
            tp: isNaN(tp) || tp === 0 ? null : tp,
            pl: 0,
        };
        state.positions.push(position);
        updateAllUI();
        requestRedraw();
    }
    
    function closePosition(positionId) {
        const index = state.positions.findIndex(p => p.id === positionId);
        if (index === -1 || !state.gameData[state.currentBarIndex]) return;
        
        const position = state.positions[index];
        const closePrice = state.gameData[state.currentBarIndex].c;
        const closeTime = state.gameData[state.currentBarIndex].time;
        
        const finalPL = calculatePL(position, closePrice);
        state.account.balance += finalPL;
        
        state.journal.push({
            ...position,
            closePrice: closePrice,
            closeTime: closeTime,
            pl: finalPL,
        });
        
        state.positions.splice(index, 1);
        updateAllUI();
        requestRedraw();
    }

    function closeAllPositions() {
        while(state.positions.length > 0) {
            closePosition(state.positions[0].id);
        }
    }

    function modifyPosition(positionId, newSl, newTp) {
        const position = state.positions.find(p => p.id === positionId);
        if (position) {
            position.sl = isNaN(newSl) || newSl === 0 ? null : newSl;
            position.tp = isNaN(newTp) || newTp === 0 ? null : newTp;
            updatePositionsList();
            requestRedraw();
        }
    }

    function calculatePL(position, currentPrice) {
        const priceDiff = currentPrice - position.entryPrice;
        const multiplier = position.type === 'buy' ? 1 : -1;
        return priceDiff * multiplier * position.lots * 100;
    }

    function updatePositionsPL() {
        if (!state.gameData[state.currentBarIndex]) return;
        const currentPrice = state.gameData[state.currentBarIndex].c;
        let totalPL = 0;
        state.positions.forEach(p => {
            p.pl = calculatePL(p, currentPrice);
            totalPL += p.pl;
        });
        state.account.equity = state.account.balance + totalPL;
    }
    
    function checkSLTP() {
        if (!state.gameData[state.currentBarIndex]) return;
        const currentBar = state.gameData[state.currentBarIndex];
        const high = currentBar.h;
        const low = currentBar.l;
        
        [...state.positions].forEach(p => {
            if (p.type === 'buy') {
                if (p.sl && low <= p.sl) closePosition(p.id);
                else if (p.tp && high >= p.tp) closePosition(p.id);
            } else { // sell
                if (p.sl && high >= p.sl) closePosition(p.id);
                else if (p.tp && low <= p.tp) closePosition(p.id);
            }
        });
    }

    /**
     * 5. UI 更新模組 (非 Canvas)
     */
    function updateAllUI() {
        const currentBar = state.gameData[state.currentBarIndex];
        if (currentBar) {
            hudDate.textContent = new Date(currentBar.time).toLocaleDateString();
        }
        hudEquity.textContent = state.account.equity.toFixed(2);
        const totalPL = state.positions.reduce((sum, p) => sum + p.pl, 0);
        hudPl.textContent = totalPL.toFixed(2);
        hudPl.style.color = totalPL >= 0 ? 'var(--green)' : 'var(--red)';
        
        if (state.gameData.length > 1) {
            const progress = (state.currentBarIndex / (state.gameData.length - 1)) * 100;
            progressBar.style.width = `${progress}%`;
        }
        
        updatePositionsList();
        updateJournalList();
    }
    
    function updatePositionsList() {
        positionsCount.textContent = state.positions.length;
        if (state.positions.length === 0) {
            positionsList.innerHTML = `<p class="text-center text-text-secondary py-4">暫無持倉</p>`;
            btnCloseAll.classList.add('hidden');
            return;
        }
        
        btnCloseAll.classList.remove('hidden');
        positionsList.innerHTML = state.positions.map(p => `
            <div class="grid grid-cols-5 gap-2 items-center text-xs mb-2 p-2 bg-border-color rounded-md">
                <div>
                    <span class="font-bold ${p.type === 'buy' ? 'text-green-400' : 'text-red-400'}">${p.type.toUpperCase()}</span>
                    <span class="text-text-secondary">${p.lots}</span>
                </div>
                <div class="text-center">${p.entryPrice.toFixed(2)}</div>
                <div class="text-center">
                    <input type="number" value="${p.sl || ''}" placeholder="-" data-id="${p.id}" data-type="sl" class="input-number w-full text-center p-1 text-xs modify-input">
                </div>
                <div class="text-center">
                    <input type="number" value="${p.tp || ''}" placeholder="-" data-id="${p.id}" data-type="tp" class="input-number w-full text-center p-1 text-xs modify-input">
                </div>
                <div class="text-right">
                    <span class="font-bold ${p.pl >= 0 ? 'text-green-400' : 'text-red-400'}">${p.pl.toFixed(2)}</span>
                    <button data-id="${p.id}" class="close-pos-btn ml-2 text-red-500">✕</button>
                </div>
            </div>
        `).join('');
    }
    
    function updateJournalList() {
        if (state.journal.length === 0) {
            journalList.innerHTML = `<p class="text-center text-text-secondary py-4">暫無交易紀錄</p>`;
            return;
        }
        journalList.innerHTML = `
            <div class="grid grid-cols-5 gap-2 text-xs font-bold text-text-secondary mb-2 px-2">
                <span>類型</span>
                <span class="text-center">開倉</span>
                <span class="text-center">平倉</span>
                <span class="text-center">手數</span>
                <span class="text-right">損益</span>
            </div>
            ${state.journal.slice().reverse().map(j => `
                <div class="grid grid-cols-5 gap-2 text-xs mb-1 px-2 py-1 rounded-md hover:bg-border-color">
                    <span class="font-bold ${j.type === 'buy' ? 'text-green-400' : 'text-red-400'}">${j.type.toUpperCase()}</span>
                    <span class="text-center">${j.entryPrice.toFixed(2)}</span>
                    <span class="text-center">${j.closePrice.toFixed(2)}</span>
                    <span class="text-center">${j.lots}</span>
                    <span class="text-right font-bold ${j.pl >= 0 ? 'text-green-400' : 'text-red-400'}">${j.pl.toFixed(2)}</span>
                </div>
            `).join('')}
        `;
    }

    /**
     * 6. 主渲染迴圈 (requestAnimationFrame)
     */
    function draw() {
        if (state.needsRedraw) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (state.gameData.length > 0) {
                calculatePriceRange();
                drawGrid();
                drawCandles();
                drawPositions();
                drawPriceAxis();
                drawTimeAxis();
                drawCurrentPriceLine();
            }
            state.needsRedraw = false;
        }

        if (state.animation.isAnimating) {
            animateLastCandle();
        }

        requestAnimationFrame(draw);
    }

    function requestRedraw() {
        state.needsRedraw = true;
    }
    
    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        requestRedraw();
    }

    // --- 圖表繪製引擎 ---
    
    function calculatePriceRange() {
        if (!state.gameData[state.currentBarIndex]) return;
        const lastBarIndex = Math.min(state.currentBarIndex, state.gameData.length - 1);
        const firstBarIndex = Math.max(0, lastBarIndex - state.view.barsOnScreen + 1);
        state.view.firstBarIndex = firstBarIndex;

        let min = Infinity, max = -Infinity;
        for (let i = firstBarIndex; i <= lastBarIndex; i++) {
            if (state.gameData[i]) {
                min = Math.min(min, state.gameData[i].l);
                max = Math.max(max, state.gameData[i].h);
            }
        }
        
        if (min === Infinity) return;
        const padding = (max - min) * 0.1 || 1;
        state.view.priceMin = min - padding;
        state.view.priceMax = max + padding;
    }
    
    // 座標轉換
    function priceToY(price) {
        const priceRange = state.view.priceMax - state.view.priceMin;
        if (priceRange <= 0) return canvas.clientHeight / 2;
        return (1 - (price - state.view.priceMin) / priceRange) * canvas.clientHeight;
    }

    function indexToX(index) {
        const barWidth = canvas.clientWidth / state.view.barsOnScreen;
        return (index - state.view.firstBarIndex) * barWidth;
    }

    function drawGrid() {
        ctx.strokeStyle = 'var(--border-color)';
        ctx.lineWidth = 1;

        const priceRange = state.view.priceMax - state.view.priceMin;
        if (priceRange <= 0) return;
        const priceStep = Math.pow(10, Math.floor(Math.log10(priceRange)) - 1);
        
        for (let p = Math.ceil(state.view.priceMin / priceStep) * priceStep; p < state.view.priceMax; p += priceStep) {
            const y = priceToY(p);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.clientWidth, y);
            ctx.stroke();
        }

        const barWidth = canvas.clientWidth / state.view.barsOnScreen;
        const timeStep = Math.max(1, Math.floor(20 / barWidth));
        for (let i = state.view.firstBarIndex; i <= state.currentBarIndex; i += timeStep * 5) {
            const x = indexToX(i) + barWidth / 2;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.clientHeight);
            ctx.stroke();
        }
    }

    function drawCandles() {
        const barWidth = canvas.clientWidth / state.view.barsOnScreen;
        const lastBarIndex = Math.min(state.currentBarIndex, state.gameData.length - 1);

        for (let i = state.view.firstBarIndex; i < lastBarIndex; i++) {
            const bar = state.gameData[i];
            if (!bar) continue;

            const x = indexToX(i);
            const yO = priceToY(bar.o);
            const yC = priceToY(bar.c);
            const yH = priceToY(bar.h);
            const yL = priceToY(bar.l);

            ctx.strokeStyle = bar.c >= bar.o ? 'var(--green)' : 'var(--red)';
            ctx.fillStyle = ctx.strokeStyle;
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(x + barWidth / 2, yH);
            ctx.lineTo(x + barWidth / 2, yL);
            ctx.stroke();

            ctx.fillRect(x + barWidth * 0.1, Math.min(yO, yC), barWidth * 0.8, Math.abs(yO - yC) || 1);
        }
        
        const lastBar = state.gameData[lastBarIndex];
        if (lastBar && !state.animation.isAnimating) {
            const x = indexToX(lastBarIndex);
            const yO = priceToY(lastBar.o);
            const yC = priceToY(lastBar.c);
            const yH = priceToY(lastBar.h);
            const yL = priceToY(lastBar.l);

            ctx.strokeStyle = lastBar.c >= lastBar.o ? 'var(--green)' : 'var(--red)';
            ctx.fillStyle = ctx.strokeStyle;
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(x + barWidth / 2, yH);
            ctx.lineTo(x + barWidth / 2, yL);
            ctx.stroke();
            ctx.fillRect(x + barWidth * 0.1, Math.min(yO, yC), barWidth * 0.8, Math.abs(yO - yC) || 1);
        }
    }

    function startCandleAnimation() {
        if (!state.gameData[state.currentBarIndex]) return;
        const lastBar = state.gameData[state.currentBarIndex];
        state.animation = {
            isAnimating: true,
            targetHigh: lastBar.h,
            targetLow: lastBar.l,
            targetClose: lastBar.c,
            open: lastBar.o,
            startTime: performance.now(),
            duration: state.gameSpeed * 0.8,
        };
        requestAnimationFrame(draw);
    }
    
    function animateLastCandle() {
        const now = performance.now();
        const elapsed = now - state.animation.startTime;
        let progress = Math.min(elapsed / state.animation.duration, 1);
        
        requestRedraw();

        const bar = state.animation;
        const yO = priceToY(bar.open);
        
        const currentHigh = bar.open + (bar.targetHigh - bar.open) * progress;
        const currentLow = bar.open - (bar.open - bar.targetLow) * progress;
        const yH = priceToY(currentHigh);
        const yL = priceToY(currentLow);
        
        const currentClose = bar.open + (bar.targetClose - bar.open) * progress;
        const yC = priceToY(currentClose);
        
        const x = indexToX(state.currentBarIndex);
        const barWidth = canvas.clientWidth / state.view.barsOnScreen;
        
        ctx.strokeStyle = currentClose >= bar.open ? 'var(--green)' : 'var(--red)';
        ctx.fillStyle = ctx.strokeStyle;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(x + barWidth / 2, yH);
        ctx.lineTo(x + barWidth / 2, yL);
        ctx.stroke();

        ctx.fillRect(x + barWidth * 0.1, Math.min(yO, yC), barWidth * 0.8, Math.abs(yO - yC) || 1);

        if (progress >= 1) {
            state.animation.isAnimating = false;
        }
    }

    function drawPriceAxis() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        ctx.clearRect(width - 60, 0, 60, height);
        
        ctx.fillStyle = 'var(--text-secondary)';
        ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = 'left';

        const priceRange = state.view.priceMax - state.view.priceMin;
        if (priceRange <= 0) return;
        const priceStep = Math.pow(10, Math.floor(Math.log10(priceRange)) - 1);
        
        for (let p = Math.ceil(state.view.priceMin / priceStep) * priceStep; p < state.view.priceMax; p += priceStep) {
            const y = priceToY(p);
            ctx.fillText(p.toFixed(2), width - 55, y + 4);
        }
    }

    function drawTimeAxis() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        ctx.clearRect(0, height - 20, width, 20);

        ctx.fillStyle = 'var(--text-secondary)';
        ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = 'center';

        const barWidth = width / state.view.barsOnScreen;
        const timeStep = Math.max(1, Math.floor(100 / barWidth));

        for (let i = state.view.firstBarIndex; i <= state.currentBarIndex; i += timeStep) {
            const bar = state.gameData[i];
            if (!bar) continue;
            const x = indexToX(i) + barWidth / 2;
            const date = new Date(bar.time);
            ctx.fillText(`${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`, x, height - 5);
        }
    }

    function drawCurrentPriceLine() {
        const currentBar = state.gameData[state.currentBarIndex];
        if (!currentBar) return;

        const price = currentBar.c;
        const y = priceToY(price);
        const width = canvas.clientWidth;

        ctx.strokeStyle = 'var(--yellow)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width - 60, y);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'var(--yellow)';
        ctx.fillRect(width - 60, y - 10, 60, 20);
        ctx.fillStyle = 'var(--bg-main)';
        ctx.font = 'bold 12px ' + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = 'center';
        ctx.fillText(price.toFixed(2), width - 30, y + 4);
    }

    function drawPositions() {
        if (!state.gameData[state.currentBarIndex]) return;
        const currentPrice = state.gameData[state.currentBarIndex].c;

        state.positions.forEach(p => {
            const yEntry = priceToY(p.entryPrice);
            ctx.strokeStyle = 'var(--blue)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(0, yEntry);
            ctx.lineTo(canvas.clientWidth - 60, yEntry);
            ctx.stroke();
            
            if (p.sl) {
                const ySl = priceToY(p.sl);
                ctx.strokeStyle = 'var(--red)';
                ctx.beginPath();
                ctx.moveTo(0, ySl);
                ctx.lineTo(canvas.clientWidth - 60, ySl);
                ctx.stroke();
                ctx.fillStyle = 'var(--red)';
                ctx.font = '10px ' + getComputedStyle(document.body).fontFamily;
                ctx.textAlign = 'left';
                ctx.fillText('SL', 5, ySl - 2);
            }
            
            if (p.tp) {
                const yTp = priceToY(p.tp);
                ctx.strokeStyle = 'var(--green)';
                ctx.beginPath();
                ctx.moveTo(0, yTp);
                ctx.lineTo(canvas.clientWidth - 60, yTp);
                ctx.stroke();
                ctx.fillStyle = 'var(--green)';
                ctx.font = '10px ' + getComputedStyle(document.body).fontFamily;
                ctx.textAlign = 'left';
                ctx.fillText('TP', 5, yTp - 2);
            }
            
            ctx.setLineDash([]);
            
            const pl = calculatePL(p, currentPrice);
            const plText = `${pl >= 0 ? '+' : ''}${pl.toFixed(2)}`;
            ctx.fillStyle = pl >= 0 ? 'var(--green)' : 'var(--red)';
            ctx.fillRect(5, yEntry - 10, 60, 20);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px ' + getComputedStyle(document.body).fontFamily;
            ctx.textAlign = 'center';
            ctx.fillText(plText, 35, yEntry + 4);
        });
    }

    // --- 事件監聽器 ---
    function bindPermanentEventListeners() {
        // Playback
        playPauseBtn.addEventListener('click', togglePlayPause);
        stepForwardBtn.addEventListener('click', stepForward);
        speedControl.addEventListener('change', (e) => changeSpeed(parseFloat(e.target.value)));

        // Tabs
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.dataset.tab;
                tabButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                tabContents.forEach(c => c.classList.add('hidden'));
                document.getElementById(`tab-content-${tab}`).classList.remove('hidden');
            });
        });

        // Trade
        btnBuy.addEventListener('click', () => executeTrade('buy'));
        btnSell.addEventListener('click', () => executeTrade('sell'));
        stepperBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const inputId = btn.dataset.input;
                const step = parseFloat(btn.dataset.step);
                const input = document.getElementById(`input-${inputId}`);
                if (input) {
                    let value = parseFloat(input.value) || 0;
                    value += step;
                    if (inputId === 'lots' && value < 0.01) value = 0.01;
                    input.value = value.toFixed(inputId === 'lots' ? 2 : 2);
                }
            });
        });
        
        // Positions
        btnCloseAll.addEventListener('click', closeAllPositions);
        positionsList.addEventListener('click', (e) => {
            if (e.target.classList.contains('close-pos-btn')) {
                const id = parseInt(e.target.dataset.id, 10);
                closePosition(id);
            }
        });
        positionsList.addEventListener('change', (e) => {
            if (e.target.classList.contains('modify-input')) {
                const id = parseInt(e.target.dataset.id, 10);
                const position = state.positions.find(p => p.id === id);
                if (position) {
                    const slInput = positionsList.querySelector(`input[data-id="${id}"][data-type="sl"]`);
                    const tpInput = positionsList.querySelector(`input[data-id="${id}"][data-type="tp"]`);
                    const newSl = parseFloat(slInput.value);
                    const newTp = parseFloat(tpInput.value);
                    modifyPosition(id, newSl, newTp);
                }
            }
        });

        // Chart Interaction
        let panStartBarIndex = 0;
        canvas.addEventListener('mousedown', (e) => {
            state.view.isDragging = true;
            state.view.lastMouseX = e.clientX;
            panStartBarIndex = state.view.firstBarIndex;
        });
        canvas.addEventListener('touchstart', (e) => {
            state.view.isDragging = true;
            state.view.lastMouseX = e.touches[0].clientX;
            panStartBarIndex = state.view.firstBarIndex;
        }, { passive: true });

        window.addEventListener('mousemove', (e) => {
            if (!state.view.isDragging) return;
            const dx = e.clientX - state.view.lastMouseX;
            const barWidth = canvas.clientWidth / state.view.barsOnScreen;
            const barShift = Math.round(dx / barWidth);
            
            const newFirstBarIndex = panStartBarIndex - barShift;
            state.view.firstBarIndex = Math.max(0, Math.min(newFirstBarIndex, state.currentBarIndex - 10));

            requestRedraw();
        });
        window.addEventListener('touchmove', (e) => {
            if (!state.view.isDragging) return;
            const dx = e.touches[0].clientX - state.view.lastMouseX;
            const barWidth = canvas.clientWidth / state.view.barsOnScreen;
            const barShift = Math.round(dx / barWidth);

            const newFirstBarIndex = panStartBarIndex - barShift;
            state.view.firstBarIndex = Math.max(0, Math.min(newFirstBarIndex, state.currentBarIndex - 10));

            requestRedraw();
        }, { passive: true });

        window.addEventListener('mouseup', () => { state.view.isDragging = false; });
        window.addEventListener('touchend', () => { state.view.isDragging = false; });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
            const newBarsOnScreen = Math.round(state.view.barsOnScreen * zoomFactor);
            state.view.barsOnScreen = Math.max(20, Math.min(500, newBarsOnScreen));
            requestRedraw();
        });
    }

    // --- 彈出式視窗與新手導引 ---
    function showModal(title, body, actions) {
        modalTitle.textContent = title;
        modalBody.innerHTML = body;
        modalActions.innerHTML = '';
        actions.forEach(action => {
            const button = document.createElement('button');
            button.textContent = action.text;
            button.className = `btn ${action.className} w-full sm:w-auto px-6 py-3 rounded-md font-bold`;
            button.onclick = action.callback;
            modalActions.appendChild(button);
        });
        modalContainer.classList.remove('hidden');
    }

    function hideModal() {
        modalContainer.classList.add('hidden');
    }

    const tutorialSteps = [
        { selector: '#chart-canvas', text: '這裡是 K 線圖。綠色代表上漲，紅色代表下跌。您可以拖曳來平移，使用滑鼠滾輪來縮放。' },
        { selector: '#hud', text: '這裡是您的帳戶狀態，顯示當前日期、淨值和總浮動損益。' },
        { selector: '#tab-content-trade', text: '在「交易」面板，您可以設定手數、停損和停利，然後點擊「買入」或「賣出」來下單。' },
        { selector: '#bottom-panel .flex', text: '在「持倉」頁籤可以管理您目前的訂單，在「紀錄」頁籤可以查看歷史交易。' },
        { selector: '#playback-controls', text: '使用這些按鈕來播放、暫停、單步前進或調整模擬速度。' },
        { selector: null, text: '導引結束！現在開始您的交易挑戰吧！祝您好運！' }
    ];
    let currentTutorialStep = 0;

    function startTutorial() {
        currentTutorialStep = 0;
        tutorialContainer.classList.remove('hidden');
        showTutorialStep();
        tutorialNextBtn.addEventListener('click', nextTutorialStep);
    }
    
    function nextTutorialStep() {
        currentTutorialStep++;
        if (currentTutorialStep < tutorialSteps.length) {
            showTutorialStep();
        } else {
            endTutorial();
        }
    }

    function endTutorial() {
        tutorialContainer.classList.add('hidden');
        localStorage.setItem('trading_challenge_tutorial_seen', 'true');
        startGame();
    }

    function showTutorialStep() {
        const step = tutorialSteps[currentTutorialStep];
        tutorialText.textContent = step.text;
        tutorialStep.textContent = `${currentTutorialStep + 1} / ${tutorialSteps.length}`;

        if (step.selector) {
            const targetElement = document.querySelector(step.selector);
            if (!targetElement) {
                console.warn(`Tutorial target not found: ${step.selector}`);
                nextTutorialStep(); // Skip if element not found
                return;
            }
            const rect = targetElement.getBoundingClientRect();
            
            tutorialHighlight.style.display = 'block';
            tutorialHighlight.style.left = `${rect.left}px`;
            tutorialHighlight.style.top = `${rect.top}px`;
            tutorialHighlight.style.width = `${rect.width}px`;
            tutorialHighlight.style.height = `${rect.height}px`;

            const tooltipRect = tutorialTooltip.getBoundingClientRect();
            let tooltipTop = rect.bottom + 10;
            if (tooltipTop + tooltipRect.height > window.innerHeight) {
                tooltipTop = rect.top - tooltipRect.height - 10;
            }
            tutorialTooltip.style.left = `${rect.left + rect.width / 2 - tooltipRect.width / 2}px`;
            tutorialTooltip.style.top = `${tooltipTop}px`;
            
        } else {
            tutorialHighlight.style.display = 'none';
            tutorialTooltip.style.left = `50%`;
            tutorialTooltip.style.top = `50%`;
            tutorialTooltip.style.transform = 'translate(-50%, -50%)';
        }
        
        tutorialTooltip.classList.remove('visible');
        setTimeout(() => tutorialTooltip.classList.add('visible'), 50);

        if (currentTutorialStep === tutorialSteps.length - 1) {
            tutorialNextBtn.textContent = "完成";
        }
    }

    // --- 啟動應用 ---
    init();
    draw(); // Start the animation loop
});
</script>
</body>
</html>
