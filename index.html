<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trading Profit Challenge</title>
    <style>
        :root {
            --background-color: #f0f2f5;
            --chart-background: #ffffff;
            --text-color: #1c1e21;
            --border-color: #dce1e6;
            --primary-button-bg: #1877f2;
            --primary-button-text: #ffffff;
            --primary-button-hover: #166fe5;
            --secondary-button-bg: #e4e6eb;
            --secondary-button-text: #050505;
            --secondary-button-hover: #d8dadf;
            --buy-color: #42b72a;
            --sell-color: #f02849;
            --buy-color-light: rgba(66, 183, 42, 0.1);
            --sell-color-light: rgba(240, 40, 73, 0.1);
            --sl-color: #fa3838;
            --tp-color: #26a69a;
            --inactive-tab-bg: #e9eaec;
            --active-tab-bg: #ffffff;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        #header {
            padding: 8px 12px;
            background-color: var(--chart-background);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header .info {
            font-size: 14px;
        }

        #header .info span {
            margin-right: 16px;
        }

        #chart-container {
            flex-grow: 1;
            position: relative;
        }

        #chart-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #bottom-panel {
            flex-shrink: 0;
            background-color: var(--background-color);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        #tab-buttons {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-button {
            flex: 1;
            padding: 12px;
            text-align: center;
            background-color: var(--inactive-tab-bg);
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color);
            border-right: 1px solid var(--border-color);
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button.active {
            background-color: var(--active-tab-bg);
            border-bottom: 2px solid var(--primary-button-bg);
            margin-bottom: -1px; /* Overlap border */
        }

        .tab-content {
            display: none;
            padding: 12px;
        }

        .tab-content.active {
            display: block;
        }

        #trade-panel .trade-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        #trade-panel .input-group {
            margin-bottom: 10px;
        }

        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .input-row label {
            width: 80px;
            font-size: 14px;
        }
        
        .input-wrapper {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .input-wrapper input {
            flex-grow: 1;
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
            background-color: var(--chart-background);
            color: var(--text-color);
            -moz-appearance: textfield;
        }
        
        .input-wrapper input::-webkit-outer-spin-button,
        .input-wrapper input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .step-button {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-button-bg);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            color: var(--secondary-button-text);
        }

        #positions-panel table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        #positions-panel th,
        #positions-panel td {
            border: 1px solid var(--border-color);
            padding: 6px;
            text-align: center;
        }

        #positions-panel th {
            background-color: var(--secondary-button-bg);
        }
        
        .close-pos-btn {
            background: none;
            border: none;
            color: var(--sell-color);
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }

        .buy-button, .sell-button {
            flex-grow: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            color: var(--primary-button-text);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .buy-button {
            background-color: var(--buy-color);
        }

        .buy-button:hover {
            background-color: #3aa122;
        }
        
        .sell-button {
            background-color: var(--sell-color);
        }

        .sell-button:hover {
            background-color: #d82341;
        }
        
        #playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #playback-controls button {
            background-color: var(--secondary-button-bg);
            border: 1px solid var(--border-color);
            color: var(--secondary-button-text);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        #playback-controls button:hover {
            background-color: var(--secondary-button-hover);
        }
        #playback-controls select {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        /* Tutorial Overlay */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 999;
            display: none;
        }
        #tutorial-highlight {
            position: absolute;
            border: 3px solid #1877f2;
            border-radius: 8px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            transition: all 0.4s ease-in-out;
            pointer-events: none;
        }
        #tutorial-box {
            position: absolute;
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #tutorial-box p {
            margin: 0 0 15px 0;
            font-size: 16px;
            line-height: 1.5;
        }
        #tutorial-box button {
            background-color: #1877f2;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            float: right;
        }

        /* End Card */
        #end-card {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #end-card-content {
            background: var(--chart-background);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        #end-card-content h2 {
            margin-top: 0;
            font-size: 24px;
        }
        #end-card-content p {
            font-size: 18px;
            margin: 15px 0;
        }
        .final-profit {
            font-weight: bold;
            font-size: 28px;
        }
        .profit-positive {
            color: var(--buy-color);
        }
        .profit-negative {
            color: var(--sell-color);
        }
        #cta-button {
            display: inline-block;
            background-color: var(--buy-color);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            text-decoration: none;
            margin-top: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #cta-button:hover {
            background-color: #3aa122;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <div id="header">
            <div id="challenge-info" class="info">
                <span>日期: <span id="current-date">--</span></span>
                <span>淨值: <span id="equity-value">10000.00</span></span>
                <span>總損益: <span id="total-pnl">0.00</span></span>
            </div>
            <div id="playback-controls">
                 <button id="play-pause-btn">▶</button>
                 <button id="next-candle-btn">→</button>
                 <select id="speed-selector">
                    <option value="1000">x1</option>
                    <option value="500">x2</option>
                    <option value="250">x4</option>
                    <option value="100">x8</option>
                </select>
            </div>
        </div>
        <div id="chart-container">
            <canvas id="chart-canvas"></canvas>
        </div>
        <div id="bottom-panel">
            <div id="tab-buttons">
                <button class="tab-button active" data-tab="trade-panel">交易</button>
                <button class="tab-button" data-tab="positions-panel">持倉 (<span id="position-count">0</span>)</button>
            </div>
            <div id="trade-panel" class="tab-content active">
                 <div class="input-row">
                    <label for="sl-input">停損價</label>
                    <div class="input-wrapper">
                        <button class="step-button" data-input="sl-input" data-step="-1">-</button>
                        <input type="number" id="sl-input" step="0.1">
                        <button class="step-button" data-input="sl-input" data-step="1">+</button>
                    </div>
                </div>
                <div class="input-row">
                    <label for="tp-input">停利價</label>
                    <div class="input-wrapper">
                         <button class="step-button" data-input="tp-input" data-step="-1">-</button>
                        <input type="number" id="tp-input" step="0.1">
                        <button class="step-button" data-input="tp-input" data-step="1">+</button>
                    </div>
                </div>
                 <div class="trade-actions">
                    <button id="sell-btn" class="sell-button">賣出</button>
                    <button id="buy-btn" class="buy-button">買入</button>
                </div>
            </div>
            <div id="positions-panel" class="tab-content">
                <table id="positions-table">
                    <thead>
                        <tr>
                            <th>類型</th>
                            <th>價格</th>
                            <th>SL</th>
                            <th>TP</th>
                            <th>損益</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div id="tutorial-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-box">
            <p id="tutorial-text"></p>
            <button id="tutorial-next-btn">下一步</button>
        </div>
    </div>

    <div id="end-card">
        <div id="end-card-content">
            <h2>挑戰結束！</h2>
            <p>您的最終淨值為：</p>
            <p id="final-equity" class="final-profit profit-positive">$10,523.45</p>
            <a id="cta-button" href="https://www.google.com" target="_blank">了解更多</a>
        </div>
    </div>

    <script>
        // =================================================================================
        // MAIN APPLICATION LOGIC
        // =================================================================================
        
        // --- CLASSES ---

        class TradingChart {
             constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.ohlcData = [];
                this.animations = [];
                this.visibleCandles = []; 

                this.candleWidth = 8;
                this.candleSpacing = 4;
                this.zoom = 1.0;
                this.panX = 0;

                this.minPrice = Infinity;
                this.maxPrice = -Infinity;

                this.isDragging = false;
                this.lastMouseX = 0;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.onMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.onMouseUp());
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
             }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.ctx.scale(dpr, dpr);
                this.draw();
            }

            setData(data, visibleCandles) {
                this.ohlcData = data;
                this.visibleCandles = visibleCandles;
                this.calculatePriceRange();
                this.draw();
            }
             
            updateData(newData) {
                this.visibleCandles = newData;
                this.calculatePriceRange();
                this.draw();
            }

            calculatePriceRange() {
                if (!this.visibleCandles || this.visibleCandles.length === 0) return;

                let min = Infinity, max = -Infinity;
                for(const candle of this.visibleCandles) {
                    min = Math.min(min, candle.low);
                    max = Math.max(max, candle.high);
                }

                const padding = (max - min) * 0.1;
                this.minPrice = min - padding;
                this.maxPrice = max + padding;
            }

            draw() {
                if (!this.ctx) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawDateSeparators();
                this.drawCandles();
                this.drawPriceAxis();
                this.drawPositions();
                this.drawAnimations();
            }
            
            drawPositions() {
                if (!window.positions) return;
                positions.forEach(pos => {
                    this.drawPositionLine(pos.entryPrice, 'blue', pos.pnl);
                    if (pos.sl) this.drawPositionLine(pos.sl, 'red');
                    if (pos.tp) this.drawPositionLine(pos.tp, 'green');
                });
            }

            drawPositionLine(price, color, pnl = null) {
                const y = this.priceToY(price);
                this.ctx.beginPath();
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeStyle = color;
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.clientWidth, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                if (pnl !== null) {
                    const pnlText = pnl.toFixed(2);
                    const pnlColor = pnl >= 0 ? 'green' : 'red';
                    this.ctx.fillStyle = pnlColor;
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(pnlText, 10, y - 5);
                }
            }

            drawDateSeparators() {
                if (!this.visibleCandles || this.visibleCandles.length === 0) return;

                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#888';

                let lastDate = null;

                for (let i = 0; i < this.visibleCandles.length; i++) {
                    const candle = this.visibleCandles[i];
                    const date = new Date(candle.time * 1000);
                    const candleDate = date.toDateString();

                    if (lastDate && candleDate !== lastDate) {
                        const x = this.getXPosition(i);
                        
                        this.ctx.beginPath();
                        this.ctx.setLineDash([4, 4]);
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.clientHeight);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        this.ctx.fillText(date.toLocaleDateString(), x + 5, this.canvas.clientHeight - 10);
                    }
                    lastDate = candleDate;
                }
            }

            getXPosition(index) {
                const totalCandleWidth = (this.candleWidth + this.candleSpacing) * this.zoom;
                return this.canvas.clientWidth - (this.visibleCandles.length - index) * totalCandleWidth - this.panX;
            }

            drawCandles() {
                if (!this.visibleCandles || this.visibleCandles.length === 0) return;

                const totalCandleWidth = (this.candleWidth + this.candleSpacing) * this.zoom;
                
                this.visibleCandles.forEach((candle, i) => {
                    const x = this.getXPosition(i);
                     if (x < -totalCandleWidth || x > this.canvas.clientWidth + totalCandleWidth) return;

                    const openY = this.priceToY(candle.open);
                    const closeY = this.priceToY(candle.close);
                    const highY = this.priceToY(candle.high);
                    const lowY = this.priceToY(candle.low);
                    
                    const isBullish = candle.close >= candle.open;
                    this.ctx.strokeStyle = isBullish ? 'green' : 'red';
                    this.ctx.fillStyle = isBullish ? 'green' : 'red';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + (this.candleWidth * this.zoom) / 2, highY);
                    this.ctx.lineTo(x + (this.candleWidth * this.zoom) / 2, lowY);
                    this.ctx.stroke();

                    const bodyHeight = Math.max(1, Math.abs(openY - closeY));
                    const bodyY = Math.min(openY, closeY);
                    
                    this.ctx.fillRect(x, bodyY, this.candleWidth * this.zoom, bodyHeight);
                });
            }

            drawPriceAxis() {
                const axisWidth = 50;
                const clientWidth = this.canvas.clientWidth;
                const clientHeight = this.canvas.clientHeight;
                
                this.ctx.fillStyle = '#f0f2f5';
                this.ctx.fillRect(clientWidth - axisWidth, 0, axisWidth, clientHeight);
                this.ctx.strokeStyle = '#dce1e6';
                this.ctx.beginPath();
                this.ctx.moveTo(clientWidth - axisWidth, 0);
                this.ctx.lineTo(clientWidth - axisWidth, clientHeight);
                this.ctx.stroke();

                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                
                if (this.maxPrice === -Infinity || this.minPrice === Infinity) return;

                const priceRange = this.maxPrice - this.minPrice;
                const numTicks = 8;
                for (let i = 0; i <= numTicks; i++) {
                    const price = this.minPrice + (i / numTicks) * priceRange;
                    const y = this.priceToY(price);
                    
                    this.ctx.fillText(price.toFixed(2), clientWidth - axisWidth + 5, y + 4);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(clientWidth - axisWidth, y);
                    this.ctx.lineTo(clientWidth - axisWidth - 5, y);
                    this.ctx.stroke();
                }
            }
             
            addOpenPositionAnimation(price, type) {
                const y = this.priceToY(price);
                const x = this.canvas.clientWidth - 55;
                this.animations.push({ type: 'arrow', x, y, dir: type === 'buy' ? 1 : -1, life: 60 });
            }

            addClosePositionAnimation(price, pnl) {
                const y = this.priceToY(price);
                const x = this.canvas.clientWidth - 100;
                this.animations.push({ type: 'pnl', x, y, pnl, life: 90, startY: y });
            }
            
            drawAnimations() {
                this.ctx.save();
                for (let i = this.animations.length - 1; i >= 0; i--) {
                    const anim = this.animations[i];
                    anim.life--;

                    if (anim.type === 'arrow') {
                        this.ctx.fillStyle = anim.dir === 1 ? 'green' : 'red';
                        this.ctx.globalAlpha = anim.life / 60;
                        this.ctx.beginPath();
                        if (anim.dir === 1) { // Buy arrow
                            this.ctx.moveTo(anim.x, anim.y + 10);
                            this.ctx.lineTo(anim.x + 10, anim.y);
                            this.ctx.lineTo(anim.x + 20, anim.y + 10);
                        } else { // Sell arrow
                            this.ctx.moveTo(anim.x, anim.y - 10);
                            this.ctx.lineTo(anim.x + 10, anim.y);
                            this.ctx.lineTo(anim.x + 20, anim.y - 10);
                        }
                        this.ctx.fill();
                    } else if (anim.type === 'pnl') {
                        const pnlText = (anim.pnl > 0 ? '+' : '') + anim.pnl.toFixed(2);
                        this.ctx.fillStyle = anim.pnl > 0 ? 'rgba(0, 128, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                        this.ctx.font = 'bold 14px Arial';
                        anim.y -= 0.5;
                        this.ctx.globalAlpha = anim.life / 90;
                        this.ctx.fillText(pnlText, anim.x, anim.y);
                    }

                    if (anim.life <= 0) {
                        this.animations.splice(i, 1);
                    }
                }
                 this.ctx.restore();
            }

            priceToY(price) {
                const priceRange = this.maxPrice - this.minPrice;
                if (priceRange <= 0) return this.canvas.clientHeight / 2;
                return (1 - (price - this.minPrice) / priceRange) * this.canvas.clientHeight;
            }

            onMouseDown(e) { this.isDragging = true; this.lastMouseX = e.clientX; }
            onMouseMove(e) { if (this.isDragging) { const dx = e.clientX - this.lastMouseX; this.panX -= dx; this.lastMouseX = e.clientX; this.draw(); } }
            onMouseUp() { this.isDragging = false; }
            onWheel(e) { e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; this.zoom = Math.max(0.1, Math.min(10, this.zoom * zoomFactor)); this.draw(); }
        }

        // --- GLOBAL STATE ---
        let ohlcData = [];
        let currentIndex = 0;
        let visibleCandles = [];
        let isPlaying = false;
        let gameInterval;
        let candleSpeed = 500;
        let chart;
        let positions = [];
        let nextPositionId = 1;
        let account = { balance: 10000, equity: 10000 };
        const VISIBLE_CANDLE_COUNT = 60;
        let tutorialStep = 0;

        // --- CORE FUNCTIONS ---

        async function loadDataAndStart() {
            console.log("Starting data load...");
            try {
                const response = await fetch('XAUUSD_M15.csv');
                 if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log(`CSV file fetched. Length: ${csvText.length} characters.`);
                
                const parsedData = parseData(csvText); // <--- RENAMED for clarity
                console.log(`Data parsed. Total valid records: ${parsedData.length}`);

                ohlcData = selectRandomMonth(parsedData);
                console.log(`Random month selected. Records for this challenge: ${ohlcData.length}`);
                
                resetChallenge();

            } catch (error) {
                console.error("Fatal Error: Failed to load or process data.", error);
                alert("錯誤：無法載入或處理市場數據，請檢查控制台以獲取詳細資訊。");
            }
        }
        
        /**
         * The definitive, format-aware data parser.
         * Handles both comma-separated (timestamp,o,h,l,c) and
         * space/tab-separated (YYYY.MM.DD HH:MM:SS o h l c v) formats.
         */
        function parseData(text) {
            console.log("Entering definitive data parser...");
            const universalText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const lines = universalText.trim().split('\n');
            
            if (lines.length <= 1) {
                console.error("Data has no rows (or only a header).");
                return [];
            }
            
            const header = lines[0].trim();
            const dataLines = lines.slice(1);
            
            // Auto-detect format based on header or first line content
            let isTimestampFormat = header.startsWith('time,') || /^\d{10,}/.test(dataLines[0]);
            
            if (isTimestampFormat) {
                console.log("Detected format: Unix Timestamp with Commas");
                return parseTimestampCSV(dataLines);
            } else {
                console.log("Detected format: Date String with Spaces/Tabs");
                return parseDateTimeSpaceSeparated(dataLines);
            }
        }

        function parseTimestampCSV(dataLines) {
            const results = [];
            for (let i = 0; i < dataLines.length; i++) {
                const line = dataLines[i].trim();
                if (!line) continue;
                
                const parts = line.split(',');
                if (parts.length < 5) continue;

                const dataPoint = {
                    time: parseInt(parts[0], 10),
                    open: parseFloat(parts[1]),
                    high: parseFloat(parts[2]),
                    low: parseFloat(parts[3]),
                    close: parseFloat(parts[4])
                };

                if (!Object.values(dataPoint).some(isNaN)) {
                    results.push(dataPoint);
                }
            }
            return results;
        }

        function parseDateTimeSpaceSeparated(dataLines) {
            const results = [];
            for (let i = 0; i < dataLines.length; i++) {
                const line = dataLines[i].trim();
                if (!line) continue;

                const parts = line.split(/\s+/); // Split by one or more whitespace chars
                if (parts.length < 6) continue; // YYYY.MM.DD, HH:MM:SS, O, H, L, C

                try {
                    // Re-format date string from 'YYYY.MM.DD' to 'YYYY-MM-DD' for better compatibility
                    const dateString = parts[0].replace(/\./g, '-') + ' ' + parts[1];
                    const timestamp = new Date(dateString).getTime() / 1000; // Convert to seconds

                    const dataPoint = {
                        time: timestamp,
                        open: parseFloat(parts[2]),
                        high: parseFloat(parts[3]),
                        low: parseFloat(parts[4]),
                        close: parseFloat(parts[5])
                    };

                    if (!Object.values(dataPoint).some(isNaN)) {
                        results.push(dataPoint);
                    }
                } catch (e) {
                    // Ignore lines that cause date parsing errors
                }
            }
            return results;
        }


        function selectRandomMonth(data) {
            if (!data || data.length === 0) {
                console.warn("Input data for selectRandomMonth is empty. Returning empty array.");
                return [];
            }
            
            const months = {};
            data.forEach(d => {
                const date = new Date(d.time * 1000);
                if (isNaN(date.getTime())) return;
                
                const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                if (!months[monthKey]) {
                    months[monthKey] = [];
                }
                months[monthKey].push(d);
            });
            
            const monthKeys = Object.keys(months);
            if (monthKeys.length === 0) {
                console.warn("No valid months found in data. Returning empty array.");
                return [];
            }

            const randomMonthKey = monthKeys[Math.floor(Math.random() * monthKeys.length)];
            return months[randomMonthKey] || [];
        }

        function resetChallenge() {
            console.log("Resetting challenge...");
            if (!ohlcData || ohlcData.length === 0) {
                console.error("Challenge cannot be reset: ohlcData is empty or invalid.");
                alert("錯誤：沒有有效的市場數據可以開始挑戰。");
                return;
            }

            currentIndex = VISIBLE_CANDLE_COUNT;
            visibleCandles = ohlcData.slice(0, VISIBLE_CANDLE_COUNT);
            chart.setData(ohlcData, visibleCandles);
            updateUI();
            showTutorialStep(0);
            console.log("Challenge ready.");
        }

        function nextCandle() {
            if (currentIndex >= ohlcData.length -1) {
                pauseGame();
                showEndCard();
                return;
            }
            currentIndex++;
            const newCandle = ohlcData[currentIndex];
            
            updatePositions(newCandle.close);
            chart.updateData(ohlcData.slice(Math.max(0, currentIndex - VISIBLE_CANDLE_COUNT), currentIndex + 1));
            updateUI();
        }

        function playPause() {
            isPlaying = !isPlaying;
            document.getElementById('play-pause-btn').textContent = isPlaying ? '❚❚' : '▶';
            if (isPlaying) {
                gameInterval = setInterval(nextCandle, candleSpeed);
            } else {
                clearInterval(gameInterval);
            }
        }
        
        function pauseGame() {
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('play-pause-btn').textContent = '▶';
                clearInterval(gameInterval);
            }
        }

        function setSpeed(speed) {
            candleSpeed = parseInt(speed);
            if (isPlaying) {
                clearInterval(gameInterval);
                gameInterval = setInterval(nextCandle, candleSpeed);
            }
        }

        // --- UI FUNCTIONS ---
        
        function updateUI() {
            const currentCandle = ohlcData[currentIndex];
            if (!currentCandle) return;
            
            const currentDate = new Date(currentCandle.time * 1000).toLocaleString();
            document.getElementById('current-date').textContent = currentDate;
            
            const totalPnl = positions.reduce((sum, pos) => sum + pos.pnl, 0);
            account.equity = account.balance + totalPnl;

            document.getElementById('equity-value').textContent = account.equity.toFixed(2);
            document.getElementById('total-pnl').textContent = totalPnl.toFixed(2);
            
            updatePositionsTable();
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        }

        // --- TRADE FUNCTIONS ---

        function openPosition(type) {
            const currentPrice = ohlcData[currentIndex].close;
            const slInput = document.getElementById('sl-input');
            const tpInput = document.getElementById('tp-input');

            const sl = parseFloat(slInput.value) || null;
            const tp = parseFloat(tpInput.value) || null;

            if (type === 'buy') {
                if (sl && sl >= currentPrice) { alert('Buy Stop Loss must be below entry price.'); return; }
                if (tp && tp <= currentPrice) { alert('Buy Take Profit must be above entry price.'); return; }
            } else {
                if (sl && sl <= currentPrice) { alert('Sell Stop Loss must be above entry price.'); return; }
                if (tp && tp >= currentPrice) { alert('Sell Take Profit must be below entry price.'); return; }
            }
            
            const newPosition = { id: nextPositionId++, type, entryPrice: currentPrice, sl, tp, pnl: 0, };
            positions.push(newPosition);
            chart.addOpenPositionAnimation(currentPrice, type);
            updateUI();
        }

        function closePosition(positionId) {
            const posIndex = positions.findIndex(p => p.id === positionId);
            if (posIndex > -1) {
                const pos = positions[posIndex];
                account.balance += pos.pnl;
                chart.addClosePositionAnimation(ohlcData[currentIndex].close, pos.pnl);
                positions.splice(posIndex, 1);
                updateUI();
            }
        }

        function updatePositions(currentPrice) {
            let positionsClosed = false;
            for (let i = positions.length - 1; i >= 0; i--) {
                const pos = positions[i];
                const pnlMultiplier = 100; // Simplified PnL calculation
                if (pos.type === 'buy') {
                    pos.pnl = (currentPrice - pos.entryPrice) * pnlMultiplier;
                    if ((pos.sl && currentPrice <= pos.sl) || (pos.tp && currentPrice >= pos.tp)) {
                        closePosition(pos.id);
                        positionsClosed = true;
                    }
                } else {
                    pos.pnl = (pos.entryPrice - currentPrice) * pnlMultiplier;
                     if ((pos.sl && currentPrice >= pos.sl) || (pos.tp && currentPrice <= pos.tp)) {
                        closePosition(pos.id);
                        positionsClosed = true;
                    }
                }
            }
            if (!positionsClosed) {
                updateUI();
            }
        }
        
        function updatePositionsTable() {
            const tableBody = document.getElementById('positions-table').querySelector('tbody');
            tableBody.innerHTML = '';
            document.getElementById('position-count').textContent = positions.length;

            positions.forEach(pos => {
                const row = document.createElement('tr');
                const pnlColor = pos.pnl >= 0 ? 'var(--buy-color)' : 'var(--sell-color)';
                row.innerHTML = `
                    <td style="color: ${pos.type === 'buy' ? 'var(--buy-color)' : 'var(--sell-color)'}">${pos.type.toUpperCase()}</td>
                    <td>${pos.entryPrice.toFixed(2)}</td>
                    <td>${pos.sl ? pos.sl.toFixed(2) : '--'}</td>
                    <td>${pos.tp ? pos.tp.toFixed(2) : '--'}</td>
                    <td style="color: ${pnlColor}">${pos.pnl.toFixed(2)}</td>
                    <td><button class="close-pos-btn" data-id="${pos.id}">X</button></td>
                `;
                tableBody.appendChild(row);
            });
            
            tableBody.querySelectorAll('.close-pos-btn').forEach(btn => {
                btn.addEventListener('click', () => closePosition(parseInt(btn.dataset.id)));
            });
        }
        
        function handleStepButtonClick(e) {
            const target = e.target;
            if (!target.classList.contains('step-button')) return;
            
            const inputId = target.dataset.input;
            const step = parseFloat(target.dataset.step);
            const input = document.getElementById(inputId);
            
            if (input && ohlcData[currentIndex]) {
                let currentValue = parseFloat(input.value) || ohlcData[currentIndex].close;
                const priceStep = 0.5;
                input.value = (currentValue + step * priceStep).toFixed(2);
            }
        }

        // --- TUTORIAL FUNCTIONS ---
        const tutorialSteps = [
            { id: 'challenge-info', text: '這裡是您的帳戶資訊，目標是透過交易來增加淨值。' },
            { id: 'chart-canvas', text: '這是黃金(XAUUSD)的走勢圖，您可以拖曳平移、滾輪縮放。' },
            { id: 'playback-controls', text: '您可以使用這些按鈕來控制時間流逝，播放、暫停或加速。' },
            { id: 'bottom-panel', text: '這是交易面板。點擊「下一步」來學習如何下單。' },
            { id: 'sell-btn', text: '如果您認為價格會下跌，點擊「賣出」。' },
            { id: 'buy-btn', text: '如果您認為價格會上漲，點擊「買入」。祝您好運！' }
        ];

        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) {
                document.getElementById('tutorial-overlay').style.display = 'none';
                return;
            }
            tutorialStep = stepIndex;
            const step = tutorialSteps[stepIndex];
            const element = document.getElementById(step.id);
            if (!element) {
                setTimeout(() => {
                    const elementRetry = document.getElementById(step.id);
                    if (!elementRetry) {
                         console.error(`Tutorial Error: Element with ID "${step.id}" not found.`);
                         showTutorialStep(stepIndex + 1);
                         return;
                    }
                    positionTutorial(elementRetry, step.text);
                }, 100);
                return;
            }
            positionTutorial(element, step.text);
        }
        
        function positionTutorial(element, text) {
            document.getElementById('tutorial-overlay').style.display = 'block';
            
            const rect = element.getBoundingClientRect();
            const highlight = document.getElementById('tutorial-highlight');
            const box = document.getElementById('tutorial-box');

            highlight.style.top = `${rect.top - 5}px`;
            highlight.style.left = `${rect.left - 5}px`;
            highlight.style.width = `${rect.width + 10}px`;
            highlight.style.height = `${rect.height + 10}px`;

            document.getElementById('tutorial-text').textContent = text;
            
            const boxTop = rect.bottom + 15;
            const boxLeft = rect.left;
            
            box.style.top = `${boxTop}px`;
            box.style.left = `${boxLeft}px`;
            
            if (boxTop + box.offsetHeight > window.innerHeight) {
                 box.style.top = `${rect.top - box.offsetHeight - 15}px`;
            }
            if (boxLeft + box.offsetWidth > window.innerWidth) {
                box.style.left = `${window.innerWidth - box.offsetWidth - 15}px`;
            }
        }
        
        function showEndCard() {
            const endCard = document.getElementById('end-card');
            const finalEquityEl = document.getElementById('final-equity');
            
            finalEquityEl.textContent = `$${account.equity.toFixed(2)}`;
            finalEquityEl.className = account.equity >= account.balance ? 'final-profit profit-positive' : 'final-profit profit-negative';
            endCard.style.display = 'flex';
        }

        // =================================================================================
        // INITIALIZATION
        // =================================================================================
        document.addEventListener('DOMContentLoaded', () => {
            chart = new TradingChart('chart-canvas');

            document.getElementById('play-pause-btn').addEventListener('click', playPause);
            document.getElementById('next-candle-btn').addEventListener('click', () => { pauseGame(); nextCandle(); });
            document.getElementById('speed-selector').addEventListener('change', (e) => setSpeed(e.target.value));
            document.getElementById('buy-btn').addEventListener('click', () => openPosition('buy'));
            document.getElementById('sell-btn').addEventListener('click', () => openPosition('sell'));
            document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => switchTab(button.dataset.tab)); });
            document.getElementById('trade-panel').addEventListener('click', handleStepButtonClick);
            document.getElementById('tutorial-next-btn').addEventListener('click', () => showTutorialStep(tutorialStep + 1));
            document.getElementById('cta-button').addEventListener('click', (e) => { e.preventDefault(); window.open('https://www.google.com', '_blank'); });
            
            loadDataAndStart();
        });
    </script>
</body>
</html>
