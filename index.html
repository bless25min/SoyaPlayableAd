<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>XAUUSD 交易模擬挑戰 (Playable Ad Rework V6.3)</title>
    <style>
        /* 1. Reset & Variables */
        :root {
            --color-bg: #f5f7fa;
            --color-panel-bg: #ffffff;
            --color-border: #e0e3eb;
            --color-text-primary: #333333;
            --color-text-secondary: #7f8c8d;
            --color-primary: #3498db;
            --color-primary-dark: #2980b9;
            --color-success: #2ecc71;
            --color-danger: #e74c3c;
            --color-neutral: #95a5a6;
            --color-warning: #f1c40f;
            --font-main: 'Helvetica Neue', Arial, sans-serif;
            --shadow-main: 0 4px 12px rgba(0, 0, 0, 0.05);
            --radius-main: 8px;

            /* Chart Specific */
            --chart-bg: #ffffff;
            --chart-grid: #f0f0f0;
            --chart-date-separator: #cccccc;
            --chart-crosshair: #777777;
            --color-bull: #26a69a;
            --color-bear: #ef5350;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 2. Layout Structure */
        .header {
            background-color: var(--color-panel-bg);
            padding: 10px 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            /* NEW FIX: Crucial for flex children in column layout to handle overflow correctly */
            min-height: 0; 
        }

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }

        /* FIX: Sidebar Layout Rework (V6.1) */
        .sidebar {
            width: 340px;
            background-color: var(--color-panel-bg);
            border-left: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            /* overflow: hidden; // REMOVED: Let the content handle its own overflow */
            flex-shrink: 0;
            /* height: 100%; // REMOVED: Flexbox handles height within main-content */
        }
        
        /* Footer */
        .footer {
            background-color: var(--color-panel-bg);
            text-align: center;
            padding: 8px 0;
            font-size: 12px;
            color: var(--color-text-secondary);
            border-top: 1px solid var(--color-border);
        }
        .footer a {
            color: var(--color-primary);
            text-decoration: none;
        }
        .footer a:hover {
            text-decoration: underline;
        }


        /* Mobile Responsiveness Adjustments */
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                /* FIX: Ensure sidebar and chart share space correctly */
                max-height: none; 
                flex: 1; 
                border-left: none;
                border-top: 1px solid var(--color-border);
            }
            .chart-container {
                /* FIX: Allow chart to shrink but maintain minimum height */
                flex: 1;
                min-height: 300px; 
                padding: 10px;
            }
            .controls {
                flex-wrap: wrap;
            }
            /* Adjust HUD layout for mobile */
            .header {
                padding: 8px 10px;
            }
            .hud, .hud-right {
                gap: 10px;
            }
            .hud-value {
                font-size: 14px;
            }
            .progress-container {
                width: 100px;
            }
        }

        /* 3. Header (HUD) Components */
        /* ... (Styles for HUD remain unchanged) ... */
        .hud {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
        }

        .hud-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .hud-value {
            font-size: 16px;
            font-weight: bold;
        }

        #hud-pl.positive { color: var(--color-success); }
        #hud-pl.negative { color: var(--color-danger); }

        .hud-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .progress-container {
            width: 150px;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--color-border);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--color-primary);
            transition: width 0.3s ease;
        }

        /* 4. Chart Components */
        /* ... (Styles for Chart remain unchanged) ... */
        .chart-wrap {
            position: relative;
            flex: 1;
            background-color: var(--chart-bg);
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            overflow: hidden;
            cursor: crosshair;
        }

        #chartCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* DOM Overlays for Position Lines */
        .position-line {
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .position-line-dash {
            flex: 1;
            height: 1px;
            border-top-style: dashed;
            border-top-width: 1px;
        }

        .position-label {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            margin-left: 5px;
            margin-right: 5px;
            white-space: nowrap;
        }

        .position-pl {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.9);
            margin-right: 5px;
            font-weight: bold;
            box-shadow: var(--shadow-main);
        }

        /* 5. Controls & Toolbar */
        .controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius-main);
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            user-select: none;
            /* FIX: Ensure button content doesn't get clipped (Bug 1) */
            line-height: 1.2;
            min-height: 32px; 
        }

        .btn:hover:not(:disabled) {
            opacity: 0.9;
        }

        .btn:active:not(:disabled) {
            transform: scale(0.98);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: default;
            transform: scale(1);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--color-border);
            color: var(--color-text-primary);
        }
        
        .btn-danger {
            background-color: var(--color-danger);
            color: white;
        }

        .btn-end-game {
             background-color: var(--color-panel-bg);
             color: var(--color-danger);
             border: 1px solid var(--color-danger);
             margin-left: auto;
        }
        .btn-end-game:hover:not(:disabled) {
            background-color: var(--color-danger);
            color: white;
        }


        .speed-selector {
            display: flex;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            overflow: hidden;
        }

        .speed-btn {
            padding: 8px 10px;
            background-color: var(--color-panel-bg);
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .speed-btn.active {
            background-color: var(--color-primary);
            color: white;
        }

        .speed-btn:not(:last-child) {
            border-right: 1px solid var(--color-border);
        }

        /* 6. Sidebar (Trading Panel) */
        
        /* 6.0 Game Objective (Now hidden by default) */
        .challenge-info {
            display: none; /* Hidden as requested */
        }

        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            /* FIX: Prevent tabs from shrinking (Bug 2) */
            flex-shrink: 0; 
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            background-color: var(--color-bg);
            border: none;
            font-weight: bold;
        }

        .tab-btn.active {
            background-color: var(--color-panel-bg);
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-primary);
        }

        /* FIX: Wrapper for tab content to manage overflow (V6.1) */
        .tabs-wrapper {
            flex: 1;
            overflow: hidden; /* Constrains the tab-content within the wrapper */
            display: flex;
            flex-direction: column;
            /* NEW FIX: Crucial for flex children with overflow in complex layouts */
            min-height: 0; 
        }

        .tab-content {
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 15px;
            /* FIX: Fill the wrapper and allow internal scrolling */
            flex-grow: 1;
            overflow-y: auto; 
            /* height: 100%; // REMOVED: Redundant and conflicting */
        }

        .tab-content.active {
            display: flex;
        }

        /* 6.1 Order Panel */
        /* ... (Styles for Order Panel remain unchanged) ... */
        .order-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-label {
            font-size: 14px;
            color: var(--color-text-secondary);
            text-align: center;
        }

        .input-field {
            /* FIX: Reduced padding slightly to prevent clipping (Bug 1) */
            padding: 8px 5px; 
            border: 1px solid var(--color-border);
            font-size: 16px;
            text-align: center;
            width: 100%;
             -moz-appearance: textfield;
        }

        .input-field::-webkit-outer-spin-button,
        .input-field::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-stepper {
            display: flex;
            align-items: stretch;
        }

        .stepper-btn {
            width: 30px;
            background-color: var(--color-border);
            border: 1px solid var(--color-border);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        .stepper-btn:active {
            background-color: var(--color-primary);
            color: white;
        }

        .stepper-btn:first-child {
            border-top-left-radius: var(--radius-main);
            border-bottom-left-radius: var(--radius-main);
            border-right: none;
        }

        .stepper-btn:last-child {
            border-top-right-radius: var(--radius-main);
            border-bottom-right-radius: var(--radius-main);
            border-left: none;
        }

        .input-stepper .input-field {
            border-radius: 0;
            flex: 1;
            min-width: 0;
        }
        
        .input-estimate {
            font-size: 12px;
            color: var(--color-text-secondary);
            text-align: center;
            height: 18px;
        }


        .trade-actions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .btn-trade {
            /* FIX: Reduced padding slightly (Bug 1) */
            padding: 10px; 
            font-size: 18px;
            color: white;
        }

        .btn-buy {
            background-color: var(--color-bull);
        }

        .btn-sell {
            background-color: var(--color-bear);
        }

        .btn-close-all {
            background-color: var(--color-neutral);
            color: white;
            font-size: 16px;
        }


        /* 6.2 Positions & History */
        /* ... (Styles for Positions & History remain unchanged) ... */
        .positions-list, .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* overflow-y: auto; Handled by tab-content now */
            /* flex-grow: 1; */
        }

        .trade-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            padding: 10px;
            font-size: 14px;
        }

        .trade-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .trade-type.BUY { color: var(--color-bull); }
        .trade-type.SELL { color: var(--color-bear); }

        .trade-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .trade-detail-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .trade-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* 7. Modals & Overlays */
        /* ... (Styles for Modals remain unchanged) ... */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--color-panel-bg);
            padding: 30px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            max-width: 550px;
            width: 90%;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            max-height: 90vh;
            /* FIX: Ensure modal content scrolls if achievements overflow (Bug 4) */
            overflow-y: auto; 
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .modal-body {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .cta-button {
            background-color: var(--color-success);
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            letter-spacing: 1px;
            text-decoration: none;
        }

        /* 7.1 Tutorial Specific */
        .tutorial-highlight {
            position: absolute;
            border: 3px dashed var(--color-primary);
            border-radius: var(--radius-main);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            z-index: 1001;
            pointer-events: none;
            transition: top 0.3s, left 0.3s, width 0.3s, height 0.3s;
        }

        .tutorial-message {
            position: absolute;
            background-color: var(--color-primary);
            color: white;
            padding: 15px;
            border-radius: var(--radius-main);
            max-width: 300px;
            z-index: 1002;
            box-shadow: var(--shadow-main);
            transition: top 0.3s, left 0.3s;
        }
        
        /* 7.2 Achievements */
        .achievements-section {
            margin-top: 25px;
            border-top: 1px solid var(--color-border);
            padding-top: 15px;
            text-align: left;
        }
        .achievements-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            list-style-type: none;
            padding: 0;
            margin-top: 10px;
        }
        @media (max-width: 500px) {
            .achievements-list {
                grid-template-columns: 1fr; /* Single column on mobile */
            }
        }

        .achievement-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        .achievement-icon {
            font-size: 20px;
            /* color: var(--color-warning); Removed to allow emoji colors */
        }
        
        /* 7.3 Achievement Notifications (Toasts) */
        /* Kept for achievements, breakouts use animations (V6.3) */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1010;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        @media (max-width: 900px) {
            #notification-container {
                top: 60px; /* Move below header on mobile/tablet */
                right: 10px;
                left: 10px;
                align-items: center;
            }
        }

        .notification-toast {
            background-color: var(--color-primary-dark);
            color: white;
            padding: 15px 20px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            display: flex;
            flex-direction: column; /* Changed layout for better readability */
            align-items: flex-start;
            gap: 5px;
            max-width: 350px;
            width: 100%;
            /* Animation */
            opacity: 0;
            transform: translateY(-20px); /* Changed animation style */
            transition: opacity 0.5s, transform 0.5s;
        }
        .notification-toast.show {
            opacity: 1;
            transform: translateY(0);
        }


        /* 8. Utilities & Loader */
        .hidden {
            display: none !important;
        }

        .loader-wrap {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            gap: 20px;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 9. File Upload Fallback */
        .file-upload-prompt {
            background-color: var(--color-panel-bg);
            padding: 30px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            border: 1px solid var(--color-border);
            max-width: 450px;
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrap" id="loader">
        <div id="loader-status">
            <div class="loading-spinner"></div>
            <p>正在載入數據與初始化圖表...</p>
        </div>
        <!-- Fallback File Upload -->
        <div id="fileUploadFallback" class="file-upload-prompt hidden">
            <p style="color: var(--color-danger); margin-bottom: 15px; font-weight: bold;">⚠️ 數據載入失敗</p>
            <p id="loader-error-message" style="margin-bottom: 15px;"></p>
            <p>這可能是由於瀏覽器的本地檔案存取限制 (CORS) 或檔案格式不正確。</p>
            <p style="margin-bottom: 20px;">請手動上傳 <strong>XAUUSD_M15.csv</strong> 檔案以繼續：</p>
            <input type="file" id="csvFileInput" accept=".csv">
        </div>
    </div>

    <!-- Notification Container (Used for Achievements) -->
    <div id="notification-container"></div>

    <!-- Header (HUD) -->
    <header class="header">
        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">模擬日期</span>
                <span class="hud-value" id="hud-date">--/--/-- --:--</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">帳戶淨值</span>
                <span class="hud-value" id="hud-equity">$10000.00</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">浮動損益</span>
                <span class="hud-value" id="hud-pl">$0.00</span>
            </div>
        </div>
        <div class="hud-right">
            <div class="hud-item">
                <span class="hud-label">花費時間</span>
                <span class="hud-value" id="hud-timer">00:00</span>
            </div>
            <div class="hud-item progress-container">
                <span class="hud-label">挑戰進度</span>
                <div class="progress-bar">
                    <div class="progress-fill" id="hud-progress"></div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        
        <!-- Chart Area -->
        <div class="chart-container">
            <div class="controls">
                <button class="btn btn-primary" id="btnPlayPause">▶️ 播放</button>
                <button class="btn btn-secondary" id="btnStepForward">➡️ 逐K前進</button>
                <div class="speed-selector" id="speedSelector">
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="5">5x</button>
                    <button class="speed-btn" data-speed="20">20x</button>
                    <button class="speed-btn" data-speed="40">40x</button>
                </div>
                <button class="btn btn-secondary" id="btnZoomIn">🔍+</button>
                <button class="btn btn-secondary" id="btnZoomOut">🔍-</button>
                <button class="btn btn-end-game" id="btnEndGame">結束挑戰</button>
            </div>

            <div class="chart-wrap" id="chartWrap">
                <canvas id="chartCanvas"></canvas>
                <div class="chart-overlay" id="chartOverlay">
                    <!-- Position lines -->
                </div>
            </div>
        </div>

        <!-- Sidebar (Trading Panel) -->
        <aside class="sidebar">
            <!-- Hidden Challenge Info (for tutorial access) -->
            <div class="challenge-info" id="challengeInfo">
                <h4>🏆 30天交易挑戰</h4>
                <p>從隨機歷史日期開始，在一個月內盡力獲取最高收益！</p>
            </div>

            <div class="panel-tabs">
                <button class="tab-btn active" data-target="tabOrder">交易</button>
                <button class="tab-btn" data-target="tabPositions">持倉 (<span id="positionsCount">0</span>)</button>
                <button class="tab-btn" data-target="tabHistory">紀錄</button>
            </div>

            <!-- FIX: Added wrapper for proper layout and overflow handling (Bug 2) -->
            <div class="tabs-wrapper">
                <div class="tab-content active" id="tabOrder">
                    <div class="order-grid">
                        
                        <div class="input-group">
                            <label class="input-label">停損 (SL)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="slDown">−</button>
                                <input type="number" class="input-field" id="inputSL" placeholder="價格" step="0.1" min="0">
                                <button class="stepper-btn" id="slUp">+</button>
                            </div>
                            <div class="input-estimate" id="estimateSL"></div>
                        </div>

                        <div class="input-group">
                            <label class="input-label">手數 (Lots)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="lotsDown">−</button>
                                <input type="number" class="input-field" id="inputLots" value="0.10" step="0.01" min="0.01">
                                <button class="stepper-btn" id="lotsUp">+</button>
                            </div>
                            <div class="input-estimate"></div>
                        </div>

                        <div class="input-group">
                            <label class="input-label">停利 (TP)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="tpDown">−</button>
                                <input type="number" class="input-field" id="inputTP" placeholder="價格" step="0.1" min="0">
                                <button class="stepper-btn" id="tpUp">+</button>
                            </div>
                            <div class="input-estimate" id="estimateTP"></div>
                        </div>
                    </div>

                    <div class="trade-actions-grid">
                        <button class="btn btn-trade btn-sell" id="btnSell">賣出</button>
                        <button class="btn btn-trade btn-close-all" id="btnCloseAllTab">全部平倉</button>
                        <button class="btn btn-trade btn-buy" id="btnBuy">買入</button>
                    </div>
                </div>

                <div class="tab-content" id="tabPositions">
                    <div class="positions-list" id="positionsList">
                        <!-- Positions -->
                    </div>
                </div>

                <div class="tab-content" id="tabHistory">
                    <div class="history-list" id="historyList">
                        <!-- History -->
                    </div>
                </div>
            </div>
             <!-- End of wrapper -->
        </aside>
    </div>
    
    <!-- Footer -->
    <footer class="footer">
        本互動遊戲廣告由 <a href="https://www.massenlighten.com/" target="_blank">眾曜智庫</a> 提供
    </footer>

    <!-- Modals -->
    <div class="modal-overlay" id="eventModal">
        <div class="modal-content">
            <h2 class="modal-title" id="eventTitle">⚠️ 重大財經事件</h2>
            <div class="modal-body" id="eventBody" style="text-align: left;">
                <!-- Event details here -->
            </div>
            <button class="btn btn-primary" id="eventContinueBtn">繼續模擬</button>
        </div>
    </div>

    <div class="modal-overlay" id="endGameModal">
        <div class="modal-content">
            <h2 class="modal-title">🎉 挑戰結束！</h2>
            <div class="modal-body" style="text-align: center;">
                <p>您的最終成績：</p>
                <h1 id="finalScore" style="font-size: 36px; margin: 10px 0;">$10000.00</h1>
                <p id="finalRoR" style="font-size: 20px;"></p>
                <p id="finalTime" style="font-size: 16px; color: var(--color-text-secondary);"></p>
                
                <div id="endGameStats" style="text-align: left; margin-top: 20px; padding-top: 10px; border-top: 1px solid var(--color-border);"></div>
                
                <div class="achievements-section" id="achievementsSection">
                    <h3>🏆 已解鎖成就</h3>
                    <ul class="achievements-list" id="achievementsList">
                        <!-- Achievements -->
                    </ul>
                </div>

            </div>
            <a href="https://www.massenlighten.com/soya%E5%A5%B3%E7%A5%9E" target="_blank" class="btn cta-button" id="ctaButton">了解如何取得高分</a>
            <button class="btn btn-secondary" id="restartButton" style="margin-top: 15px;">重新挑戰</button>
        </div>
    </div>

    <!-- Tutorial Elements -->
    <div class="tutorial-highlight hidden" id="tutorialHighlight"></div>
    <div class="tutorial-message hidden" id="tutorialMessage">
        <p id="tutorialText"></p>
        <button class="btn btn-small" id="tutorialNextBtn" style="margin-top: 10px; background-color: white; color: var(--color-primary);">下一步</button>
    </div>

    <script>
        // ============================================================================
        // 專案：XAUUSD 交易模擬 Playable Ad (Rework V6.3 - URGENCY & ANIMATIONS)
        // ============================================================================

        // ----------------------------------------------------------------------------
        // 1. 狀態管理與常數 (State Management & Constants)
        // ----------------------------------------------------------------------------

        const CONFIG = {
            DATA_URL: 'XAUUSD_M15.csv',
            TICK_INTERVAL: 500,
            CHART_PADDING: { top: 20, right: 60, bottom: 30, left: 10 },
            CANDLE_WIDTH_DEFAULT: 8,
            CANDLE_SPACING: 3,
            CONTRACT_SIZE: 100,
            INITIAL_BALANCE: 10000,
            SIMULATION_DURATION_DAYS: 30,
        };

        // UPDATED: New Achievements List (Feature 6)
        const ACHIEVEMENTS = {
            // 1. 新手上路
            FIRST_TRADE: { title: "新手上路", description: "剛開戶就上車，駕照還在影印中", icon: "🚗" },
            // 2. 荷包滿滿
            BIG_WIN: { title: "荷包滿滿", description: "一根長紅，帳戶變胖了！ (單筆獲利>$3000)", icon: "💰" },
            // 3. 忍痛停損
            BIG_LOSS: { title: "忍痛停損", description: "對帳單一打開，我直接見祖先 (單筆虧損>$3000)", icon: "💔" },
            // 4. 財神保佑
            WIN_STREAK_3: { title: "財神保佑", description: "三連紅，今天有神明附身 (連勝3筆)", icon: "🙏" },
            // 5. 這人急了
            LOSS_STREAK_3: { title: "這人急了", description: "每根K棒都能解讀成希望 (連虧3筆)", icon: "😰" },
            // 6. 凹單大師
            HOLD_LOSS_7D: { title: "凹單大師", description: "主力洗我我不怕，我有信仰 (持虧損倉>7天)", icon: "🧱" },
            // 7. 佛系操盤
            HOLD_WIN_7D: { title: "佛系操盤", description: "放著讓它噴，天命流最會賺 (持獲利倉>7天)", icon: "🧘" },
            // 8. 積少成多
            TRADER_10: { title: "積少成多", description: "韭菜每天割一點，主力都感動了 (累計10筆)", icon: "👨‍🌾" },
            // 9. 快槍俠 (Updated condition: 1 hour)
            QUICK_DRAW: { title: "快槍俠", description: "一敲就出場，我盤感來了 (1小時內獲利平倉)", icon: "⚡" },
            // 10. 翻倍！
            DOUBLE_UP: { title: "翻倍！", description: "阿嬤都說你該辭職全職操盤了 (淨值>$20000)", icon: "🚀" },
            // 11. 破產邊緣 (Updated condition: $2000)
            MARGIN_CALL: { title: "破產邊緣", description: "再跌我就要賣腎了啦！(淨值曾低於$2000)", icon: "📉" },
            // 12. 穩健獲利
            CONSISTENT: { title: "穩健獲利", description: "不當沖、不飆股，照樣噴到天花板 (結束時勝率>60%，且至少10筆)", icon: "🎯" },
            
            // NEW ACHIEVEMENTS
            // 13. 信仰之力
            DIAMOND_HANDS_LOSS: { title: "信仰之力", description: "就算跌停，我還是幫它按愛心 (單一虧損部位抱超過 30%虧損還沒出場)", icon: "💖" },
            // 14. 拉回買點
            AVERAGE_DOWN: { title: "拉回買點", description: "每次攤平，內心都默唸老師有交代 (對同一方向加碼 3 次以上)", icon: "📉📈" },
            // 15. 今天盤不好
            BAD_DAY: { title: "今天盤不好", description: "明明賠錢卻能講到像賺錢 (單日虧損交易三次)", icon: "🌧️" },
            // 16. 盤中抽筋
            RUG_PULL: { title: "盤中抽筋", description: "開高進場，收盤哭著關機 (同日內由獲利轉為虧損超過 $2000)", icon: "😱" },
        };


        const state = {
            rawData: [],
            gameData: [],
            isLoading: true,
            isPlaying: false,
            isEnded: false,
            speedMultiplier: 1,
            currentIndex: 0,
            barAnimationProgress: 0,
            balance: CONFIG.INITIAL_BALANCE,
            equity: CONFIG.INITIAL_BALANCE,
            floatingPL: 0,
            openPositions: [],
            tradeHistory: [],
            orderIdCounter: 1,
            chart: {
                canvas: null,
                ctx: null,
                width: 0,
                height: 0,
                viewStartIndex: 0, 
                viewEndIndex: 0,
                minPrice: 0,
                maxPrice: 0,
                candleWidth: CONFIG.CANDLE_WIDTH_DEFAULT,
                candleSpacing: CONFIG.CANDLE_SPACING,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0, // NEW: For mobile touch distance calculation
                dragStartScroll: 0,
                scrollOffset: 0, 
                isCrosshairPinned: false, // NEW: For mobile touch interaction
                pinnedCrosshairPos: { x: 0, y: 0 }, // NEW
            },
            // NEW V6.3: Breakout Detection State
            breakout: {
                isBreakingHigh: false,
                isBreakingLow: false,
                highPrice: -Infinity,
                lowPrice: Infinity,
                lookbackPeriodDays: 7,
            },
            mouse: { x: -1, y: -1, isOverChart: false },
            isMobile: false, // NEW: Detect mobile/touch device
            tutorialActive: false,
            tutorialCompletedOnce: false,
            
            // Game Timer
            gameStartTime: null,
            elapsedTime: 0,
            timerIntervalId: null,

            // Achievements
            unlockedAchievements: new Set(),
            achievementStats: {
                consecutiveWins: 0,
                consecutiveLosses: 0,
                maxEquity: CONFIG.INITIAL_BALANCE,
                minEquity: CONFIG.INITIAL_BALANCE,
                // NEW TRACKERS (Feature 6)
                currentDay: null,
                dailyLossCount: 0,
                dailyMaxPL: 0, // Tracks the maximum P/L (equity - initial balance) reached during the day
            },

            financialEvents: [
                 { triggerDay: 5, title: '美國非農就業數據 (NFP)', description: '非農數據即將公布，市場預期將出現劇烈波動。請注意風險！' },
                { triggerDay: 15, title: '美國 CPI 公布', description: '消費者物價指數 (CPI) 高於預期，可能引發市場對通膨的擔憂。' },
                { triggerDay: 25, title: 'FOMC 利率決議', description: '聯準會即將宣布利率決議。市場普遍預期將維持現有利率。' },
            ],
            triggeredEvents: new Set(),
        };

        const DOM = {};

        // ----------------------------------------------------------------------------
        // 2. 數據處理 (Data Processing)
        // ----------------------------------------------------------------------------

        async function loadData() {
            try {
                const response = await fetch(CONFIG.DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP 錯誤! 狀態碼: ${response.status}`);
                }
                const csvText = await response.text();
                processData(csvText);
            } catch (error) {
                console.error("自動載入數據失敗:", error);
                let errorMessage = error.message;
                if (error instanceof TypeError && window.location.protocol === 'file:') {
                    errorMessage = "無法從本地檔案系統 (file://) 載入數據。這是瀏覽器的安全限制。";
                }
                promptForFileUpload(errorMessage);
            }
        }

        function promptForFileUpload(errorMessage) {
            document.getElementById('loader-status').classList.add('hidden');
            document.getElementById('fileUploadFallback').classList.remove('hidden');
            if (errorMessage) {
                document.getElementById('loader-error-message').textContent = errorMessage;
            }
            
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput.dataset.listenerAttached) return;
            fileInput.dataset.listenerAttached = true;

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const csvText = e.target.result;
                        document.getElementById('fileUploadFallback').classList.add('hidden');
                        document.getElementById('loader-status').classList.remove('hidden');
                        processData(csvText);
                    };
                    reader.readAsText(file, 'UTF-8');
                }
            });
        }

        function processData(csvText) {
            try {
                state.rawData = parseData(csvText);
                if (state.rawData.length === 0) {
                    throw new Error("無法解析數據或數據為空。請檢查 CSV 檔案格式、內容和編碼。");
                }
                startGame();
            } catch (error) {
                console.error("處理數據失敗:", error);
                promptForFileUpload(error.message);
            }
        }

        function parseData(csvText) {
            // ... (parseData implementation remains the same as V6.2)
            if (csvText.charCodeAt(0) === 0xFEFF) {
                csvText = csvText.substring(1);
            }

            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];

            const firstLine = lines.find(line => {
                const lowerLine = line.trim().toLowerCase();
                return lowerLine !== '' && !lowerLine.includes('time') && !lowerLine.includes('open');
            });

            if (!firstLine) return [];

            let delimiter = ',';
            if (firstLine.includes('\t') || (firstLine.includes(' ') && !firstLine.includes(','))) {
                delimiter = /\s+/;
            } else if (firstLine.includes(';')) {
                delimiter = ';';
            }

            const testParts = firstLine.split(delimiter);
            if (testParts.length < 5) return [];

            let timeFormat = 'unknown';
            if (testParts[0].match(/^\d{10,}$/)) {
                timeFormat = 'timestamp';
            } else if (testParts[0].match(/^\d{4}[\.\-\/]\d{2}[\.\-\/]\d{2}$/) && testParts.length > 1 && testParts[1].match(/^\d{2}:\d{2}/)) {
                timeFormat = 'datetime_separate';
            } else if (testParts[0].includes(':') || testParts[0].match(/^\d{4}[\.\-\/]\d{2}[\.\-\/]\d{2}/)) {
                timeFormat = 'datetime_combined';
            }
            
            const parsedData = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '' || line.toLowerCase().includes('open') || line.toLowerCase().includes('time')) continue;

                const values = line.split(delimiter);
                let timestamp, open, high, low, close;

                try {
                    if (timeFormat === 'timestamp') {
                        if (values.length < 5) continue;
                        timestamp = parseInt(values[0]);
                        if (timestamp < 10000000000) timestamp *= 1000;
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    } else if (timeFormat === 'datetime_separate') {
                        if (values.length < 6) continue;
                        const dateStr = `${values[0].replace(/[\.\/]/g, '-')} ${values[1]}`;
                        timestamp = new Date(dateStr).getTime();
                        open = parseFloat(values[2]);
                        high = parseFloat(values[3]);
                        low = parseFloat(values[4]);
                        close = parseFloat(values[5]);
                    } else if (timeFormat === 'datetime_combined') {
                        if (values.length < 5) continue;
                        timestamp = new Date(values[0].replace(/[\.\/]/g, '-')).getTime();
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    } else {
                        continue;
                    }

                    if (isNaN(timestamp) || timestamp <= 0 || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        continue;
                    }

                    parsedData.push({ time: timestamp, open, high, low, close });
                } catch (error) {
                    // Ignore parsing errors
                }
            }

            return parsedData.sort((a, b) => a.time - b.time);
        }

        // ----------------------------------------------------------------------------
        // 3. 遊戲初始化與流程控制 (Game Initialization & Flow Control)
        // ----------------------------------------------------------------------------

        function init() {
            console.log("Initializing application...");
            // NEW: Detect mobile device (simple check for touch support)
            state.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            cacheDOMElements();
            setupEventListeners();
            initChart();
            loadData();
        }

        function cacheDOMElements() {
             // ... (cacheDOMElements implementation remains the same as V6.2)
            // HUD, Controls, Chart
            Object.assign(DOM, {
                hudDate: document.getElementById('hud-date'),
                hudEquity: document.getElementById('hud-equity'),
                hudPL: document.getElementById('hud-pl'),
                hudProgress: document.getElementById('hud-progress'),
                hudTimer: document.getElementById('hud-timer'),
                btnPlayPause: document.getElementById('btnPlayPause'),
                btnStepForward: document.getElementById('btnStepForward'),
                speedSelector: document.getElementById('speedSelector'),
                chartWrap: document.getElementById('chartWrap'),
                chartCanvas: document.getElementById('chartCanvas'),
                chartOverlay: document.getElementById('chartOverlay'),
            });
            // Sidebar Inputs & Lists
            Object.assign(DOM, {
                inputLots: document.getElementById('inputLots'),
                inputSL: document.getElementById('inputSL'),
                inputTP: document.getElementById('inputTP'),
                estimateSL: document.getElementById('estimateSL'),
                estimateTP: document.getElementById('estimateTP'),
                positionsList: document.getElementById('positionsList'),
                historyList: document.getElementById('historyList'),
                positionsCount: document.getElementById('positionsCount'),
                btnCloseAllTab: document.getElementById('btnCloseAllTab'),
            });
            // Modals, Tutorial, Notifications
            Object.assign(DOM, {
                loader: document.getElementById('loader'),
                eventModal: document.getElementById('eventModal'),
                endGameModal: document.getElementById('endGameModal'),
                tutorialHighlight: document.getElementById('tutorialHighlight'),
                tutorialMessage: document.getElementById('tutorialMessage'),
                tutorialText: document.getElementById('tutorialText'),
                tutorialNextBtn: document.getElementById('tutorialNextBtn'),
                notificationContainer: document.getElementById('notification-container'),
            });
        }

        function startGame() {
            if (state.rawData.length === 0) return;

            DOM.endGameModal.classList.remove('active');
            
            resetState();
            selectRandomDataSegment();

            if (state.gameData.length === 0) return;
            
            const initialVisibleCandles = calculateVisibleCandles();
            state.currentIndex = Math.min(Math.floor(initialVisibleCandles * 0.8), state.gameData.length - 1);
            
            // Initialize daily stats based on the starting point
            updateDailyStats();
            updateBreakoutLevels(); // NEW V6.3 Initialize breakout levels

            state.isLoading = false;
            DOM.loader.classList.add('hidden');
            
            startTimer();

            updateUI();
            requestAnimationFrame(draw);

            if (!state.tutorialCompletedOnce) {
                startTutorial();
            }
        }

        
        function resetState() {
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
                state.timerIntervalId = null;
            }

            state.balance = CONFIG.INITIAL_BALANCE;
            state.equity = CONFIG.INITIAL_BALANCE;
            state.floatingPL = 0;
            state.openPositions = [];
            state.tradeHistory = [];
            state.orderIdCounter = 1;
            state.isPlaying = false;
            state.isEnded = false;
            state.currentIndex = 0;
            state.barAnimationProgress = 0;
            state.triggeredEvents.clear();
            state.chart.candleWidth = CONFIG.CANDLE_WIDTH_DEFAULT;
            state.chart.candleSpacing = CONFIG.CANDLE_SPACING;
            state.chart.scrollOffset = 0;
            state.chart.isCrosshairPinned = false; // Reset pinned crosshair
            DOM.chartOverlay.innerHTML = '';
            DOM.positionsList.innerHTML = ''; // Ensure list is cleared
            DOM.historyList.innerHTML = '';

            // Reset Breakout State (V6.3)
            state.breakout.isBreakingHigh = false;
            state.breakout.isBreakingLow = false;
            state.breakout.highPrice = -Infinity;
            state.breakout.lowPrice = Infinity;
            
            // Reset Inputs
            DOM.inputLots.value = "0.10";
            DOM.inputSL.value = "";
            DOM.inputTP.value = "";

            // Reset Timer State
            state.gameStartTime = null;
            state.elapsedTime = 0;
            DOM.hudTimer.textContent = "00:00";

            // Reset Achievements
            state.unlockedAchievements.clear();
            state.achievementStats = {
                consecutiveWins: 0,
                consecutiveLosses: 0,
                maxEquity: CONFIG.INITIAL_BALANCE,
                minEquity: CONFIG.INITIAL_BALANCE,
                // NEW TRACKERS RESET
                currentDay: null,
                dailyLossCount: 0,
                dailyMaxPL: 0,
            };
        }

        function selectRandomDataSegment() {
             // ... (selectRandomDataSegment implementation remains the same as V6.2)
            const totalDurationMs = CONFIG.SIMULATION_DURATION_DAYS * 24 * 60 * 60 * 1000;
            
            if (state.rawData.length === 0) return;

            const dataDuration = state.rawData[state.rawData.length - 1].time - state.rawData[0].time;

            if (dataDuration < totalDurationMs) {
                state.gameData = [...state.rawData];
                return;
            }

            const latestStartTime = state.rawData[state.rawData.length - 1].time - totalDurationMs;
            const earliestStartTime = state.rawData[0].time;
            const randomStartTime = earliestStartTime + Math.random() * (latestStartTime - earliestStartTime);

            let startIndex = state.rawData.findIndex(d => d.time >= randomStartTime);
            if (startIndex === -1) startIndex = 0;

            const startTime = state.rawData[startIndex].time;
            const endTime = startTime + totalDurationMs;

            state.gameData = state.rawData.filter(d => d.time >= startTime && d.time <= endTime);
        }


        let lastTickTime = 0;
        let animationFrameId;

        function gameLoop(timestamp) {
            if (!state.isPlaying || state.isEnded) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const effectiveInterval = CONFIG.TICK_INTERVAL / state.speedMultiplier;
            if (lastTickTime === 0) lastTickTime = timestamp;
            const deltaTime = timestamp - lastTickTime;

             if (deltaTime > 0) { 
                 const progressIncrement = deltaTime / effectiveInterval;
                 state.barAnimationProgress = Math.min(1, state.barAnimationProgress + progressIncrement);
                 
                 checkBreakouts(); // NEW V6.3: Check breakouts during animation
                 updateDailyStats(); // NEW: Update stats continuously
                 updatePositions();
                 updateAccount();
                 updateUI(); 

                 checkDurationAchievements();
                 checkDrawdownAchievement(); // NEW: Check RUG_PULL continuously

                 if (state.barAnimationProgress >= 1) {
                    finalizeCurrentBar();
                    if (!advanceSimulation()) {
                        endGame();
                        return;
                    }
                    state.barAnimationProgress = 0;
                    checkForEvents();
                    
                    if (state.chart.scrollOffset > 0) {
                        state.chart.scrollOffset++;
                    }
                 }
                 lastTickTime = timestamp;
            }
            
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function finalizeCurrentBar() {
            state.barAnimationProgress = 1;
            updatePositions();
            updateAccount();
        }

        function advanceSimulation() {
            if (state.currentIndex < state.gameData.length - 1) {
                state.currentIndex++;
                updateDailyStats(); // NEW: Update stats on step forward
                updateBreakoutLevels(); // NEW V6.3: Update levels for the new bar
                return true;
            }
            return false;
        }

        function endGame() {
            // ... (endGame implementation remains the same as V6.2)
            if (state.isEnded) return;

            console.log("Game Ended.");
            state.isPlaying = false;
            state.isEnded = true;
            cancelAnimationFrame(animationFrameId);

            stopTimer();
            
            // Close remaining positions
            if (state.gameData.length > 0) {
                let closeIndex = state.currentIndex;
                if (closeIndex >= state.gameData.length) {
                    closeIndex = state.gameData.length - 1;
                }
                const closePrice = state.gameData[closeIndex].close;

                while(state.openPositions.length > 0) {
                    // Ensure final trades count towards achievements (skipAchievementCheck=false)
                    closeOrder(state.openPositions[0].id, closePrice, false); 
                }
            }

            checkFinalAchievements();

            updateAccount();
            updateUI();
            showEndGameModal();
        }

        // Timer Functions
        function startTimer() {
            // ... (startTimer implementation remains the same as V6.2)
            state.gameStartTime = Date.now();
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
            }
            state.timerIntervalId = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            // ... (updateTimer implementation remains the same as V6.2)
            if (state.gameStartTime && !state.isEnded) {
                state.elapsedTime = Math.floor((Date.now() - state.gameStartTime) / 1000);
                const minutes = Math.floor(state.elapsedTime / 60);
                const seconds = state.elapsedTime % 60;
                DOM.hudTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function stopTimer() {
            // ... (stopTimer implementation remains the same as V6.2)
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
                state.timerIntervalId = null;
            }
        }


        // ----------------------------------------------------------------------------
        // 4. 圖表繪製與渲染 (Chart Drawing & Rendering)
        // ----------------------------------------------------------------------------
        
        function initChart() {
            state.chart.canvas = DOM.chartCanvas;
            state.chart.ctx = state.chart.canvas.getContext('2d');
            resizeCanvas();
        }

        function resizeCanvas() {
            // ... (resizeCanvas implementation remains the same as V6.2)
            const dpr = window.devicePixelRatio || 1;
            const rect = DOM.chartWrap.getBoundingClientRect();
            const width = Math.max(1, Math.floor(rect.width));
            const height = Math.max(1, Math.floor(rect.height));

            if (state.chart.width !== width || state.chart.height !== height) {
                state.chart.canvas.width = width * dpr;
                state.chart.canvas.height = height * dpr;
                state.chart.canvas.style.width = `${width}px`;
                state.chart.canvas.style.height = `${height}px`;

                state.chart.ctx.scale(dpr, dpr);
                state.chart.width = width;
                state.chart.height = height;

                validateScrollOffset();
            }

            if (!state.isLoading) {
                draw();
            }
        }

        function draw() {
            if (state.isLoading || state.gameData.length === 0) return;

            const ctx = state.chart.ctx;
            ctx.clearRect(0, 0, state.chart.width, state.chart.height);

            calculateViewport();

            drawBackground(ctx);
            drawGrid(ctx);
            drawCandles(ctx);
            drawYAxis(ctx);
            drawXAxis(ctx);
            drawCrosshair(ctx);
            drawTradeAnimations(ctx);
            drawBreakoutAnimations(ctx); // NEW V6.3
            
            updatePositionOverlays();
        }

         function calculateVisibleCandles() {
            // ... (calculateVisibleCandles implementation remains the same as V6.2)
            const { width, candleWidth, candleSpacing } = state.chart;
            const { left, right } = CONFIG.CHART_PADDING;
            const chartAreaWidth = width - left - right;
            const candleUnitWidth = candleWidth + candleSpacing;
            if (candleUnitWidth <= 0) return 100;
            return Math.max(1, Math.floor(chartAreaWidth / candleUnitWidth));
        }

        function calculateViewport() {
            // ... (calculateViewport implementation remains the same as V6.2)
            const visibleCandles = calculateVisibleCandles();

            let endIndex = state.currentIndex + 1 - state.chart.scrollOffset;
            let startIndex = endIndex - visibleCandles;

            if (endIndex > state.currentIndex + 1) {
                endIndex = state.currentIndex + 1;
                startIndex = Math.max(0, endIndex - visibleCandles);
            }
            if (startIndex < 0) {
                startIndex = 0;
                endIndex = Math.min(state.currentIndex + 1, startIndex + visibleCandles);
            }
            
            state.chart.viewStartIndex = startIndex;
            state.chart.viewEndIndex = endIndex;

            // Calculate Price Range
            let minPrice = Infinity;
            let maxPrice = -Infinity;

            for (let i = startIndex; i < endIndex; i++) {
                if (i >= state.gameData.length || i < 0) continue; 

                const bar = state.gameData[i];

                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    const animatedBar = getAnimatedBar(bar);
                    minPrice = Math.min(minPrice, animatedBar.low);
                    maxPrice = Math.max(maxPrice, animatedBar.high);
                } else {
                    minPrice = Math.min(minPrice, bar.low);
                    maxPrice = Math.max(maxPrice, bar.high);
                }
            }

            // Add padding to price range
            const priceRange = maxPrice - minPrice;
            if (priceRange <= 0 || !isFinite(priceRange)) {
                const centerPrice = (minPrice === Infinity) ? (state.gameData[0]?.close || 1900) : minPrice;
                const padding = centerPrice * 0.001;
                state.chart.minPrice = centerPrice - padding;
                state.chart.maxPrice = centerPrice + padding;
            } else {
                const padding = priceRange * 0.1;
                state.chart.minPrice = minPrice - padding;
                state.chart.maxPrice = maxPrice + padding;
            }
        }


        // 座標轉換工具
        function priceToY(price) {
            // ... (priceToY implementation remains the same as V6.2)
            const { height, minPrice, maxPrice } = state.chart;
            const { top, bottom } = CONFIG.CHART_PADDING;
            const chartAreaHeight = height - top - bottom;
            const priceRange = maxPrice - minPrice;
            
            if (chartAreaHeight <= 0 || priceRange <= 0) return top + chartAreaHeight / 2;

            const y = top + chartAreaHeight * (1 - (price - minPrice) / priceRange);
            return Math.max(top, Math.min(height - bottom, y));
        }

        function yToPrice(y) {
            // ... (yToPrice implementation remains the same as V6.2)
            const { height, minPrice, maxPrice } = state.chart;
            const { top, bottom } = CONFIG.CHART_PADDING;
            const chartAreaHeight = height - top - bottom;
            const priceRange = maxPrice - minPrice;

            if (chartAreaHeight <= 0) return (minPrice + maxPrice) / 2;

            const constrainedY = Math.max(top, Math.min(height - bottom, y));
            
            const price = minPrice + priceRange * (1 - (constrainedY - top) / chartAreaHeight);
            return price;
        }

        function indexToX(index) {
            // ... (indexToX implementation remains the same as V6.2)
            const { viewStartIndex, candleWidth, candleSpacing } = state.chart;
            const { left } = CONFIG.CHART_PADDING;
            const candleUnitWidth = candleWidth + candleSpacing;
            return left + (index - viewStartIndex) * candleUnitWidth + candleWidth / 2;
        }

        // Drawing Functions Implementation
        function drawBackground(ctx) {
            // ... (drawBackground implementation remains the same as V6.2)
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(0, 0, state.chart.width, state.chart.height);
        }

        function drawGrid(ctx) {
            // ... (drawGrid implementation remains the same as V6.2)
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim();
            const dateSeparatorColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-date-separator').trim();
            const { left, right, top, bottom } = CONFIG.CHART_PADDING;

            // 1. Horizontal Grid Lines
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            const yTicks = calculateYAxisTicks();
            yTicks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.beginPath();
                ctx.moveTo(left, y);
                ctx.lineTo(state.chart.width - right, y);
                ctx.stroke();
            });

            // 2. Vertical Grid Lines & Date Separators
            const xTicks = calculateXAxisTicks();
            xTicks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= left && x <= state.chart.width - right) {
                    
                    if (tick.isDateSeparator) {
                        ctx.strokeStyle = dateSeparatorColor;
                        ctx.lineWidth = 1.5;
                    } else {
                        ctx.strokeStyle = gridColor;
                        ctx.lineWidth = 1;
                    }

                    ctx.beginPath();
                    ctx.moveTo(x, top);
                    ctx.lineTo(x, state.chart.height - bottom);
                    ctx.stroke();
                }
            });
            
            ctx.lineWidth = 1;
        }

        function getAnimatedBar(bar) {
            // ... (getAnimatedBar implementation remains the same as V6.2)
            const progress = state.barAnimationProgress;
            const open = bar.open;
            
            const wickProgress = Math.min(1, progress * 2);
            const high = open + (bar.high - open) * wickProgress;
            const low = open + (bar.low - open) * wickProgress;

            const close = open + (bar.close - open) * progress;

            const finalHigh = Math.max(high, close, open);
            const finalLow = Math.min(low, close, open);

            return { open, high: finalHigh, low: finalLow, close };
        }

        function drawCandles(ctx) {
            // ... (drawCandles implementation remains the same as V6.2)
            const { viewStartIndex, viewEndIndex, candleWidth } = state.chart;
            const colorBull = getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim();
            const colorBear = getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                 if (i >= state.gameData.length || i < 0) continue;

                const bar = state.gameData[i];
                let displayBar = bar;

                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    displayBar = getAnimatedBar(bar);
                }

                const x = indexToX(i);
                const openY = priceToY(displayBar.open);
                const highY = priceToY(displayBar.high);
                const lowY = priceToY(displayBar.low);
                const closeY = priceToY(displayBar.close);

                const color = displayBar.close >= displayBar.open ? colorBull : colorBear;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;

                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(openY - closeY);
                
                const finalHeight = Math.max(1, bodyHeight);
                const finalWidth = Math.max(1, candleWidth);

                ctx.fillRect(x - finalWidth / 2, bodyTop, finalWidth, finalHeight);
            }
        }

        function calculateYAxisTicks() {
            // ... (calculateYAxisTicks implementation remains the same as V6.2)
            const { minPrice, maxPrice, height } = state.chart;
            const priceRange = maxPrice - minPrice;
            if (priceRange <= 0) return [];
            const targetCount = Math.max(2, Math.floor(height / 50));
            const rawSpacing = priceRange / targetCount;
            const magnitude = Math.pow(10, Math.floor(Math.log10(rawSpacing)));
            const normalizedSpacing = rawSpacing / magnitude;

            let tickSpacing;
            if (normalizedSpacing > 5) tickSpacing = 10 * magnitude;
            else if (normalizedSpacing > 2) tickSpacing = 5 * magnitude;
            else if (normalizedSpacing > 1) tickSpacing = 2 * magnitude;
            else tickSpacing = magnitude;

            const ticks = [];
            let currentTick = Math.ceil(minPrice / tickSpacing) * tickSpacing;

            while (currentTick <= maxPrice) {
                if (isFinite(currentTick)) {
                    ticks.push({ price: currentTick });
                }
                currentTick += tickSpacing;
                if (tickSpacing === 0) break;
            }
            return ticks;
        }

        function drawYAxis(ctx) {
            // ... (drawYAxis implementation remains the same as V6.2)
            const { width, height } = state.chart;
            const { right } = CONFIG.CHART_PADDING;
            const axisX = width - right;

            // Draw axis background and border
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(axisX, 0, right, height);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
            ctx.beginPath();
            ctx.moveTo(axisX, 0);
            ctx.lineTo(axisX, height);
            ctx.stroke();

            // Draw ticks
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            const ticks = calculateYAxisTicks();
            ticks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.fillText(tick.price.toFixed(2), axisX + 5, y);
            });

            // Draw current price indicator (Only if crosshair is NOT active and not pinned)
            const isCrosshairActive = (state.mouse.isOverChart || state.chart.isCrosshairPinned) && !state.chart.isDragging;

            if (state.currentIndex < state.gameData.length && state.chart.scrollOffset === 0 && !isCrosshairActive) {
                const currentPrice = getCurrentPrice();
                const currentY = priceToY(currentPrice);
                
                const color = currentPrice >= state.gameData[state.currentIndex].open 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim()
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();

                ctx.fillStyle = color;
                ctx.fillRect(axisX + 1, currentY - 10, right - 1, 20);
                
                ctx.fillStyle = 'white';
                ctx.fillText(currentPrice.toFixed(2), axisX + 5, currentY);
            }
        }

        function calculateXAxisTicks() {
            // ... (calculateXAxisTicks implementation remains the same as V6.2)
            const { viewStartIndex, viewEndIndex, width } = state.chart;
            if (viewEndIndex <= viewStartIndex || viewStartIndex >= state.gameData.length) return [];

            const targetCount = Math.max(2, Math.floor(width / 100));
            const visibleCandles = viewEndIndex - viewStartIndex;
            const interval = Math.max(1, Math.round(visibleCandles / targetCount));

            const ticks = [];
            let lastDateStr = null;

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                if (i < 0 || i >= state.gameData.length) continue; // Safety check

                const time = state.gameData[i].time;
                const currentDate = new Date(time);
                const currentDateStr = currentDate.toDateString(); 

                let isDateSeparator = false;
                if (lastDateStr !== null && currentDateStr !== lastDateStr) {
                    isDateSeparator = true;
                }
                lastDateStr = currentDateStr;

                if (isDateSeparator || (i - viewStartIndex) % interval === 0) {
                     if (!ticks.some(t => t.index === i)) {
                        ticks.push({ index: i, time: time, isDateSeparator: isDateSeparator });
                     }
                }
            }
            return ticks;
        }

        function drawXAxis(ctx) {
            // ... (drawXAxis implementation remains the same as V6.2)
            const { width, height } = state.chart;
            const { bottom, right, left } = CONFIG.CHART_PADDING;
            const axisY = height - bottom;

            // Draw axis background and border
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(0, axisY, width, bottom);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(width - right, axisY);
            ctx.stroke();

            // Draw ticks
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const ticks = calculateXAxisTicks();
            
            let timeDiff = 0;
            if (state.chart.viewEndIndex > state.chart.viewStartIndex && state.gameData.length > 0) {
                 // Safety check for indices
                const startIndex = Math.max(0, state.chart.viewStartIndex);
                const endIndex = Math.min(state.gameData.length - 1, state.chart.viewEndIndex - 1);
                
                if (endIndex >= startIndex) {
                    timeDiff = state.gameData[endIndex].time - state.gameData[startIndex].time;
                }
            }

            ticks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= left && x <= width - right) {
                    const date = new Date(tick.time);
                    
                    let label;
                    
                    if (tick.isDateSeparator) {
                         label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' });
                         ctx.font = 'bold 12px sans-serif'; 
                    } else {
                        ctx.font = '12px sans-serif';
                        if (timeDiff < 48 * 3600 * 1000) {
                            label = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                        } else {
                            label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' });
                        }
                    }
                    
                    ctx.fillText(label, x, axisY + 5);
                }
            });
        }

        // Draw Crosshair (Handles both mouse hover and pinned touch)
        function drawCrosshair(ctx) {
            // ... (drawCrosshair implementation remains the same as V6.2)
            if (state.chart.isDragging) return;

            let x, y;

            // Determine crosshair source (Pinned or Mouse)
            if (state.chart.isCrosshairPinned) {
                x = state.chart.pinnedCrosshairPos.x;
                y = state.chart.pinnedCrosshairPos.y;
            } else if (state.mouse.isOverChart) {
                x = state.mouse.x;
                y = state.mouse.y;
            } else {
                return; // No source, don't draw
            }

            const { left, right, top, bottom } = CONFIG.CHART_PADDING;
            const { width, height } = state.chart;

            // Boundary check
            if (x < left || x > width - right || y < top || y > height - bottom) return;

            const crosshairColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-crosshair').trim();
            ctx.strokeStyle = crosshairColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(width - right, y);
            ctx.stroke();

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, height - bottom);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw Price Label
            const crosshairPrice = yToPrice(y);
            const axisX = width - right;

            ctx.fillStyle = crosshairColor;
            ctx.fillRect(axisX + 1, y - 10, right - 1, 20);
            
            ctx.fillStyle = 'white'; 
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(crosshairPrice.toFixed(2), axisX + 5, y);
        }

        function updatePositionOverlays() {
            // ... (updatePositionOverlays implementation remains the same as V6.2)
            const overlay = DOM.chartOverlay;
            const linesToKeep = new Set();

            state.openPositions.forEach(pos => {
                const entryId = `line-entry-${pos.id}`;
                const slId = `line-sl-${pos.id}`;
                const tpId = `line-tp-${pos.id}`;
                
                // 進場線
                const entryColor = pos.type === 'BUY' ? 'var(--color-bull)' : 'var(--color-bear)';
                createOrUpdatePositionLine(overlay, entryId, pos.entryPrice, entryColor, `進場價 ${pos.entryPrice.toFixed(2)}`, pos);
                linesToKeep.add(entryId);

                // SL 線
                if (pos.sl) {
                    const potentialPL = calculateProfit(pos, pos.sl);
                    createOrUpdatePositionLine(overlay, slId, pos.sl, 'var(--color-danger)', `停損 ${pos.sl.toFixed(2)}`, null, potentialPL);
                    linesToKeep.add(slId);
                }

                // TP 線
                if (pos.tp) {
                    const potentialPL = calculateProfit(pos, pos.tp);
                    createOrUpdatePositionLine(overlay, tpId, pos.tp, 'var(--color-success)', `停利 ${pos.tp.toFixed(2)}`, null, potentialPL);
                    linesToKeep.add(tpId);
                }
            });

            Array.from(overlay.children).forEach(child => {
                if (child.classList.contains('position-line') && !linesToKeep.has(child.id)) {
                    overlay.removeChild(child);
                }
            });
        }

        function createOrUpdatePositionLine(container, id, price, color, labelText, position = null, potentialPL = null) {
            // ... (createOrUpdatePositionLine implementation remains the same as V6.2)
            let line = document.getElementById(id);
            if (!line) {
                line = document.createElement('div');
                line.id = id;
                line.className = 'position-line';
                
                // Layout: [Label] [P/L Display] [Dash]

                const label = document.createElement('div');
                label.className = 'position-label';
                line.appendChild(label); // 1. Label

                const plDisplay = document.createElement('div');
                plDisplay.className = 'position-pl';
                line.appendChild(plDisplay); // 2. P/L Display

                const dash = document.createElement('div');
                dash.className = 'position-line-dash';
                line.appendChild(dash); // 3. Dash

                container.appendChild(line);
            }

            const y = priceToY(price);
            
            // Visibility check
            if (y < CONFIG.CHART_PADDING.top || y > state.chart.height - CONFIG.CHART_PADDING.bottom) {
                line.style.opacity = 0;
            } else {
                line.style.opacity = 1;
                line.style.top = `${y - 10}px`; // Center vertically
            }
            
            line.style.width = `calc(100% - ${CONFIG.CHART_PADDING.right}px)`;

            // 更新內容和樣式
            const dash = line.querySelector('.position-line-dash');
            dash.style.borderTopColor = color;

            const label = line.querySelector('.position-label');
            label.style.backgroundColor = color;
            label.textContent = labelText;

            // 更新損益顯示
            const plDisplay = line.querySelector('.position-pl');
            let displayValue = null;

            if (position) {
                displayValue = position.profit;
            } else if (potentialPL !== null) {
                displayValue = potentialPL;
            }

            if (displayValue !== null) {
                plDisplay.textContent = `$${displayValue.toFixed(2)}`;
                plDisplay.style.color = displayValue >= 0 ? 'var(--color-success)' : 'var(--color-danger';
                plDisplay.style.display = 'block';
            } else {
                plDisplay.style.display = 'none';
            }
        }

        const tradeAnimations = [];
        const breakoutAnimations = []; // NEW V6.3

        function addTradeAnimation(type, price, index, profit = 0) {
            tradeAnimations.push({
                type,
                price,
                index,
                profit,
                startTime: performance.now(),
                duration: type === 'CLOSE' ? 1500 : 800,
            });
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        // NEW V6.3: Add breakout animation
        function addBreakoutAnimation(type, price, index) {
            // Prevent spamming animations if one is already running for this type very recently
            const MIN_INTERVAL = 1000; // Minimum 1 second between animations of the same type
            if (breakoutAnimations.some(a => a.type === type && performance.now() - a.startTime < MIN_INTERVAL)) {
                return;
            }

            breakoutAnimations.push({
                type, // 'HIGH' or 'LOW'
                price,
                index,
                startTime: performance.now(),
                duration: 2000, // Lasts 2 seconds
            });
            // No need to force draw if playing, gameLoop handles it.
             if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function drawTradeAnimations(ctx) {
            // ... (drawTradeAnimations implementation remains the same as V6.2)
            const now = performance.now();
            let animationsRunning = false;

            for (let i = tradeAnimations.length - 1; i >= 0; i--) {
                const anim = tradeAnimations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);
                
                const opacity = 1 - progress;

                const x = indexToX(anim.index);
                const y = priceToY(anim.price);

                if (x < CONFIG.CHART_PADDING.left || x > state.chart.width - CONFIG.CHART_PADDING.right) {
                     if (progress >= 1) {
                        tradeAnimations.splice(i, 1);
                    } else {
                        animationsRunning = true;
                    }
                    continue;
                }

                ctx.globalAlpha = opacity;

                if (anim.type === 'BUY' || anim.type === 'SELL') {
                    const color = anim.type === 'BUY' ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();
                    ctx.fillStyle = color;
                    
                    const size = 12 + progress * 5; 
                    const offsetY = anim.type === 'BUY' ? 15 : -15;
                    
                    ctx.beginPath();
                    if (anim.type === 'BUY') {
                        ctx.moveTo(x, y + offsetY);
                        ctx.lineTo(x - size/2, y + offsetY + size);
                        ctx.lineTo(x + size/2, y + offsetY + size);
                    } else {
                        ctx.moveTo(x, y + offsetY);
                        ctx.lineTo(x - size/2, y + offsetY - size);
                        ctx.lineTo(x + size/2, y + offsetY - size);
                    }
                    ctx.closePath();
                    ctx.fill();

                } else if (anim.type === 'CLOSE') {
                    const color = anim.profit >= 0 ? getComputedStyle(document.documentElement).getPropertyValue('--color-success').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim();
                    ctx.fillStyle = color;
                    ctx.font = 'bold 18px sans-serif';
                    ctx.textAlign = 'center';
                    
                    const floatY = y - progress * 60; 
                    ctx.fillText(`$${anim.profit.toFixed(2)}`, x, floatY);
                }

                ctx.globalAlpha = 1;

                if (progress >= 1) {
                    tradeAnimations.splice(i, 1);
                } else {
                    animationsRunning = true;
                }
            }

            if (animationsRunning && !state.isPlaying) {
                requestAnimationFrame(draw); 
            }
        }

        // NEW V6.3: Draw breakout animations on the chart
        function drawBreakoutAnimations(ctx) {
            const now = performance.now();
            let animationsRunning = false;

            const colorHigh = getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim();
            const colorLow = getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();

            for (let i = breakoutAnimations.length - 1; i >= 0; i--) {
                const anim = breakoutAnimations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);
                
                // Fade out in the last 25% of the duration
                const opacity = progress > 0.75 ? (1 - progress) * 4 : 1;

                const x = indexToX(anim.index);
                // Use the actual animated price for the Y coordinate if viewing the current bar
                let y;
                if (anim.index === state.currentIndex && state.chart.scrollOffset === 0 && state.currentIndex < state.gameData.length) {
                    const animatedBar = getAnimatedBar(state.gameData[state.currentIndex]);
                    y = priceToY(anim.type === 'HIGH' ? animatedBar.high : animatedBar.low);
                } else {
                    y = priceToY(anim.price);
                }


                // Check visibility
                if (x < CONFIG.CHART_PADDING.left || x > state.chart.width - CONFIG.CHART_PADDING.right ||
                    y < CONFIG.CHART_PADDING.top || y > state.chart.height - CONFIG.CHART_PADDING.bottom) {
                     if (progress >= 1) {
                        breakoutAnimations.splice(i, 1);
                    } else {
                        animationsRunning = true;
                    }
                    continue;
                }

                const color = anim.type === 'HIGH' ? colorHigh : colorLow;
                
                // 1. Radiating Circle
                // Opacity fades faster for the circle
                ctx.globalAlpha = opacity * (1-progress); 

                const radius = progress * 60;
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 2. Text Label
                // Opacity based on time left for the text
                ctx.globalAlpha = opacity; 

                const text = anim.type === 'HIGH' ? '📈 7日新高!' : '📉 7日新低!';
                ctx.font = 'bold 22px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Position text slightly offset
                const textY = anim.type === 'HIGH' ? y - 40 : y + 40;

                // Text shadow/outline for better visibility
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.strokeText(text, x, textY);
                
                ctx.fillStyle = color;
                ctx.fillText(text, x, textY);

                // Reset context properties
                ctx.globalAlpha = 1;

                if (progress >= 1) {
                    breakoutAnimations.splice(i, 1);
                } else {
                    animationsRunning = true;
                }
            }

            if (animationsRunning && !state.isPlaying) {
                requestAnimationFrame(draw); 
            }
        }


        // ----------------------------------------------------------------------------
        // 5. 交易邏輯與帳戶管理 (Trading Logic & Account Management)
        // ----------------------------------------------------------------------------

        function getCurrentPrice() {
            if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return 0;
            const currentBar = state.gameData[state.currentIndex];
            return getAnimatedBar(currentBar).close;
        }

         function openOrder(type, lots, sl = null, tp = null) {
            // ... (openOrder implementation remains the same as V6.2)
            if (state.isEnded || state.gameData.length === 0) return;

            const entryPrice = getCurrentPrice();

            if (entryPrice <= 0) return;

            // Validation
            if (type === 'BUY') {
                if (sl && sl >= entryPrice) {
                    alert("買單 (BUY) 的停損價格 (SL) 必須低於進場價格。");
                    return;
                }
                if (tp && tp <= entryPrice) {
                    alert("買單 (BUY) 的停利價格 (TP) 必須高於進場價格。");
                    return;
                }
            } else { // SELL
                if (sl && sl <= entryPrice) {
                    alert("賣單 (SELL) 的停損價格 (SL) 必須高於進場價格。");
                    return;
                }
                if (tp && tp >= entryPrice) {
                    alert("賣單 (SELL) 的停利價格 (TP) 必須低於進場價格。");
                    return;
                }
            }

            const position = {
                id: state.orderIdCounter++,
                type: type,
                lots: lots,
                entryPrice: entryPrice,
                entryTime: state.gameData[state.currentIndex].time,
                sl: sl,
                tp: tp,
                profit: 0,
            };

            // NEW: Achievement Check - 14. 拉回買點 (AVERAGE_DOWN)
            const sameTypeCount = state.openPositions.filter(p => p.type === type).length;
            if (sameTypeCount + 1 >= 3) {
                unlockAchievement('AVERAGE_DOWN');
            }

            state.openPositions.push(position);

            addTradeAnimation(type, entryPrice, state.currentIndex);

            updateAccount();
            updateUI();
             if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function closeOrder(id, closePrice, skipAchievementCheck = false) {
            // ... (closeOrder implementation remains the same as V6.2)
            const index = state.openPositions.findIndex(p => p.id === id);
            if (index === -1) return;

            const position = state.openPositions[index];
            const profit = calculateProfit(position, closePrice);

            state.balance += profit;
            
            // Determine close time safely
            let closeTime;
            if (state.gameData && state.gameData.length > 0) {
                let closeIndex = state.currentIndex;
                if (closeIndex >= state.gameData.length) {
                    closeIndex = state.gameData.length - 1;
                }
                closeTime = state.gameData[closeIndex].time;
            } else {
                closeTime = position.entryTime;
            }

            const historyEntry = {
                ...position,
                closePrice: closePrice,
                closeTime: closeTime,
                profit: profit,
            };
            state.tradeHistory.push(historyEntry);
            
            state.openPositions.splice(index, 1);

            // Update achievement stats and check achievements
            if (!skipAchievementCheck) {
                updateAchievementStats(historyEntry);
                checkTradeAchievements(historyEntry);
            }

            addTradeAnimation('CLOSE', closePrice, Math.min(state.currentIndex, state.gameData.length - 1), profit);

            updateAccount();
            updateUI();
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }
         
         function calculateProfit(position, currentPrice) {
            // ... (calculateProfit implementation remains the same as V6.2)
            let priceDiff = 0;
            if (position.type === 'BUY') {
                priceDiff = currentPrice - position.entryPrice;
            } else { // SELL
                priceDiff = position.entryPrice - currentPrice;
            }
            return priceDiff * CONFIG.CONTRACT_SIZE * position.lots;
        }

         function updatePositions() {
            // ... (updatePositions implementation remains the same as V6.2)
            if (state.currentIndex >= state.gameData.length || state.gameData.length === 0) return;

            const currentBar = state.gameData[state.currentIndex];
            const animatedBar = getAnimatedBar(currentBar);
            
            const currentPrice = animatedBar.close;
            const currentHigh = animatedBar.high;
            const currentLow = animatedBar.low;

            const positionsToClose = [];

            // Iterate over a copy because closeOrder modifies state.openPositions if triggered
            [...state.openPositions].forEach(pos => {
                // Check if position still exists (might have been closed by SL/TP already in this loop)
                // We use find by ID because the 'pos' object reference might be stale if updates happened
                if (!state.openPositions.find(p => p.id === pos.id)) return;

                pos.profit = calculateProfit(pos, currentPrice);

                // NEW: Achievement Check - 13. 信仰之力 (DIAMOND_HANDS_LOSS)
                if (pos.profit < 0) {
                    // Calculate loss percentage relative to the position value (Price * Size * Lots)
                    const positionValue = pos.entryPrice * CONFIG.CONTRACT_SIZE * pos.lots;
                    if (positionValue > 0) {
                        const lossPercentage = (Math.abs(pos.profit) / positionValue) * 100;
                        if (lossPercentage > 30) {
                            unlockAchievement('DIAMOND_HANDS_LOSS');
                        }
                    }
                }

                // Check SL/TP
                if (pos.type === 'BUY') {
                    if (pos.sl && currentLow <= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } 
                    // Use 'else if' to prevent SL and TP triggering on the same tick if they are very close
                    else if (pos.tp && currentHigh >= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                } else { // SELL
                    if (pos.sl && currentHigh >= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } 
                    else if (pos.tp && currentLow <= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                }
            });

            // Process closures uniquely
            const closedIds = new Set();
            positionsToClose.forEach(order => {
                if (!closedIds.has(order.id)) {
                    closeOrder(order.id, order.price);
                    closedIds.add(order.id);
                }
            });
        }

        function updateAccount() {
            // ... (updateAccount implementation remains the same as V6.2)
            state.floatingPL = state.openPositions.reduce((sum, pos) => sum + pos.profit, 0);
            state.equity = state.balance + state.floatingPL;

            // Track equity extremes
            if (state.equity > state.achievementStats.maxEquity) {
                state.achievementStats.maxEquity = state.equity;
            }
            if (state.equity < state.achievementStats.minEquity) {
                state.achievementStats.minEquity = state.equity;
            }

            checkEquityAchievements();
        }

        // ----------------------------------------------------------------------------
        // 6. UI 更新與互動 (UI Updates & Interaction)
        // ----------------------------------------------------------------------------

         function updateUI() {
            updateHUD();
            updatePositionsPanel();
            updateHistoryPanel();
            updateControls();
            updateOrderPanel();
        }

         function updateOrderPanel() {
            // ... (updateOrderPanel implementation remains the same as V6.2)
            const hasPositions = state.openPositions.length > 0;
            DOM.btnCloseAllTab.disabled = !hasPositions || state.isEnded;
            
            updateEstimatedPL();
        }

         function updateEstimatedPL() {
            // ... (updateEstimatedPL implementation remains the same as V6.2)
            const lots = parseFloat(DOM.inputLots.value);
            const slPrice = parseFloat(DOM.inputSL.value);
            const tpPrice = parseFloat(DOM.inputTP.value);
            const currentPrice = getCurrentPrice();

            DOM.estimateSL.textContent = '';
            DOM.estimateTP.textContent = '';

            if (isNaN(lots) || lots <= 0 || currentPrice <= 0) {
                return;
            }

            // SL 估算
            if (!isNaN(slPrice) && slPrice > 0) {
                const slDistance = Math.abs(currentPrice - slPrice);
                const slPL = slDistance * CONFIG.CONTRACT_SIZE * lots;
                DOM.estimateSL.textContent = `預估損失: -$${slPL.toFixed(2)}`;
            }

            // TP 估算
            if (!isNaN(tpPrice) && tpPrice > 0) {
                const tpDistance = Math.abs(currentPrice - tpPrice);
                const tpPL = tpDistance * CONFIG.CONTRACT_SIZE * lots;
                DOM.estimateTP.textContent = `預估獲利: +$${tpPL.toFixed(2)}`;
            }
        }
        
        function updateHUD() {
            // ... (updateHUD implementation remains the same as V6.2)
            if (state.gameData.length === 0) return;

            let displayIndex = state.currentIndex;
            if (displayIndex >= state.gameData.length) {
                displayIndex = state.gameData.length - 1;
            }

            if (displayIndex < 0) return;

            const currentDate = new Date(state.gameData[displayIndex].time);
            DOM.hudDate.textContent = currentDate.toLocaleString('zh-TW', { 
                year: 'numeric', month: 'numeric', day: 'numeric', 
                hour: '2-digit', minute: '2-digit', hour12: false 
            });
            
            DOM.hudEquity.textContent = `$${state.equity.toFixed(2)}`;
            DOM.hudPL.textContent = `$${state.floatingPL.toFixed(2)}`;
            
            DOM.hudPL.classList.toggle('positive', state.floatingPL > 0);
            DOM.hudPL.classList.toggle('negative', state.floatingPL < 0);

            const progress = (displayIndex / (state.gameData.length - 1)) * 100;
            DOM.hudProgress.style.width = `${Math.min(100, progress)}%`;
        }

        // FIX V6.2: Optimized updatePositionsPanel to prevent DOM thrashing
        function updatePositionsPanel() {
             // ... (updatePositionsPanel implementation remains the same as V6.2)
            DOM.positionsCount.textContent = state.openPositions.length;

            // 1. Get existing DOM elements
            const existingItems = DOM.positionsList.children;
            
            // 2. Identify current position IDs
            const currentIds = new Set(state.openPositions.map(p => p.id));

            // 3. Remove DOM elements for closed positions
            // Iterate backwards to safely remove elements while iterating
            for (let i = existingItems.length - 1; i >= 0; i--) {
                const item = existingItems[i];
                const id = parseInt(item.dataset.id);
                if (!currentIds.has(id)) {
                    DOM.positionsList.removeChild(item);
                }
            }

            // 4. Add new positions or Update existing ones
            // We iterate through state.openPositions to maintain order if needed, although order isn't strictly guaranteed here.
            state.openPositions.forEach(pos => {
                let item = DOM.positionsList.querySelector(`[data-id="${pos.id}"]`);

                if (!item) {
                    // Create new item if it doesn't exist
                    item = document.createElement('div');
                    item.className = 'trade-item';
                    item.dataset.id = pos.id;

                    // Initial HTML structure with placeholders for dynamic data
                    // We add specific classes (trade-profit, trade-sl, trade-tp) for easy selection later.
                    item.innerHTML = `
                        <div class="trade-header">
                            <span class="trade-type ${pos.type}">#${pos.id} ${pos.type === 'BUY' ? '買入' : '賣出'} ${pos.lots.toFixed(2)}手</span>
                            <span class="trade-profit"></span> <!-- Placeholder for profit -->
                        </div>
                        <div class="trade-details">
                            <div>
                                <div class="trade-detail-label">進場價</div>
                                <div>${pos.entryPrice.toFixed(2)}</div>
                            </div>
                            <div>
                                <div class="trade-detail-label">停損(SL)</div>
                                <div class="trade-sl"></div> <!-- Placeholder for SL -->
                            </div>
                            <div>
                                <div class="trade-detail-label">停利(TP)</div>
                                <div class="trade-tp"></div> <!-- Placeholder for TP -->
                            </div>
                        </div>
                        <div class="trade-actions">
                            <button class="btn btn-small btn-secondary btn-modify">修改</button>
                            <button class="btn btn-small btn-danger btn-close">平倉</button>
                        </div>
                    `;
                    // Append the new item. If we needed strict ordering (e.g., newest first), we'd adjust insertion logic.
                    DOM.positionsList.appendChild(item);
                }

                // Update dynamic parts (Profit, SL, TP)
                const profitElement = item.querySelector('.trade-profit');
                const slElement = item.querySelector('.trade-sl');
                const tpElement = item.querySelector('.trade-tp');

                const profitColor = pos.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)';
                
                // Only update if changed (minor optimization)
                const newProfitText = `$${pos.profit.toFixed(2)}`;
                if (profitElement.textContent !== newProfitText) {
                    profitElement.textContent = newProfitText;
                    profitElement.style.color = profitColor;
                }
                
                const newSLText = pos.sl ? pos.sl.toFixed(2) : 'N/A';
                if (slElement.textContent !== newSLText) {
                    slElement.textContent = newSLText;
                }

                const newTPText = pos.tp ? pos.tp.toFixed(2) : 'N/A';
                if (tpElement.textContent !== newTPText) {
                    tpElement.textContent = newTPText;
                }
            });
        }

        function updateHistoryPanel() {
            // ... (updateHistoryPanel implementation remains the same as V6.2)
            if (DOM.historyList.children.length === state.tradeHistory.length) return;

            DOM.historyList.innerHTML = '';
            const sortedHistory = [...state.tradeHistory].reverse();

            sortedHistory.forEach(trade => {
                const item = document.createElement('div');
                item.className = 'trade-item';
                
                const profitColor = trade.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)';

                item.innerHTML = `
                    <div class="trade-header">
                        <span class="trade-type ${trade.type}">#${trade.id} ${trade.type === 'BUY' ? '買入' : '賣出'} ${trade.lots.toFixed(2)}手</span>
                        <span style="color: ${profitColor}">$${trade.profit.toFixed(2)}</span>
                    </div>
                    <div class="trade-details">
                        <div>
                            <div class="trade-detail-label">開倉價</div>
                            <div>${trade.entryPrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">平倉價</div>
                            <div>${trade.closePrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">持有時間</div>
                            <div>${formatDuration(trade.closeTime - trade.entryTime)}</div>
                        </div>
                    </div>
                `;
                DOM.historyList.appendChild(item);
            });
        }

        function updateControls() {
            DOM.btnPlayPause.textContent = state.isPlaying ? '⏸️ 暫停' : '▶️ 播放';
            DOM.btnStepForward.disabled = state.isPlaying || state.isEnded;
            DOM.btnPlayPause.disabled = state.isEnded;
            document.getElementById('btnBuy').disabled = state.isEnded;
            document.getElementById('btnSell').disabled = state.isEnded;
            document.getElementById('btnEndGame').disabled = state.isEnded;
        }

        function setupEventListeners() {
            // ... (setupEventListeners implementation remains the same as V6.2)
            window.addEventListener('resize', resizeCanvas);

            // Controls
            DOM.btnPlayPause.addEventListener('click', togglePlayPause);
            DOM.btnStepForward.addEventListener('click', stepForward);
            DOM.speedSelector.addEventListener('click', handleSpeedChange);
            document.getElementById('btnZoomIn').addEventListener('click', () => zoomChart(1.2));
            document.getElementById('btnZoomOut').addEventListener('click', () => zoomChart(1/1.2));
            document.getElementById('btnEndGame').addEventListener('click', handleEndGameClick);


            // Trading Panel Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', handleTabSwitch);
            });

            // Order Inputs (Steppers)
            // FIX: Updated steps (Feature 5). Lots 0.1. Price 5.0.
            setupInputStepper('lotsUp', 'inputLots', 0.1);
            setupInputStepper('lotsDown', 'inputLots', -0.1);
            setupInputStepper('slUp', 'inputSL', 5.0);
            setupInputStepper('slDown', 'inputSL', -5.0);
            setupInputStepper('tpUp', 'inputTP', 5.0);
            setupInputStepper('tpDown', 'inputTP', -5.0);

            // Input change listeners for P/L estimation
            DOM.inputLots.addEventListener('input', updateEstimatedPL);
            DOM.inputSL.addEventListener('input', updateEstimatedPL);
            DOM.inputTP.addEventListener('input', updateEstimatedPL);


            // Trade Buttons
            document.getElementById('btnBuy').addEventListener('click', () => handleTrade('BUY'));
            document.getElementById('btnSell').addEventListener('click', () => handleTrade('SELL'));
            DOM.btnCloseAllTab.addEventListener('click', closeAllOrders);

            // FIX: Event Delegation for Positions List (Bug 3)
            // This mechanism works correctly with the optimized updatePositionsPanel.
            DOM.positionsList.addEventListener('click', (e) => {
                const target = e.target;
                const tradeItem = target.closest('.trade-item');
                if (!tradeItem) return;

                const id = parseInt(tradeItem.dataset.id);

                // Check if the ID is still valid (position exists)
                if (!state.openPositions.find(p => p.id === id)) return;

                if (target.classList.contains('btn-close')) {
                    const currentPrice = getCurrentPrice();
                    closeOrder(id, currentPrice);
                } else if (target.classList.contains('btn-modify')) {
                    modifyOrder(id);
                }
            });


            // Chart Interaction (Mouse)
            DOM.chartWrap.addEventListener('mousemove', handleMouseMove);
            DOM.chartWrap.addEventListener('mouseleave', handleMouseLeave);
            DOM.chartWrap.addEventListener('wheel', handleMouseWheel, { passive: false });
            DOM.chartWrap.addEventListener('mousedown', handleDragStart);
            window.addEventListener('mousemove', handleDragging);
            window.addEventListener('mouseup', handleDragEnd);

            // Chart Interaction (Touch)
            DOM.chartWrap.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd);


            // Modal Buttons
            document.getElementById('eventContinueBtn').addEventListener('click', continueFromEvent);
            document.getElementById('restartButton').addEventListener('click', startGame);
        }
        
        function handleEndGameClick() {
            // ... (handleEndGameClick implementation remains the same as V6.2)
            if (state.isEnded) return;
            
            // Pause game before confirmation
            if (state.isPlaying) {
                togglePlayPause();
            }

            if (confirm("確定要提前結束本次挑戰嗎？")) {
                endGame();
            }
        }

        // Event Handlers Implementation
         function togglePlayPause() {
            if (state.isEnded) return;
            state.isPlaying = !state.isPlaying;
            
            if (state.isPlaying) {
                lastTickTime = 0; 
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                cancelAnimationFrame(animationFrameId);
            }
            updateControls();
        }

        function stepForward() {
            if (state.isPlaying || state.isEnded) return;
            
            finalizeCurrentBar();
            
            if (!advanceSimulation()) {
                endGame();
            } else {
                state.barAnimationProgress = 1; 
                checkBreakouts(); // V6.3 Check breakouts on manual step
                updatePositions();
                updateAccount();
                checkDurationAchievements(); // Check achievements on manual step
                checkDrawdownAchievement(); // NEW
                updateUI();
                checkForEvents();
                
                if (state.chart.scrollOffset > 0) {
                    state.chart.scrollOffset = Math.max(0, state.chart.scrollOffset - 1);
                }
                requestAnimationFrame(draw);
            }
        }
        
        function handleSpeedChange(e) {
            // ... (handleSpeedChange implementation remains the same as V6.2)
            if (e.target.classList.contains('speed-btn')) {
                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.speedMultiplier = parseInt(e.target.dataset.speed);
                lastTickTime = 0;
            }
        }

        // FIX: Updated function to re-evaluate tutorial highlight on tab switch (V6.2)
        function handleTabSwitch(e) {
            // ... (handleTabSwitch implementation remains the same as V6.2)
            const target = e.target.closest('.tab-btn');
            if (!target) return;

            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            target.classList.add('active');
            document.getElementById(target.dataset.target).classList.add('active');

            // FIX: Re-evaluate the tutorial highlight after the layout changes (V6.2)
            // This prevents the overlay from blocking the UI if the target element is now hidden.
            if (state.tutorialActive) {
                // Use a slight delay to ensure the DOM is updated (CSS transitions finished) before recalculating bounds
                setTimeout(showTutorialStep, 50); 
            }
        }

        function handleTrade(type) {
            // ... (handleTrade implementation remains the same as V6.2)
            const lots = parseFloat(DOM.inputLots.value);
            const sl = DOM.inputSL.value ? parseFloat(DOM.inputSL.value) : null;
            const tp = DOM.inputTP.value ? parseFloat(DOM.inputTP.value) : null;

            if (isNaN(lots) || lots < 0.01) {
                alert("請輸入有效的手數 (Lots)，最小為 0.01。");
                return;
            }
            
            if (sl !== null && (isNaN(sl) || sl <= 0)) {
                 alert("停損價格 (SL) 必須是正數。");
                return;
            }
             if (tp !== null && (isNaN(tp) || tp <= 0)) {
                alert("停利價格 (TP) 必須是正數。");
                return;
            }

            openOrder(type, lots, sl, tp);
        }

        function closeAllOrders() {
            // ... (closeAllOrders implementation remains the same as V6.2)
            if (state.openPositions.length === 0 || state.isEnded) return;
            
            const currentPrice = getCurrentPrice();
            // Iterate over a copy to safely modify the original array
            [...state.openPositions].forEach(pos => {
                closeOrder(pos.id, currentPrice);
            });
        }

        function modifyOrder(id) {
            // ... (modifyOrder implementation remains the same as V6.2)
            const position = state.openPositions.find(p => p.id === id);
            if (!position) return;

            // Pause game when modifying order
            if (state.isPlaying) {
                togglePlayPause();
            }

            const currentSL = position.sl ? position.sl.toFixed(2) : '';
            const currentTP = position.tp ? position.tp.toFixed(2) : '';

            const newSLInput = prompt(`修改訂單 #${id} 停損 (SL)。\n進場價: ${position.entryPrice.toFixed(2)}\n留空則取消 SL。目前值: ${currentSL}`, currentSL);
            
            if (newSLInput === null) return;

            const newTPInput = prompt(`修改訂單 #${id} 停利 (TP)。\n進場價: ${position.entryPrice.toFixed(2)}\n留空則取消 TP。目前值: ${currentTP}`, currentTP);

            if (newTPInput === null) return;

            let newSL = null;
            if (newSLInput !== '') {
                newSL = parseFloat(newSLInput);
                if (isNaN(newSL) || newSL <= 0) {
                    alert("無效的 SL 價格。");
                    return;
                }
                if (position.type === 'BUY' && newSL >= position.entryPrice) {
                    alert("買單的停損必須低於進場價。");
                    return;
                } else if (position.type === 'SELL' && newSL <= position.entryPrice) {
                    alert("賣單的停損必須高於進場價。");
                    return;
                }
            }

            let newTP = null;
            if (newTPInput !== '') {
                newTP = parseFloat(newTPInput);
                if (isNaN(newTP) || newTP <= 0) {
                    alert("無效的 TP 價格。");
                    return;
                }
                if (position.type === 'BUY' && newTP <= position.entryPrice) {
                    alert("買單的停利必須高於進場價。");
                    return;
                } else if (position.type === 'SELL' && newTP >= position.entryPrice) {
                    alert("賣單的停利必須低於進場價。");
                    return;
                }
            }

            position.sl = newSL;
            position.tp = newTP;
            
            updateUI();
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        
        // Chart Interaction Handlers (Mouse & Touch)
        
        function handleMouseMove(e) {
            // ... (handleMouseMove implementation remains the same as V6.2)
            const rect = DOM.chartWrap.getBoundingClientRect();
            state.mouse.x = e.clientX - rect.left;
            state.mouse.y = e.clientY - rect.top;
            state.mouse.isOverChart = true;

            // Unpin crosshair on mouse move (Desktop behavior)
            if (state.chart.isCrosshairPinned && !state.isMobile) {
                state.chart.isCrosshairPinned = false;
            }
            
            if (!state.isPlaying && !state.chart.isDragging) {
                 requestAnimationFrame(draw);
            }
        }

        function handleMouseLeave() {
            // ... (handleMouseLeave implementation remains the same as V6.2)
            state.mouse.isOverChart = false;
             if (!state.isPlaying && !state.chart.isDragging) {
                requestAnimationFrame(draw);
            }
        }

        function handleMouseWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            zoomChart(zoomFactor);
        }

        function zoomChart(factor) {
            // ... (zoomChart implementation remains the same as V6.2)
            const newWidth = state.chart.candleWidth * factor;
            const newSpacing = state.chart.candleSpacing * factor;

            if (newWidth < 2 || newWidth > 50) return;

            state.chart.candleWidth = newWidth;
            state.chart.candleSpacing = newSpacing;

            validateScrollOffset();

            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }


        // Panning (Dragging) Logic
        // ... (Dragging Logic implementations remain the same as V6.2)
        function handleDragStart(e) {
            if (e.button !== 0) return;
            startDrag(e.clientX, e.clientY);
        }

        function handleDragging(e) {
            if (!state.chart.isDragging) return;
            performDrag(e.clientX, e.clientY);
        }

        function handleDragEnd() {
            // Prevent mouse interaction from triggering tap logic on desktop
             if (!state.isMobile && state.chart.isDragging) {
                endDrag();
            }
        }

        // FIX: Updated Touch handlers for better pinning/unpinning logic (Feature 3)
        function handleTouchStart(e) {
            if (e.touches.length === 1 && e.target.closest('#chartWrap')) {
                e.preventDefault();
                // Don't unpin immediately. Wait to see if it's a drag or tap.
                startDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 1 && state.chart.isDragging) {
                e.preventDefault();

                // NEW: If it moves significantly, it's a drag. Unpin now for responsiveness.
                const dx = e.touches[0].clientX - state.chart.dragStartX;
                const dy = e.touches[0].clientY - state.chart.dragStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 10 && state.chart.isCrosshairPinned) {
                    state.chart.isCrosshairPinned = false;
                }

                performDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        function handleTouchEnd(e) {
            if (!state.chart.isDragging) return;

            const touchDuration = Date.now() - state.chart.dragStartTimeStamp;
            const dx = state.chart.dragCurrentX - state.chart.dragStartX;
            const dy = state.chart.dragCurrentY - state.chart.dragStartY;
            const touchDistance = Math.sqrt(dx * dx + dy * dy);

            // Define thresholds for a "tap"
            const isTap = touchDuration < 300 && touchDistance < 10;

            if (isTap) {
                if (state.chart.isCrosshairPinned) {
                    // Case 1: Was pinned, user tapped -> Unpin
                    state.chart.isCrosshairPinned = false;
                } else {
                    // Case 2: Was unpinned, user tapped -> Pin
                    const rect = DOM.chartWrap.getBoundingClientRect();
                    // Use the final touch position (dragCurrentX/Y) relative to the chart wrap for pinning
                    state.chart.pinnedCrosshairPos.x = state.chart.dragCurrentX - rect.left;
                    state.chart.pinnedCrosshairPos.y = state.chart.dragCurrentY - rect.top;
                    state.chart.isCrosshairPinned = true;
                }
            }
            // If it was a drag (not a tap), the unpinning (if needed) happened in handleTouchMove.
            
            endDrag();
        }

        // Updated to handle Y coordinates
        function startDrag(clientX, clientY = 0) {
            state.chart.isDragging = true;
            state.chart.dragStartX = clientX;
            state.chart.dragStartY = clientY; // NEW
            state.chart.dragStartScroll = state.chart.scrollOffset;
            DOM.chartWrap.style.cursor = 'grabbing';
            
            // Store initial touch position and time for tap detection
            state.chart.dragCurrentX = clientX;
            state.chart.dragCurrentY = clientY;
            state.chart.dragStartTimeStamp = Date.now();
        }

        // Updated to handle Y coordinates
        function performDrag(clientX, clientY = 0) {
            const dx = clientX - state.chart.dragStartX;
            const candleUnitWidth = state.chart.candleWidth + state.chart.candleSpacing;
            
            if (candleUnitWidth <= 0) return;

            const candlesDragged = Math.round(dx / candleUnitWidth);
            
            // TradingView style scrolling (Natural)
            state.chart.scrollOffset = state.chart.dragStartScroll + candlesDragged;

            // Update current touch position
            state.chart.dragCurrentX = clientX;
            state.chart.dragCurrentY = clientY;

            validateScrollOffset();

            requestAnimationFrame(draw);
        }

        function endDrag() {
            state.chart.isDragging = false;
            DOM.chartWrap.style.cursor = 'crosshair';
             if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function validateScrollOffset() {
            if (state.gameData.length === 0) {
                state.chart.scrollOffset = 0;
                return;
            }

            const visibleCandles = calculateVisibleCandles();
            const maxOffset = Math.max(0, state.currentIndex + 1 - visibleCandles);
            
            state.chart.scrollOffset = Math.max(0, Math.min(maxOffset, state.chart.scrollOffset));
        }


        // ----------------------------------------------------------------------------
        // 7. 遊戲化功能 (Gamification Features)
        // ----------------------------------------------------------------------------

         function checkForEvents() {
            // ... (checkForEvents implementation remains the same as V6.2)
            if (state.isEnded || state.gameData.length === 0) return;

            // Calculate day relative to the start of the simulation for event triggering
            const currentDate = new Date(state.gameData[state.currentIndex].time);
            const startTime = state.gameData[0].time;
            const elapsedMs = currentDate.getTime() - startTime;
            const elapsedDays = Math.floor(elapsedMs / (1000 * 60 * 60 * 24)) + 1;


            const event = state.financialEvents.find(e => e.triggerDay === elapsedDays);

            // Use elapsedDays as the key to ensure events trigger once per simulation run
            const eventKey = `Day${elapsedDays}`;
            
            if (event && !state.triggeredEvents.has(eventKey)) {
                showEventModal(event);
                state.triggeredEvents.add(eventKey);
            }
        }

         function showEventModal(event) {
            // ... (showEventModal implementation remains the same as V6.2)
            if (state.isPlaying) {
                state.wasPlayingBeforeEvent = true;
                state.isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                updateControls();
            } else {
                state.wasPlayingBeforeEvent = false;
            }

            document.getElementById('eventTitle').textContent = `⚠️ ${event.title}`;
            document.getElementById('eventBody').textContent = event.description;
            DOM.eventModal.classList.add('active');
        }

         function continueFromEvent() {
            DOM.eventModal.classList.remove('active');
            if (state.wasPlayingBeforeEvent) {
                togglePlayPause();
            }
        }

        // NEW V6.3: Calculate recent highs/lows for breakout detection
        function updateBreakoutLevels() {
            if (state.gameData.length === 0 || state.currentIndex === 0) return;

            const lookbackMs = state.breakout.lookbackPeriodDays * 24 * 60 * 60 * 1000;
            // Calculate levels based on data up to the *previous* bar
            const referenceTime = state.gameData[state.currentIndex - 1].time;
            const lookbackTime = referenceTime - lookbackMs;

            let high = -Infinity;
            let low = Infinity;

            // Iterate backwards from the previous bar (currentIndex - 1)
            for (let i = state.currentIndex - 1; i >= 0; i--) {
                const bar = state.gameData[i];
                if (bar.time < lookbackTime) break;

                high = Math.max(high, bar.high);
                low = Math.min(low, bar.low);
            }

            state.breakout.highPrice = high;
            state.breakout.lowPrice = low;
            // Reset flags for the new bar
            state.breakout.isBreakingHigh = false;
            state.breakout.isBreakingLow = false;
        }

        // NEW V6.3: Check if the current animated bar is breaking levels
        function checkBreakouts() {
            // We only check breakouts during the animation of the current bar, and only if not scrolling back
            if (state.currentIndex === 0 || state.chart.scrollOffset !== 0) return;

            const currentBar = state.gameData[state.currentIndex];
            const animatedBar = getAnimatedBar(currentBar);

            const { highPrice, lowPrice } = state.breakout;

            // Check if levels are valid (they should be if currentIndex > 0)
            if (highPrice === -Infinity || lowPrice === Infinity) return;

            // Check if the *current* animated high/low exceeds the *previous* period's high/low
            const isBreakingHigh = animatedBar.high > highPrice;
            const isBreakingLow = animatedBar.low < lowPrice;

            // Trigger animation if a new breakout occurs (flag changes from false to true)
            if (isBreakingHigh && !state.breakout.isBreakingHigh) {
                addBreakoutAnimation('HIGH', animatedBar.high, state.currentIndex);
            }
            if (isBreakingLow && !state.breakout.isBreakingLow) {
                addBreakoutAnimation('LOW', animatedBar.low, state.currentIndex);
            }

            // Update the state flags
            state.breakout.isBreakingHigh = isBreakingHigh;
            state.breakout.isBreakingLow = isBreakingLow;
        }

        
        function showEndGameModal() {
            // ... (showEndGameModal implementation remains the same as V6.2)
            const finalRoR = ((state.equity - CONFIG.INITIAL_BALANCE) / CONFIG.INITIAL_BALANCE) * 100;
            
            document.getElementById('finalScore').textContent = `$${state.equity.toFixed(2)}`;
            document.getElementById('finalRoR').textContent = `回報率 (RoR): ${finalRoR.toFixed(2)}%`;
            document.getElementById('finalRoR').style.color = finalRoR >= 0 ? 'var(--color-success)' : 'var(--color-danger)';

            // Display final time
            const minutes = Math.floor(state.elapsedTime / 60);
            const seconds = state.elapsedTime % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalTime').textContent = `總花費時間: ${timeString}`;

            // Stats Calculation
            const totalTrades = state.tradeHistory.length;
            const winningTrades = state.tradeHistory.filter(t => t.profit > 0).length;
            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const totalProfit = state.tradeHistory.reduce((sum, t) => sum + t.profit, 0);

            const statsHTML = `
                <p><strong>交易統計：</strong></p>
                <ul style="list-style-position: inside; padding-left: 10px;">
                    <li>總交易次數: ${totalTrades}</li>
                    <li>勝率: ${winRate.toFixed(2)}%</li>
                    <li>總損益: $${totalProfit.toFixed(2)}</li>
                    <li>模擬期間: 約 ${CONFIG.SIMULATION_DURATION_DAYS} 天</li>
                </ul>
            `;
            document.getElementById('endGameStats').innerHTML = statsHTML;

            // Display Achievements
            displayAchievements();

            DOM.endGameModal.classList.add('active');
        }

        // 7.3 新手導引 (Tutorial)
        // UPDATED V6.3 Tutorial Steps
        const TUTORIAL_STEPS = [
            { selector: '#challengeInfo', message: '歡迎！本次挑戰目標：在隨機的30天歷史行情中取得最高收益。', action: 'next' },
            { selector: '.chart-container', message: '這裡是 K 線圖表。向右拖曳查看歷史數據。在手機上，點擊圖表可以鎖定十字準心查看價格，再次點擊或拖曳可解除鎖定。', action: 'next' },
            { selector: '.controls', message: '使用這些按鈕控制模擬速度，或點擊「結束挑戰」隨時結算成績。', action: 'next' },
            { selector: '.order-grid', message: '設定停損(SL)、手數和停利(TP)。使用 +/- 按鈕可快速調整（步進值已優化為整數增減）。注意下方的預估損益。', action: 'next' },
            { selector: '.trade-actions-grid', message: '點擊「賣出」或「買入」進行交易。點擊「全部平倉」可快速關閉所有訂單。', action: 'next' },
            { selector: '[data-target="tabPositions"]', message: '點擊「持倉」分頁來查看和管理您當前的訂單。', action: 'next' },
            // UPDATED V6.3 Message
            { selector: '.header', message: '頂部 HUD 顯示您的帳戶狀態。注意：引導結束後行情將自動開始，祝您交易順利！', action: 'next' },
        ];

        let currentTutorialStep = 0;

        function startTutorial() {
            state.tutorialActive = true;
            currentTutorialStep = 0;
            // Temporarily show the hidden challenge info for the tutorial
            document.getElementById('challengeInfo').style.display = 'block'; 
            showTutorialStep();
        }

        function showTutorialStep() {
            if (currentTutorialStep >= TUTORIAL_STEPS.length) {
                endTutorial();
                return;
            }

            const step = TUTORIAL_STEPS[currentTutorialStep];
            const element = document.querySelector(step.selector);

            if (!element) {
                // If element isn't ready yet, wait a bit and try again
                setTimeout(showTutorialStep, 100);
                return;
            }

            highlightElement(element);
            DOM.tutorialText.textContent = step.message;

            // Ensure "Next" button is visible and bound
            // Check added because highlightElement might hide the message if the element is hidden (V6.2)
            if (!DOM.tutorialMessage.classList.contains('hidden')) {
                DOM.tutorialNextBtn.classList.remove('hidden');
                DOM.tutorialNextBtn.onclick = completeTutorialStep;
            }
        }

        function completeTutorialStep() {
            if (!state.tutorialActive) return;
            currentTutorialStep++;
            showTutorialStep();
        }

        // UPDATED V6.3: Auto-start simulation after tutorial
        function endTutorial() {
            state.tutorialActive = false;
            state.tutorialCompletedOnce = true;
            DOM.tutorialHighlight.classList.add('hidden');
            DOM.tutorialMessage.classList.add('hidden');
            // Hide the challenge info again after tutorial ends
            document.getElementById('challengeInfo').style.display = 'none';

            // NEW V6.3: Auto-start the simulation for urgency
            if (!state.isEnded && !state.isPlaying) {
                togglePlayPause();
            }
        }

        // FIX: Updated function to handle hidden elements gracefully (V6.2)
        function highlightElement(element) {
             // ... (highlightElement implementation remains the same as V6.2)
            const rect = element.getBoundingClientRect();
            const padding = 10;

            // FIX: Check if the element is hidden (e.g., in an inactive tab) (V6.2)
            // If the element has 0 width/height (or is otherwise not displayed), it's effectively hidden.
            if (rect.width === 0 && rect.height === 0) {
                // If the target element is hidden, we must hide the highlight and message,
                // otherwise the overlay (box-shadow) will block interaction with the visible UI.
                DOM.tutorialHighlight.classList.add('hidden');
                DOM.tutorialMessage.classList.add('hidden');
                return; // Exit early
            }

            // If visible, proceed as normal
            DOM.tutorialHighlight.classList.remove('hidden');
            DOM.tutorialHighlight.style.top = `${rect.top + window.scrollY - padding}px`;
            DOM.tutorialHighlight.style.left = `${rect.left + window.scrollX - padding}px`;
            DOM.tutorialHighlight.style.width = `${rect.width + padding * 2}px`;
            DOM.tutorialHighlight.style.height = `${rect.height + padding * 2}px`;

            DOM.tutorialMessage.classList.remove('hidden');
            
            let messageTop = rect.bottom + window.scrollY + padding + 15;
            let messageLeft = rect.left + window.scrollX;

            // Force re-calculation of message size based on current text
            DOM.tutorialMessage.style.width = 'auto';
            const messageRect = DOM.tutorialMessage.getBoundingClientRect();
            const maxWidth = 300;


            // Boundary checks
            if (messageTop + messageRect.height > window.innerHeight + window.scrollY) {
                messageTop = Math.max(10 + window.scrollY, rect.top + window.scrollY - messageRect.height - padding - 15);
            }
            
            if (messageLeft + Math.min(maxWidth, messageRect.width) > window.innerWidth + window.scrollX) {
                messageLeft = window.innerWidth + window.scrollX - Math.min(maxWidth, messageRect.width) - 20;
            }
            
            messageLeft = Math.max(10 + window.scrollX, messageLeft);

            DOM.tutorialMessage.style.top = `${messageTop}px`;
            DOM.tutorialMessage.style.left = `${messageLeft}px`;
        }


        // ----------------------------------------------------------------------------
        // 8. 成就係統 (Achievement System)
        // ----------------------------------------------------------------------------

        function unlockAchievement(key) {
            if (!state.unlockedAchievements.has(key)) {
                state.unlockedAchievements.add(key);
                const achievement = ACHIEVEMENTS[key];
                // V6.3: Achievements still use notifications.
                if (achievement) {
                    showNotification(`🏆 成就解鎖: ${achievement.title}`, achievement.description);
                }
            }
        }

        // NEW: Handles daily statistics updates for achievements (Feature 6)
        function updateDailyStats() {
            // ... (updateDailyStats implementation remains the same as V6.2)
            if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return;

            const currentTime = state.gameData[state.currentIndex].time;
            const currentDay = new Date(currentTime).toDateString();

            const currentTotalPL = state.equity - CONFIG.INITIAL_BALANCE;

            if (state.achievementStats.currentDay !== currentDay) {
                // Day changed, reset daily stats
                state.achievementStats.currentDay = currentDay;
                state.achievementStats.dailyLossCount = 0;
                // Initialize daily max P/L with the P/L at the start of the day
                state.achievementStats.dailyMaxPL = currentTotalPL;
            }

            // Update daily max P/L
            if (currentTotalPL > state.achievementStats.dailyMaxPL) {
                state.achievementStats.dailyMaxPL = currentTotalPL;
            }
        }

        function updateAchievementStats(closedTrade) {
            // ... (updateAchievementStats implementation remains the same as V6.2)
            // Update consecutive wins/losses
            if (closedTrade.profit > 0) {
                state.achievementStats.consecutiveWins++;
                state.achievementStats.consecutiveLosses = 0;
            } else if (closedTrade.profit < 0) {
                state.achievementStats.consecutiveLosses++;
                state.achievementStats.consecutiveWins = 0;

                // NEW: Update daily loss count (BAD_DAY)
                // Ensure the trade closed on the current simulation day before counting
                const closeDay = new Date(closedTrade.closeTime).toDateString();
                if (closeDay === state.achievementStats.currentDay) {
                   state.achievementStats.dailyLossCount++;
                }
            }
        }

        function checkTradeAchievements(trade) {
            // ... (checkTradeAchievements implementation remains the same as V6.2)
            // 1. First Trade
            if (state.tradeHistory.length >= 1) {
                unlockAchievement('FIRST_TRADE');
            }
            // 8. Total Trades
            if (state.tradeHistory.length >= 10) {
                unlockAchievement('TRADER_10');
            }
            // 2. Big Win / 3. Big Loss
            if (trade.profit > 3000) {
                unlockAchievement('BIG_WIN');
            }
            if (trade.profit < -3000) {
                unlockAchievement('BIG_LOSS');
            }
            // 4. Win Streak / 5. Loss Streak
            if (state.achievementStats.consecutiveWins >= 3) {
                unlockAchievement('WIN_STREAK_3');
            }
            if (state.achievementStats.consecutiveLosses >= 3) {
                unlockAchievement('LOSS_STREAK_3');
            }
            // 9. 快槍俠 (QUICK_DRAW) - 1 hour condition
            const durationMs = trade.closeTime - trade.entryTime;
            const durationHours = durationMs / (1000 * 60 * 60);
            if (trade.profit > 0 && durationHours <= 1) {
                unlockAchievement('QUICK_DRAW');
            }
            // 15. 今天盤不好 (BAD_DAY)
            if (state.achievementStats.dailyLossCount >= 3) {
                unlockAchievement('BAD_DAY');
            }
        }

        function checkEquityAchievements() {
            // ... (checkEquityAchievements implementation remains the same as V6.2)
            // 10. Double Up
            if (state.equity >= 20000) {
                unlockAchievement('DOUBLE_UP');
            }
            // 11. 破產邊緣 (MARGIN_CALL) - $2000 threshold
            if (state.achievementStats.minEquity < 2000) {
                unlockAchievement('MARGIN_CALL');
            }
        }

        // NEW: Check for RUG_PULL achievement (Drawdown) (Feature 6)
        function checkDrawdownAchievement() {
            // ... (checkDrawdownAchievement implementation remains the same as V6.2)
            // 16. 盤中抽筋 (RUG_PULL)
            const currentTotalPL = state.equity - CONFIG.INITIAL_BALANCE;
            
            // Check if we went from profit to loss AND the drawdown from the daily peak P/L exceeds $2000
            // We check if dailyMaxPL > 0 to ensure there was profit during the day.
            if (state.achievementStats.dailyMaxPL > 0 && state.achievementStats.dailyMaxPL - currentTotalPL > 2000) {
                 // Further check if the current state is a loss, as required by the description
                 if (currentTotalPL < 0) {
                     unlockAchievement('RUG_PULL');
                 }
            }
        }

        function checkDurationAchievements() {
            // ... (checkDurationAchievements implementation remains the same as V6.2)
            // Ensure gameData access is safe
            if (!state.gameData || state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return;

            // Use simulation time
            const currentTime = state.gameData[state.currentIndex].time;
            const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;

            state.openPositions.forEach(pos => {
                const duration = currentTime - pos.entryTime;
                if (duration > SEVEN_DAYS_MS) {
                    // 7. 佛系操盤
                    if (pos.profit > 0) {
                        unlockAchievement('HOLD_WIN_7D');
                    // 6. 凹單大師
                    } else if (pos.profit < 0) {
                        unlockAchievement('HOLD_LOSS_7D');
                    }
                }
            });
        }

        function checkFinalAchievements() {
            // ... (checkFinalAchievements implementation remains the same as V6.2)
            // 12. 穩健獲利 (CONSISTENT)
            const totalTrades = state.tradeHistory.length;
            if (totalTrades >= 10) {
                const winningTrades = state.tradeHistory.filter(t => t.profit > 0).length;
                const winRate = (winningTrades / totalTrades) * 100;
                if (winRate > 60) {
                    unlockAchievement('CONSISTENT');
                }
            }
        }

        function displayAchievements() {
            // ... (displayAchievements implementation remains the same as V6.2)
            const listElement = document.getElementById('achievementsList');
            const sectionElement = document.getElementById('achievementsSection');
            listElement.innerHTML = '';

            if (state.unlockedAchievements.size === 0) {
                sectionElement.style.display = 'none';
                return;
            }

            sectionElement.style.display = 'block';

            // Display achievements in the order they were unlocked (Set preserves insertion order)
            state.unlockedAchievements.forEach(key => {
                const achievement = ACHIEVEMENTS[key];
                if (achievement) {
                    const item = document.createElement('li');
                    item.className = 'achievement-item';
                    item.innerHTML = `
                        <span class="achievement-icon">${achievement.icon}</span>
                        <div>
                            <strong>${achievement.title}</strong>
                            <p style="font-size: 12px; color: var(--color-text-secondary);">${achievement.description}</p>
                        </div>
                    `;
                    listElement.appendChild(item);
                }
            });
        }

        // Notification (Toast) System
        // V6.3: Used for Achievements.
        function showNotification(title, message) {
            // Ensure DOM container exists
            if (!DOM.notificationContainer) return;

            const toast = document.createElement('div');
            toast.className = 'notification-toast';

            toast.innerHTML = `<strong>${title}</strong><p>${message}</p>`;
            
            // Prepend so the newest notification is on top
            DOM.notificationContainer.insertBefore(toast, DOM.notificationContainer.firstChild);

            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (DOM.notificationContainer.contains(toast)) {
                        DOM.notificationContainer.removeChild(toast);
                    }
                }, 500); // Wait for fade out transition
            }, 5000);
        }


        // ----------------------------------------------------------------------------
        // 9. 輔助函式 (Utility Functions)
        // ----------------------------------------------------------------------------

         // 設置輸入框的步進按鈕邏輯 (包含初始化)
         // FIX: Updated logic for initialization and stepping (Feature 5)
        function setupInputStepper(buttonId, inputId, step) {
            // ... (setupInputStepper implementation remains the same as V6.2)
            const button = document.getElementById(buttonId);
            if (!button) return;

            button.addEventListener('click', () => {
                const input = document.getElementById(inputId);
                let currentValue = parseFloat(input.value);
                let newValue;

                // 精度處理
                const stepStr = Math.abs(step).toString();
                const decimalPlaces = (stepStr.split('.')[1] || []).length;
                
                // 確保價格顯示兩位小數
                const displayDecimalPlaces = (inputId === 'inputLots') ? decimalPlaces : 2;

                // 初始化邏輯
                if (isNaN(currentValue) || (currentValue <= 0 && inputId !== 'inputLots')) {
                    if (inputId === 'inputSL' || inputId === 'inputTP') {
                        const currentPrice = getCurrentPrice();
                        if (currentPrice > 0) {
                            // FIX: 從當前市價開始，並對齊到最近的 step 倍數，確保方向正確
                            if (step > 0) {
                                // If pressing UP, initialize to the next multiple of 'step' above current price
                                newValue = Math.ceil(currentPrice / Math.abs(step)) * Math.abs(step);
                                if (newValue <= currentPrice) {
                                    newValue += Math.abs(step);
                                }
                            } else {
                                // If pressing DOWN, initialize to the next multiple of 'step' below current price
                                newValue = Math.floor(currentPrice / Math.abs(step)) * Math.abs(step);
                                if (newValue >= currentPrice) {
                                     newValue -= Math.abs(step);
                                }
                            }
                        } else {
                            return; // 市價不可用則不操作
                        }
                    } else if (inputId === 'inputLots') {
                        // Ensure initialization respects the step (e.g., if step is 0.1, initialize to 0.1)
                        // If pressing down from empty, initialize to minimum lot size
                        if (step > 0) {
                             newValue = Math.abs(step);
                        } else {
                            newValue = 0.01;
                        }
                    }
                } else {
                     newValue = currentValue + step;
                }
                
                // 浮點數校正
                const precisionFactor = Math.pow(10, Math.max(decimalPlaces, displayDecimalPlaces));
                // Safety check if newValue somehow became undefined
                if (newValue === undefined) return; 
                newValue = Math.round(newValue * precisionFactor) / precisionFactor;


                // 邊界檢查
                if (inputId === 'inputLots') {
                     if (newValue < 0.01) newValue = 0.01;
                } else {
                    // SL/TP 必須大於 0
                    if (newValue <= 0) {
                        input.value = '';
                        updateEstimatedPL(); // 更新預估損益
                        return;
                    }
                }
               
                input.value = newValue.toFixed(displayDecimalPlaces);
                updateEstimatedPL(); // 更新預估損益
            });
        }

         function formatDuration(ms) {
            // ... (formatDuration implementation remains the same as V6.2)
            if (ms < 0) ms = 0;
            const minutes = Math.floor(ms / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}天 ${hours % 24}小時`;
            if (hours > 0) return `${hours}小時 ${minutes % 60}分鐘`;
            // Added seconds display for very short durations
            if (minutes === 0) return `${Math.floor(ms / 1000)}秒`;
            return `${minutes}分鐘`;
        }

        // ----------------------------------------------------------------------------
        // 啟動應用程式 (Bootstrap Application)
        // ----------------------------------------------------------------------------
        
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>            display: flex;
            flex: 1;
            overflow: hidden;
            /* NEW FIX: Crucial for flex children in column layout to handle overflow correctly */
            min-height: 0; 
        }

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }

        /* FIX: Sidebar Layout Rework (V6.1) */
        .sidebar {
            width: 340px;
            background-color: var(--color-panel-bg);
            border-left: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            /* overflow: hidden; // REMOVED: Let the content handle its own overflow */
            flex-shrink: 0;
            /* height: 100%; // REMOVED: Flexbox handles height within main-content */
        }
        
        /* Footer */
        .footer {
            background-color: var(--color-panel-bg);
            text-align: center;
            padding: 8px 0;
            font-size: 12px;
            color: var(--color-text-secondary);
            border-top: 1px solid var(--color-border);
        }
        .footer a {
            color: var(--color-primary);
            text-decoration: none;
        }
        .footer a:hover {
            text-decoration: underline;
        }


        /* Mobile Responsiveness Adjustments */
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                /* FIX: Ensure sidebar and chart share space correctly */
                max-height: none; 
                flex: 1; 
                border-left: none;
                border-top: 1px solid var(--color-border);
            }
            .chart-container {
                /* FIX: Allow chart to shrink but maintain minimum height */
                flex: 1;
                min-height: 300px; 
                padding: 10px;
            }
            .controls {
                flex-wrap: wrap;
            }
            /* Adjust HUD layout for mobile */
            .header {
                padding: 8px 10px;
            }
            .hud, .hud-right {
                gap: 10px;
            }
            .hud-value {
                font-size: 14px;
            }
            .progress-container {
                width: 100px;
            }
        }

        /* 3. Header (HUD) Components */
        /* ... (Styles for HUD remain unchanged) ... */
        .hud {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
        }

        .hud-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .hud-value {
            font-size: 16px;
            font-weight: bold;
        }

        #hud-pl.positive { color: var(--color-success); }
        #hud-pl.negative { color: var(--color-danger); }

        .hud-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .progress-container {
            width: 150px;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--color-border);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--color-primary);
            transition: width 0.3s ease;
        }

        /* 4. Chart Components */
        /* ... (Styles for Chart remain unchanged) ... */
        .chart-wrap {
            position: relative;
            flex: 1;
            background-color: var(--chart-bg);
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            overflow: hidden;
            cursor: crosshair;
        }

        #chartCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* DOM Overlays for Position Lines */
        .position-line {
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .position-line-dash {
            flex: 1;
            height: 1px;
            border-top-style: dashed;
            border-top-width: 1px;
        }

        .position-label {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            margin-left: 5px;
            margin-right: 5px;
            white-space: nowrap;
        }

        .position-pl {
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.9);
            margin-right: 5px;
            font-weight: bold;
            box-shadow: var(--shadow-main);
        }

        /* 5. Controls & Toolbar */
        .controls {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius-main);
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            user-select: none;
            /* FIX: Ensure button content doesn't get clipped (Bug 1) */
            line-height: 1.2;
            min-height: 32px; 
        }

        .btn:hover:not(:disabled) {
            opacity: 0.9;
        }

        .btn:active:not(:disabled) {
            transform: scale(0.98);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: default;
            transform: scale(1);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--color-border);
            color: var(--color-text-primary);
        }
        
        .btn-danger {
            background-color: var(--color-danger);
            color: white;
        }

        .btn-end-game {
             background-color: var(--color-panel-bg);
             color: var(--color-danger);
             border: 1px solid var(--color-danger);
             margin-left: auto;
        }
        .btn-end-game:hover:not(:disabled) {
            background-color: var(--color-danger);
            color: white;
        }


        .speed-selector {
            display: flex;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            overflow: hidden;
        }

        .speed-btn {
            padding: 8px 10px;
            background-color: var(--color-panel-bg);
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .speed-btn.active {
            background-color: var(--color-primary);
            color: white;
        }

        .speed-btn:not(:last-child) {
            border-right: 1px solid var(--color-border);
        }

        /* 6. Sidebar (Trading Panel) */
        
        /* 6.0 Game Objective (Now hidden by default) */
        .challenge-info {
            display: none; /* Hidden as requested */
        }

        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            /* FIX: Prevent tabs from shrinking (Bug 2) */
            flex-shrink: 0; 
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            background-color: var(--color-bg);
            border: none;
            font-weight: bold;
        }

        .tab-btn.active {
            background-color: var(--color-panel-bg);
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-primary);
        }

        /* FIX: Wrapper for tab content to manage overflow (V6.1) */
        .tabs-wrapper {
            flex: 1;
            overflow: hidden; /* Constrains the tab-content within the wrapper */
            display: flex;
            flex-direction: column;
            /* NEW FIX: Crucial for flex children with overflow in complex layouts */
            min-height: 0; 
        }

        .tab-content {
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 15px;
            /* FIX: Fill the wrapper and allow internal scrolling */
            flex-grow: 1;
            overflow-y: auto; 
            /* height: 100%; // REMOVED: Redundant and conflicting */
        }

        .tab-content.active {
            display: flex;
        }

        /* 6.1 Order Panel */
        /* ... (Styles for Order Panel remain unchanged) ... */
        .order-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-label {
            font-size: 14px;
            color: var(--color-text-secondary);
            text-align: center;
        }

        .input-field {
            /* FIX: Reduced padding slightly to prevent clipping (Bug 1) */
            padding: 8px 5px; 
            border: 1px solid var(--color-border);
            font-size: 16px;
            text-align: center;
            width: 100%;
             -moz-appearance: textfield;
        }

        .input-field::-webkit-outer-spin-button,
        .input-field::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-stepper {
            display: flex;
            align-items: stretch;
        }

        .stepper-btn {
            width: 30px;
            background-color: var(--color-border);
            border: 1px solid var(--color-border);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        .stepper-btn:active {
            background-color: var(--color-primary);
            color: white;
        }

        .stepper-btn:first-child {
            border-top-left-radius: var(--radius-main);
            border-bottom-left-radius: var(--radius-main);
            border-right: none;
        }

        .stepper-btn:last-child {
            border-top-right-radius: var(--radius-main);
            border-bottom-right-radius: var(--radius-main);
            border-left: none;
        }

        .input-stepper .input-field {
            border-radius: 0;
            flex: 1;
            min-width: 0;
        }
        
        .input-estimate {
            font-size: 12px;
            color: var(--color-text-secondary);
            text-align: center;
            height: 18px;
        }


        .trade-actions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .btn-trade {
            /* FIX: Reduced padding slightly (Bug 1) */
            padding: 10px; 
            font-size: 18px;
            color: white;
        }

        .btn-buy {
            background-color: var(--color-bull);
        }

        .btn-sell {
            background-color: var(--color-bear);
        }

        .btn-close-all {
            background-color: var(--color-neutral);
            color: white;
            font-size: 16px;
        }


        /* 6.2 Positions & History */
        /* ... (Styles for Positions & History remain unchanged) ... */
        .positions-list, .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* overflow-y: auto; Handled by tab-content now */
            /* flex-grow: 1; */
        }

        .trade-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            padding: 10px;
            font-size: 14px;
        }

        .trade-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .trade-type.BUY { color: var(--color-bull); }
        .trade-type.SELL { color: var(--color-bear); }

        .trade-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .trade-detail-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .trade-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* 7. Modals & Overlays */
        /* ... (Styles for Modals remain unchanged) ... */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--color-panel-bg);
            padding: 30px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            max-width: 550px;
            width: 90%;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            max-height: 90vh;
            /* FIX: Ensure modal content scrolls if achievements overflow (Bug 4) */
            overflow-y: auto; 
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .modal-body {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .cta-button {
            background-color: var(--color-success);
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            letter-spacing: 1px;
            text-decoration: none;
        }

        /* 7.1 Tutorial Specific */
        .tutorial-highlight {
            position: absolute;
            border: 3px dashed var(--color-primary);
            border-radius: var(--radius-main);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            z-index: 1001;
            pointer-events: none;
            transition: top 0.3s, left 0.3s, width 0.3s, height 0.3s;
        }

        .tutorial-message {
            position: absolute;
            background-color: var(--color-primary);
            color: white;
            padding: 15px;
            border-radius: var(--radius-main);
            max-width: 300px;
            z-index: 1002;
            box-shadow: var(--shadow-main);
            transition: top 0.3s, left 0.3s;
        }
        
        /* 7.2 Achievements */
        .achievements-section {
            margin-top: 25px;
            border-top: 1px solid var(--color-border);
            padding-top: 15px;
            text-align: left;
        }
        .achievements-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            list-style-type: none;
            padding: 0;
            margin-top: 10px;
        }
        @media (max-width: 500px) {
            .achievements-list {
                grid-template-columns: 1fr; /* Single column on mobile */
            }
        }

        .achievement-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-main);
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        .achievement-icon {
            font-size: 20px;
            /* color: var(--color-warning); Removed to allow emoji colors */
        }
        
        /* 7.3 Achievement Notifications (Toasts) */
        #notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1010;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        @media (max-width: 900px) {
            #notification-container {
                top: 60px; /* Move below header on mobile/tablet */
                right: 10px;
                left: 10px;
                align-items: center;
            }
        }

        .notification-toast {
            background-color: var(--color-primary-dark);
            color: white;
            padding: 15px 20px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            display: flex;
            flex-direction: column; /* Changed layout for better readability */
            align-items: flex-start;
            gap: 5px;
            max-width: 350px;
            width: 100%;
            /* Animation */
            opacity: 0;
            transform: translateY(-20px); /* Changed animation style */
            transition: opacity 0.5s, transform 0.5s;
        }
        .notification-toast.show {
            opacity: 1;
            transform: translateY(0);
        }


        /* 8. Utilities & Loader */
        .hidden {
            display: none !important;
        }

        .loader-wrap {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            gap: 20px;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 9. File Upload Fallback */
        .file-upload-prompt {
            background-color: var(--color-panel-bg);
            padding: 30px;
            border-radius: var(--radius-main);
            box-shadow: var(--shadow-main);
            border: 1px solid var(--color-border);
            max-width: 450px;
        }
    </style>
</head>
<body>
    <!-- Loader -->
    <div class="loader-wrap" id="loader">
        <div id="loader-status">
            <div class="loading-spinner"></div>
            <p>正在載入數據與初始化圖表...</p>
        </div>
        <!-- Fallback File Upload -->
        <div id="fileUploadFallback" class="file-upload-prompt hidden">
            <p style="color: var(--color-danger); margin-bottom: 15px; font-weight: bold;">⚠️ 數據載入失敗</p>
            <p id="loader-error-message" style="margin-bottom: 15px;"></p>
            <p>這可能是由於瀏覽器的本地檔案存取限制 (CORS) 或檔案格式不正確。</p>
            <p style="margin-bottom: 20px;">請手動上傳 <strong>XAUUSD_M15.csv</strong> 檔案以繼續：</p>
            <input type="file" id="csvFileInput" accept=".csv">
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container"></div>

    <!-- Header (HUD) -->
    <header class="header">
        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">模擬日期</span>
                <span class="hud-value" id="hud-date">--/--/-- --:--</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">帳戶淨值</span>
                <span class="hud-value" id="hud-equity">$10000.00</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">浮動損益</span>
                <span class="hud-value" id="hud-pl">$0.00</span>
            </div>
        </div>
        <div class="hud-right">
            <div class="hud-item">
                <span class="hud-label">花費時間</span>
                <span class="hud-value" id="hud-timer">00:00</span>
            </div>
            <div class="hud-item progress-container">
                <span class="hud-label">挑戰進度</span>
                <div class="progress-bar">
                    <div class="progress-fill" id="hud-progress"></div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        
        <!-- Chart Area -->
        <div class="chart-container">
            <div class="controls">
                <button class="btn btn-primary" id="btnPlayPause">▶️ 播放</button>
                <button class="btn btn-secondary" id="btnStepForward">➡️ 逐K前進</button>
                <div class="speed-selector" id="speedSelector">
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="5">5x</button>
                    <button class="speed-btn" data-speed="20">20x</button>
                    <button class="speed-btn" data-speed="40">40x</button>
                </div>
                <button class="btn btn-secondary" id="btnZoomIn">🔍+</button>
                <button class="btn btn-secondary" id="btnZoomOut">🔍-</button>
                <button class="btn btn-end-game" id="btnEndGame">結束挑戰</button>
            </div>

            <div class="chart-wrap" id="chartWrap">
                <canvas id="chartCanvas"></canvas>
                <div class="chart-overlay" id="chartOverlay">
                    <!-- Position lines -->
                </div>
            </div>
        </div>

        <!-- Sidebar (Trading Panel) -->
        <aside class="sidebar">
            <!-- Hidden Challenge Info (for tutorial access) -->
            <div class="challenge-info" id="challengeInfo">
                <h4>🏆 30天交易挑戰</h4>
                <p>從隨機歷史日期開始，在一個月內盡力獲取最高收益！</p>
            </div>

            <div class="panel-tabs">
                <button class="tab-btn active" data-target="tabOrder">交易</button>
                <button class="tab-btn" data-target="tabPositions">持倉 (<span id="positionsCount">0</span>)</button>
                <button class="tab-btn" data-target="tabHistory">紀錄</button>
            </div>

            <!-- FIX: Added wrapper for proper layout and overflow handling (Bug 2) -->
            <div class="tabs-wrapper">
                <div class="tab-content active" id="tabOrder">
                    <div class="order-grid">
                        
                        <div class="input-group">
                            <label class="input-label">停損 (SL)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="slDown">−</button>
                                <input type="number" class="input-field" id="inputSL" placeholder="價格" step="0.1" min="0">
                                <button class="stepper-btn" id="slUp">+</button>
                            </div>
                            <div class="input-estimate" id="estimateSL"></div>
                        </div>

                        <div class="input-group">
                            <label class="input-label">手數 (Lots)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="lotsDown">−</button>
                                <input type="number" class="input-field" id="inputLots" value="0.10" step="0.01" min="0.01">
                                <button class="stepper-btn" id="lotsUp">+</button>
                            </div>
                            <div class="input-estimate"></div>
                        </div>

                        <div class="input-group">
                            <label class="input-label">停利 (TP)</label>
                            <div class="input-stepper">
                                <button class="stepper-btn" id="tpDown">−</button>
                                <input type="number" class="input-field" id="inputTP" placeholder="價格" step="0.1" min="0">
                                <button class="stepper-btn" id="tpUp">+</button>
                            </div>
                            <div class="input-estimate" id="estimateTP"></div>
                        </div>
                    </div>

                    <div class="trade-actions-grid">
                        <button class="btn btn-trade btn-sell" id="btnSell">賣出</button>
                        <button class="btn btn-trade btn-close-all" id="btnCloseAllTab">全部平倉</button>
                        <button class="btn btn-trade btn-buy" id="btnBuy">買入</button>
                    </div>
                </div>

                <div class="tab-content" id="tabPositions">
                    <div class="positions-list" id="positionsList">
                        <!-- Positions -->
                    </div>
                </div>

                <div class="tab-content" id="tabHistory">
                    <div class="history-list" id="historyList">
                        <!-- History -->
                    </div>
                </div>
            </div>
             <!-- End of wrapper -->
        </aside>
    </div>
    
    <!-- Footer -->
    <footer class="footer">
        本互動遊戲廣告由 <a href="https://www.massenlighten.com/" target="_blank">眾曜智庫</a> 提供
    </footer>

    <!-- Modals -->
    <div class="modal-overlay" id="eventModal">
        <div class="modal-content">
            <h2 class="modal-title" id="eventTitle">⚠️ 重大財經事件</h2>
            <div class="modal-body" id="eventBody" style="text-align: left;">
                <!-- Event details here -->
            </div>
            <button class="btn btn-primary" id="eventContinueBtn">繼續模擬</button>
        </div>
    </div>

    <div class="modal-overlay" id="endGameModal">
        <div class="modal-content">
            <h2 class="modal-title">🎉 挑戰結束！</h2>
            <div class="modal-body" style="text-align: center;">
                <p>您的最終成績：</p>
                <h1 id="finalScore" style="font-size: 36px; margin: 10px 0;">$10000.00</h1>
                <p id="finalRoR" style="font-size: 20px;"></p>
                <p id="finalTime" style="font-size: 16px; color: var(--color-text-secondary);"></p>
                
                <div id="endGameStats" style="text-align: left; margin-top: 20px; padding-top: 10px; border-top: 1px solid var(--color-border);"></div>
                
                <div class="achievements-section" id="achievementsSection">
                    <h3>🏆 已解鎖成就</h3>
                    <ul class="achievements-list" id="achievementsList">
                        <!-- Achievements -->
                    </ul>
                </div>

            </div>
            <a href="https://www.massenlighten.com/soya%E5%A5%B3%E7%A5%9E" target="_blank" class="btn cta-button" id="ctaButton">了解如何取得高分</a>
            <button class="btn btn-secondary" id="restartButton" style="margin-top: 15px;">重新挑戰</button>
        </div>
    </div>

    <!-- Tutorial Elements -->
    <div class="tutorial-highlight hidden" id="tutorialHighlight"></div>
    <div class="tutorial-message hidden" id="tutorialMessage">
        <p id="tutorialText"></p>
        <button class="btn btn-small" id="tutorialNextBtn" style="margin-top: 10px; background-color: white; color: var(--color-primary);">下一步</button>
    </div>

    <script>
        // ============================================================================
        // 專案：XAUUSD 交易模擬 Playable Ad (Rework V6.2 - INTERACTION & TUTORIAL FIX)
        // ============================================================================

        // ----------------------------------------------------------------------------
        // 1. 狀態管理與常數 (State Management & Constants)
        // ----------------------------------------------------------------------------

        const CONFIG = {
            DATA_URL: 'XAUUSD_M15.csv',
            TICK_INTERVAL: 500,
            CHART_PADDING: { top: 20, right: 60, bottom: 30, left: 10 },
            CANDLE_WIDTH_DEFAULT: 8,
            CANDLE_SPACING: 3,
            CONTRACT_SIZE: 100,
            INITIAL_BALANCE: 10000,
            SIMULATION_DURATION_DAYS: 30,
        };

        // UPDATED: New Achievements List (Feature 6)
        const ACHIEVEMENTS = {
            // 1. 新手上路
            FIRST_TRADE: { title: "新手上路", description: "剛開戶就上車，駕照還在影印中", icon: "🚗" },
            // 2. 荷包滿滿
            BIG_WIN: { title: "荷包滿滿", description: "一根長紅，帳戶變胖了！ (單筆獲利>$3000)", icon: "💰" },
            // 3. 忍痛停損
            BIG_LOSS: { title: "忍痛停損", description: "對帳單一打開，我直接見祖先 (單筆虧損>$3000)", icon: "💔" },
            // 4. 財神保佑
            WIN_STREAK_3: { title: "財神保佑", description: "三連紅，今天有神明附身 (連勝3筆)", icon: "🙏" },
            // 5. 這人急了
            LOSS_STREAK_3: { title: "這人急了", description: "每根K棒都能解讀成希望 (連虧3筆)", icon: "😰" },
            // 6. 凹單大師
            HOLD_LOSS_7D: { title: "凹單大師", description: "主力洗我我不怕，我有信仰 (持虧損倉>7天)", icon: "🧱" },
            // 7. 佛系操盤
            HOLD_WIN_7D: { title: "佛系操盤", description: "放著讓它噴，天命流最會賺 (持獲利倉>7天)", icon: "🧘" },
            // 8. 積少成多
            TRADER_10: { title: "積少成多", description: "韭菜每天割一點，主力都感動了 (累計10筆)", icon: "👨‍🌾" },
            // 9. 快槍俠 (Updated condition: 1 hour)
            QUICK_DRAW: { title: "快槍俠", description: "一敲就出場，我盤感來了 (1小時內獲利平倉)", icon: "⚡" },
            // 10. 翻倍！
            DOUBLE_UP: { title: "翻倍！", description: "阿嬤都說你該辭職全職操盤了 (淨值>$20000)", icon: "🚀" },
            // 11. 破產邊緣 (Updated condition: $2000)
            MARGIN_CALL: { title: "破產邊緣", description: "再跌我就要賣腎了啦！(淨值曾低於$2000)", icon: "📉" },
            // 12. 穩健獲利
            CONSISTENT: { title: "穩健獲利", description: "不當沖、不飆股，照樣噴到天花板 (結束時勝率>60%，且至少10筆)", icon: "🎯" },
            
            // NEW ACHIEVEMENTS
            // 13. 信仰之力
            DIAMOND_HANDS_LOSS: { title: "信仰之力", description: "就算跌停，我還是幫它按愛心 (單一虧損部位抱超過 30%虧損還沒出場)", icon: "💖" },
            // 14. 拉回買點
            AVERAGE_DOWN: { title: "拉回買點", description: "每次攤平，內心都默唸老師有交代 (對同一方向加碼 3 次以上)", icon: "📉📈" },
            // 15. 今天盤不好
            BAD_DAY: { title: "今天盤不好", description: "明明賠錢卻能講到像賺錢 (單日虧損交易三次)", icon: "🌧️" },
            // 16. 盤中抽筋
            RUG_PULL: { title: "盤中抽筋", description: "開高進場，收盤哭著關機 (同日內由獲利轉為虧損超過 $2000)", icon: "😱" },
        };


        const state = {
            rawData: [],
            gameData: [],
            isLoading: true,
            isPlaying: false,
            isEnded: false,
            speedMultiplier: 1,
            currentIndex: 0,
            barAnimationProgress: 0,
            balance: CONFIG.INITIAL_BALANCE,
            equity: CONFIG.INITIAL_BALANCE,
            floatingPL: 0,
            openPositions: [],
            tradeHistory: [],
            orderIdCounter: 1,
            chart: {
                canvas: null,
                ctx: null,
                width: 0,
                height: 0,
                viewStartIndex: 0, 
                viewEndIndex: 0,
                minPrice: 0,
                maxPrice: 0,
                candleWidth: CONFIG.CANDLE_WIDTH_DEFAULT,
                candleSpacing: CONFIG.CANDLE_SPACING,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0, // NEW: For mobile touch distance calculation
                dragStartScroll: 0,
                scrollOffset: 0, 
                isCrosshairPinned: false, // NEW: For mobile touch interaction
                pinnedCrosshairPos: { x: 0, y: 0 }, // NEW
            },
            mouse: { x: -1, y: -1, isOverChart: false },
            isMobile: false, // NEW: Detect mobile/touch device
            tutorialActive: false,
            tutorialCompletedOnce: false,
            
            // Game Timer
            gameStartTime: null,
            elapsedTime: 0,
            timerIntervalId: null,

            // Achievements
            unlockedAchievements: new Set(),
            achievementStats: {
                consecutiveWins: 0,
                consecutiveLosses: 0,
                maxEquity: CONFIG.INITIAL_BALANCE,
                minEquity: CONFIG.INITIAL_BALANCE,
                // NEW TRACKERS (Feature 6)
                currentDay: null,
                dailyLossCount: 0,
                dailyMaxPL: 0, // Tracks the maximum P/L (equity - initial balance) reached during the day
            },

            financialEvents: [
                 { triggerDay: 5, title: '美國非農就業數據 (NFP)', description: '非農數據即將公布，市場預期將出現劇烈波動。請注意風險！' },
                { triggerDay: 15, title: '美國 CPI 公布', description: '消費者物價指數 (CPI) 高於預期，可能引發市場對通膨的擔憂。' },
                { triggerDay: 25, title: 'FOMC 利率決議', description: '聯準會即將宣布利率決議。市場普遍預期將維持現有利率。' },
            ],
            triggeredEvents: new Set(),
        };

        const DOM = {};

        // ----------------------------------------------------------------------------
        // 2. 數據處理 (Data Processing)
        // ----------------------------------------------------------------------------

        async function loadData() {
            try {
                const response = await fetch(CONFIG.DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP 錯誤! 狀態碼: ${response.status}`);
                }
                const csvText = await response.text();
                processData(csvText);
            } catch (error) {
                console.error("自動載入數據失敗:", error);
                let errorMessage = error.message;
                if (error instanceof TypeError && window.location.protocol === 'file:') {
                    errorMessage = "無法從本地檔案系統 (file://) 載入數據。這是瀏覽器的安全限制。";
                }
                promptForFileUpload(errorMessage);
            }
        }

        function promptForFileUpload(errorMessage) {
            document.getElementById('loader-status').classList.add('hidden');
            document.getElementById('fileUploadFallback').classList.remove('hidden');
            if (errorMessage) {
                document.getElementById('loader-error-message').textContent = errorMessage;
            }
            
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput.dataset.listenerAttached) return;
            fileInput.dataset.listenerAttached = true;

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const csvText = e.target.result;
                        document.getElementById('fileUploadFallback').classList.add('hidden');
                        document.getElementById('loader-status').classList.remove('hidden');
                        processData(csvText);
                    };
                    reader.readAsText(file, 'UTF-8');
                }
            });
        }

        function processData(csvText) {
            try {
                state.rawData = parseData(csvText);
                if (state.rawData.length === 0) {
                    throw new Error("無法解析數據或數據為空。請檢查 CSV 檔案格式、內容和編碼。");
                }
                startGame();
            } catch (error) {
                console.error("處理數據失敗:", error);
                promptForFileUpload(error.message);
            }
        }

        function parseData(csvText) {
            if (csvText.charCodeAt(0) === 0xFEFF) {
                csvText = csvText.substring(1);
            }

            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];

            const firstLine = lines.find(line => {
                const lowerLine = line.trim().toLowerCase();
                return lowerLine !== '' && !lowerLine.includes('time') && !lowerLine.includes('open');
            });

            if (!firstLine) return [];

            let delimiter = ',';
            if (firstLine.includes('\t') || (firstLine.includes(' ') && !firstLine.includes(','))) {
                delimiter = /\s+/;
            } else if (firstLine.includes(';')) {
                delimiter = ';';
            }

            const testParts = firstLine.split(delimiter);
            if (testParts.length < 5) return [];

            let timeFormat = 'unknown';
            if (testParts[0].match(/^\d{10,}$/)) {
                timeFormat = 'timestamp';
            } else if (testParts[0].match(/^\d{4}[\.\-\/]\d{2}[\.\-\/]\d{2}$/) && testParts.length > 1 && testParts[1].match(/^\d{2}:\d{2}/)) {
                timeFormat = 'datetime_separate';
            } else if (testParts[0].includes(':') || testParts[0].match(/^\d{4}[\.\-\/]\d{2}[\.\-\/]\d{2}/)) {
                timeFormat = 'datetime_combined';
            }
            
            const parsedData = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '' || line.toLowerCase().includes('open') || line.toLowerCase().includes('time')) continue;

                const values = line.split(delimiter);
                let timestamp, open, high, low, close;

                try {
                    if (timeFormat === 'timestamp') {
                        if (values.length < 5) continue;
                        timestamp = parseInt(values[0]);
                        if (timestamp < 10000000000) timestamp *= 1000;
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    } else if (timeFormat === 'datetime_separate') {
                        if (values.length < 6) continue;
                        const dateStr = `${values[0].replace(/[\.\/]/g, '-')} ${values[1]}`;
                        timestamp = new Date(dateStr).getTime();
                        open = parseFloat(values[2]);
                        high = parseFloat(values[3]);
                        low = parseFloat(values[4]);
                        close = parseFloat(values[5]);
                    } else if (timeFormat === 'datetime_combined') {
                        if (values.length < 5) continue;
                        timestamp = new Date(values[0].replace(/[\.\/]/g, '-')).getTime();
                        open = parseFloat(values[1]);
                        high = parseFloat(values[2]);
                        low = parseFloat(values[3]);
                        close = parseFloat(values[4]);
                    } else {
                        continue;
                    }

                    if (isNaN(timestamp) || timestamp <= 0 || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        continue;
                    }

                    parsedData.push({ time: timestamp, open, high, low, close });
                } catch (error) {
                    // Ignore parsing errors
                }
            }

            return parsedData.sort((a, b) => a.time - b.time);
        }

        // ----------------------------------------------------------------------------
        // 3. 遊戲初始化與流程控制 (Game Initialization & Flow Control)
        // ----------------------------------------------------------------------------

        function init() {
            console.log("Initializing application...");
            // NEW: Detect mobile device (simple check for touch support)
            state.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            cacheDOMElements();
            setupEventListeners();
            initChart();
            loadData();
        }

        function cacheDOMElements() {
            // HUD, Controls, Chart
            Object.assign(DOM, {
                hudDate: document.getElementById('hud-date'),
                hudEquity: document.getElementById('hud-equity'),
                hudPL: document.getElementById('hud-pl'),
                hudProgress: document.getElementById('hud-progress'),
                hudTimer: document.getElementById('hud-timer'),
                btnPlayPause: document.getElementById('btnPlayPause'),
                btnStepForward: document.getElementById('btnStepForward'),
                speedSelector: document.getElementById('speedSelector'),
                chartWrap: document.getElementById('chartWrap'),
                chartCanvas: document.getElementById('chartCanvas'),
                chartOverlay: document.getElementById('chartOverlay'),
            });
            // Sidebar Inputs & Lists
            Object.assign(DOM, {
                inputLots: document.getElementById('inputLots'),
                inputSL: document.getElementById('inputSL'),
                inputTP: document.getElementById('inputTP'),
                estimateSL: document.getElementById('estimateSL'),
                estimateTP: document.getElementById('estimateTP'),
                positionsList: document.getElementById('positionsList'),
                historyList: document.getElementById('historyList'),
                positionsCount: document.getElementById('positionsCount'),
                btnCloseAllTab: document.getElementById('btnCloseAllTab'),
            });
            // Modals, Tutorial, Notifications
            Object.assign(DOM, {
                loader: document.getElementById('loader'),
                eventModal: document.getElementById('eventModal'),
                endGameModal: document.getElementById('endGameModal'),
                tutorialHighlight: document.getElementById('tutorialHighlight'),
                tutorialMessage: document.getElementById('tutorialMessage'),
                tutorialText: document.getElementById('tutorialText'),
                tutorialNextBtn: document.getElementById('tutorialNextBtn'),
                notificationContainer: document.getElementById('notification-container'),
            });
        }

        function startGame() {
            if (state.rawData.length === 0) return;

            DOM.endGameModal.classList.remove('active');
            
            resetState();
            selectRandomDataSegment();

            if (state.gameData.length === 0) return;
            
            const initialVisibleCandles = calculateVisibleCandles();
            state.currentIndex = Math.min(Math.floor(initialVisibleCandles * 0.8), state.gameData.length - 1);
            
            // Initialize daily stats based on the starting point
            updateDailyStats();

            state.isLoading = false;
            DOM.loader.classList.add('hidden');
            
            startTimer();

            updateUI();
            requestAnimationFrame(draw);

            if (!state.tutorialCompletedOnce) {
                startTutorial();
            }
        }

        
        function resetState() {
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
                state.timerIntervalId = null;
            }

            state.balance = CONFIG.INITIAL_BALANCE;
            state.equity = CONFIG.INITIAL_BALANCE;
            state.floatingPL = 0;
            state.openPositions = [];
            state.tradeHistory = [];
            state.orderIdCounter = 1;
            state.isPlaying = false;
            state.isEnded = false;
            state.currentIndex = 0;
            state.barAnimationProgress = 0;
            state.triggeredEvents.clear();
            state.chart.candleWidth = CONFIG.CANDLE_WIDTH_DEFAULT;
            state.chart.candleSpacing = CONFIG.CANDLE_SPACING;
            state.chart.scrollOffset = 0;
            state.chart.isCrosshairPinned = false; // Reset pinned crosshair
            DOM.chartOverlay.innerHTML = '';
            DOM.positionsList.innerHTML = ''; // Ensure list is cleared
            DOM.historyList.innerHTML = '';
            
            // Reset Inputs
            DOM.inputLots.value = "0.10";
            DOM.inputSL.value = "";
            DOM.inputTP.value = "";

            // Reset Timer State
            state.gameStartTime = null;
            state.elapsedTime = 0;
            DOM.hudTimer.textContent = "00:00";

            // Reset Achievements
            state.unlockedAchievements.clear();
            state.achievementStats = {
                consecutiveWins: 0,
                consecutiveLosses: 0,
                maxEquity: CONFIG.INITIAL_BALANCE,
                minEquity: CONFIG.INITIAL_BALANCE,
                // NEW TRACKERS RESET
                currentDay: null,
                dailyLossCount: 0,
                dailyMaxPL: 0,
            };
        }

        function selectRandomDataSegment() {
            const totalDurationMs = CONFIG.SIMULATION_DURATION_DAYS * 24 * 60 * 60 * 1000;
            
            if (state.rawData.length === 0) return;

            const dataDuration = state.rawData[state.rawData.length - 1].time - state.rawData[0].time;

            if (dataDuration < totalDurationMs) {
                state.gameData = [...state.rawData];
                return;
            }

            const latestStartTime = state.rawData[state.rawData.length - 1].time - totalDurationMs;
            const earliestStartTime = state.rawData[0].time;
            const randomStartTime = earliestStartTime + Math.random() * (latestStartTime - earliestStartTime);

            let startIndex = state.rawData.findIndex(d => d.time >= randomStartTime);
            if (startIndex === -1) startIndex = 0;

            const startTime = state.rawData[startIndex].time;
            const endTime = startTime + totalDurationMs;

            state.gameData = state.rawData.filter(d => d.time >= startTime && d.time <= endTime);
        }


        let lastTickTime = 0;
        let animationFrameId;

        function gameLoop(timestamp) {
            if (!state.isPlaying || state.isEnded) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const effectiveInterval = CONFIG.TICK_INTERVAL / state.speedMultiplier;
            if (lastTickTime === 0) lastTickTime = timestamp;
            const deltaTime = timestamp - lastTickTime;

             if (deltaTime > 0) { 
                 const progressIncrement = deltaTime / effectiveInterval;
                 state.barAnimationProgress = Math.min(1, state.barAnimationProgress + progressIncrement);
                 
                 updateDailyStats(); // NEW: Update stats continuously
                 updatePositions();
                 updateAccount();
                 updateUI(); 

                 checkDurationAchievements();
                 checkDrawdownAchievement(); // NEW: Check RUG_PULL continuously

                 if (state.barAnimationProgress >= 1) {
                    finalizeCurrentBar();
                    if (!advanceSimulation()) {
                        endGame();
                        return;
                    }
                    state.barAnimationProgress = 0;
                    checkForEvents();
                    
                    if (state.chart.scrollOffset > 0) {
                        state.chart.scrollOffset++;
                    }
                 }
                 lastTickTime = timestamp;
            }
            
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function finalizeCurrentBar() {
            state.barAnimationProgress = 1;
            updatePositions();
            updateAccount();
        }

        function advanceSimulation() {
            if (state.currentIndex < state.gameData.length - 1) {
                state.currentIndex++;
                updateDailyStats(); // NEW: Update stats on step forward
                return true;
            }
            return false;
        }

        function endGame() {
            if (state.isEnded) return;

            console.log("Game Ended.");
            state.isPlaying = false;
            state.isEnded = true;
            cancelAnimationFrame(animationFrameId);

            stopTimer();
            
            // Close remaining positions
            if (state.gameData.length > 0) {
                let closeIndex = state.currentIndex;
                if (closeIndex >= state.gameData.length) {
                    closeIndex = state.gameData.length - 1;
                }
                const closePrice = state.gameData[closeIndex].close;

                while(state.openPositions.length > 0) {
                    // Ensure final trades count towards achievements (skipAchievementCheck=false)
                    closeOrder(state.openPositions[0].id, closePrice, false); 
                }
            }

            checkFinalAchievements();

            updateAccount();
            updateUI();
            showEndGameModal();
        }

        // Timer Functions
        function startTimer() {
            state.gameStartTime = Date.now();
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
            }
            state.timerIntervalId = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (state.gameStartTime && !state.isEnded) {
                state.elapsedTime = Math.floor((Date.now() - state.gameStartTime) / 1000);
                const minutes = Math.floor(state.elapsedTime / 60);
                const seconds = state.elapsedTime % 60;
                DOM.hudTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function stopTimer() {
            if (state.timerIntervalId) {
                clearInterval(state.timerIntervalId);
                state.timerIntervalId = null;
            }
        }


        // ----------------------------------------------------------------------------
        // 4. 圖表繪製與渲染 (Chart Drawing & Rendering)
        // ----------------------------------------------------------------------------
        
        function initChart() {
            state.chart.canvas = DOM.chartCanvas;
            state.chart.ctx = state.chart.canvas.getContext('2d');
            resizeCanvas();
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = DOM.chartWrap.getBoundingClientRect();
            const width = Math.max(1, Math.floor(rect.width));
            const height = Math.max(1, Math.floor(rect.height));

            if (state.chart.width !== width || state.chart.height !== height) {
                state.chart.canvas.width = width * dpr;
                state.chart.canvas.height = height * dpr;
                state.chart.canvas.style.width = `${width}px`;
                state.chart.canvas.style.height = `${height}px`;

                state.chart.ctx.scale(dpr, dpr);
                state.chart.width = width;
                state.chart.height = height;

                validateScrollOffset();
            }

            if (!state.isLoading) {
                draw();
            }
        }

        function draw() {
            if (state.isLoading || state.gameData.length === 0) return;

            const ctx = state.chart.ctx;
            ctx.clearRect(0, 0, state.chart.width, state.chart.height);

            calculateViewport();

            drawBackground(ctx);
            drawGrid(ctx);
            drawCandles(ctx);
            drawYAxis(ctx);
            drawXAxis(ctx);
            drawCrosshair(ctx);
            drawTradeAnimations(ctx);
            
            updatePositionOverlays();
        }

         function calculateVisibleCandles() {
            const { width, candleWidth, candleSpacing } = state.chart;
            const { left, right } = CONFIG.CHART_PADDING;
            const chartAreaWidth = width - left - right;
            const candleUnitWidth = candleWidth + candleSpacing;
            if (candleUnitWidth <= 0) return 100;
            return Math.max(1, Math.floor(chartAreaWidth / candleUnitWidth));
        }

        function calculateViewport() {
            const visibleCandles = calculateVisibleCandles();

            let endIndex = state.currentIndex + 1 - state.chart.scrollOffset;
            let startIndex = endIndex - visibleCandles;

            if (endIndex > state.currentIndex + 1) {
                endIndex = state.currentIndex + 1;
                startIndex = Math.max(0, endIndex - visibleCandles);
            }
            if (startIndex < 0) {
                startIndex = 0;
                endIndex = Math.min(state.currentIndex + 1, startIndex + visibleCandles);
            }
            
            state.chart.viewStartIndex = startIndex;
            state.chart.viewEndIndex = endIndex;

            // Calculate Price Range
            let minPrice = Infinity;
            let maxPrice = -Infinity;

            for (let i = startIndex; i < endIndex; i++) {
                if (i >= state.gameData.length || i < 0) continue; 

                const bar = state.gameData[i];

                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    const animatedBar = getAnimatedBar(bar);
                    minPrice = Math.min(minPrice, animatedBar.low);
                    maxPrice = Math.max(maxPrice, animatedBar.high);
                } else {
                    minPrice = Math.min(minPrice, bar.low);
                    maxPrice = Math.max(maxPrice, bar.high);
                }
            }

            // Add padding to price range
            const priceRange = maxPrice - minPrice;
            if (priceRange <= 0 || !isFinite(priceRange)) {
                const centerPrice = (minPrice === Infinity) ? (state.gameData[0]?.close || 1900) : minPrice;
                const padding = centerPrice * 0.001;
                state.chart.minPrice = centerPrice - padding;
                state.chart.maxPrice = centerPrice + padding;
            } else {
                const padding = priceRange * 0.1;
                state.chart.minPrice = minPrice - padding;
                state.chart.maxPrice = maxPrice + padding;
            }
        }


        // 座標轉換工具
        function priceToY(price) {
            const { height, minPrice, maxPrice } = state.chart;
            const { top, bottom } = CONFIG.CHART_PADDING;
            const chartAreaHeight = height - top - bottom;
            const priceRange = maxPrice - minPrice;
            
            if (chartAreaHeight <= 0 || priceRange <= 0) return top + chartAreaHeight / 2;

            const y = top + chartAreaHeight * (1 - (price - minPrice) / priceRange);
            return Math.max(top, Math.min(height - bottom, y));
        }

        function yToPrice(y) {
            const { height, minPrice, maxPrice } = state.chart;
            const { top, bottom } = CONFIG.CHART_PADDING;
            const chartAreaHeight = height - top - bottom;
            const priceRange = maxPrice - minPrice;

            if (chartAreaHeight <= 0) return (minPrice + maxPrice) / 2;

            const constrainedY = Math.max(top, Math.min(height - bottom, y));
            
            const price = minPrice + priceRange * (1 - (constrainedY - top) / chartAreaHeight);
            return price;
        }

        function indexToX(index) {
            const { viewStartIndex, candleWidth, candleSpacing } = state.chart;
            const { left } = CONFIG.CHART_PADDING;
            const candleUnitWidth = candleWidth + candleSpacing;
            return left + (index - viewStartIndex) * candleUnitWidth + candleWidth / 2;
        }

        // Drawing Functions Implementation
        function drawBackground(ctx) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(0, 0, state.chart.width, state.chart.height);
        }

        function drawGrid(ctx) {
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim();
            const dateSeparatorColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-date-separator').trim();
            const { left, right, top, bottom } = CONFIG.CHART_PADDING;

            // 1. Horizontal Grid Lines
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            const yTicks = calculateYAxisTicks();
            yTicks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.beginPath();
                ctx.moveTo(left, y);
                ctx.lineTo(state.chart.width - right, y);
                ctx.stroke();
            });

            // 2. Vertical Grid Lines & Date Separators
            const xTicks = calculateXAxisTicks();
            xTicks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= left && x <= state.chart.width - right) {
                    
                    if (tick.isDateSeparator) {
                        ctx.strokeStyle = dateSeparatorColor;
                        ctx.lineWidth = 1.5;
                    } else {
                        ctx.strokeStyle = gridColor;
                        ctx.lineWidth = 1;
                    }

                    ctx.beginPath();
                    ctx.moveTo(x, top);
                    ctx.lineTo(x, state.chart.height - bottom);
                    ctx.stroke();
                }
            });
            
            ctx.lineWidth = 1;
        }

        function getAnimatedBar(bar) {
            const progress = state.barAnimationProgress;
            const open = bar.open;
            
            const wickProgress = Math.min(1, progress * 2);
            const high = open + (bar.high - open) * wickProgress;
            const low = open + (bar.low - open) * wickProgress;

            const close = open + (bar.close - open) * progress;

            const finalHigh = Math.max(high, close, open);
            const finalLow = Math.min(low, close, open);

            return { open, high: finalHigh, low: finalLow, close };
        }

        function drawCandles(ctx) {
            const { viewStartIndex, viewEndIndex, candleWidth } = state.chart;
            const colorBull = getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim();
            const colorBear = getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                 if (i >= state.gameData.length || i < 0) continue;

                const bar = state.gameData[i];
                let displayBar = bar;

                if (i === state.currentIndex && state.chart.scrollOffset === 0) {
                    displayBar = getAnimatedBar(bar);
                }

                const x = indexToX(i);
                const openY = priceToY(displayBar.open);
                const highY = priceToY(displayBar.high);
                const lowY = priceToY(displayBar.low);
                const closeY = priceToY(displayBar.close);

                const color = displayBar.close >= displayBar.open ? colorBull : colorBear;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;

                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                const bodyTop = Math.min(openY, closeY);
                const bodyHeight = Math.abs(openY - closeY);
                
                const finalHeight = Math.max(1, bodyHeight);
                const finalWidth = Math.max(1, candleWidth);

                ctx.fillRect(x - finalWidth / 2, bodyTop, finalWidth, finalHeight);
            }
        }

        function calculateYAxisTicks() {
            const { minPrice, maxPrice, height } = state.chart;
            const priceRange = maxPrice - minPrice;
            if (priceRange <= 0) return [];
            const targetCount = Math.max(2, Math.floor(height / 50));
            const rawSpacing = priceRange / targetCount;
            const magnitude = Math.pow(10, Math.floor(Math.log10(rawSpacing)));
            const normalizedSpacing = rawSpacing / magnitude;

            let tickSpacing;
            if (normalizedSpacing > 5) tickSpacing = 10 * magnitude;
            else if (normalizedSpacing > 2) tickSpacing = 5 * magnitude;
            else if (normalizedSpacing > 1) tickSpacing = 2 * magnitude;
            else tickSpacing = magnitude;

            const ticks = [];
            let currentTick = Math.ceil(minPrice / tickSpacing) * tickSpacing;

            while (currentTick <= maxPrice) {
                if (isFinite(currentTick)) {
                    ticks.push({ price: currentTick });
                }
                currentTick += tickSpacing;
                if (tickSpacing === 0) break;
            }
            return ticks;
        }

        function drawYAxis(ctx) {
            const { width, height } = state.chart;
            const { right } = CONFIG.CHART_PADDING;
            const axisX = width - right;

            // Draw axis background and border
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(axisX, 0, right, height);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
            ctx.beginPath();
            ctx.moveTo(axisX, 0);
            ctx.lineTo(axisX, height);
            ctx.stroke();

            // Draw ticks
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            const ticks = calculateYAxisTicks();
            ticks.forEach(tick => {
                const y = priceToY(tick.price);
                ctx.fillText(tick.price.toFixed(2), axisX + 5, y);
            });

            // Draw current price indicator (Only if crosshair is NOT active and not pinned)
            const isCrosshairActive = (state.mouse.isOverChart || state.chart.isCrosshairPinned) && !state.chart.isDragging;

            if (state.currentIndex < state.gameData.length && state.chart.scrollOffset === 0 && !isCrosshairActive) {
                const currentPrice = getCurrentPrice();
                const currentY = priceToY(currentPrice);
                
                const color = currentPrice >= state.gameData[state.currentIndex].open 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim()
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();

                ctx.fillStyle = color;
                ctx.fillRect(axisX + 1, currentY - 10, right - 1, 20);
                
                ctx.fillStyle = 'white';
                ctx.fillText(currentPrice.toFixed(2), axisX + 5, currentY);
            }
        }

        function calculateXAxisTicks() {
            const { viewStartIndex, viewEndIndex, width } = state.chart;
            if (viewEndIndex <= viewStartIndex || viewStartIndex >= state.gameData.length) return [];

            const targetCount = Math.max(2, Math.floor(width / 100));
            const visibleCandles = viewEndIndex - viewStartIndex;
            const interval = Math.max(1, Math.round(visibleCandles / targetCount));

            const ticks = [];
            let lastDateStr = null;

            for (let i = viewStartIndex; i < viewEndIndex; i++) {
                if (i < 0 || i >= state.gameData.length) continue; // Safety check

                const time = state.gameData[i].time;
                const currentDate = new Date(time);
                const currentDateStr = currentDate.toDateString(); 

                let isDateSeparator = false;
                if (lastDateStr !== null && currentDateStr !== lastDateStr) {
                    isDateSeparator = true;
                }
                lastDateStr = currentDateStr;

                if (isDateSeparator || (i - viewStartIndex) % interval === 0) {
                     if (!ticks.some(t => t.index === i)) {
                        ticks.push({ index: i, time: time, isDateSeparator: isDateSeparator });
                     }
                }
            }
            return ticks;
        }

        function drawXAxis(ctx) {
            const { width, height } = state.chart;
            const { bottom, right, left } = CONFIG.CHART_PADDING;
            const axisY = height - bottom;

            // Draw axis background and border
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            ctx.fillRect(0, axisY, width, bottom);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border').trim();
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(width - right, axisY);
            ctx.stroke();

            // Draw ticks
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const ticks = calculateXAxisTicks();
            
            let timeDiff = 0;
            if (state.chart.viewEndIndex > state.chart.viewStartIndex && state.gameData.length > 0) {
                 // Safety check for indices
                const startIndex = Math.max(0, state.chart.viewStartIndex);
                const endIndex = Math.min(state.gameData.length - 1, state.chart.viewEndIndex - 1);
                
                if (endIndex >= startIndex) {
                    timeDiff = state.gameData[endIndex].time - state.gameData[startIndex].time;
                }
            }

            ticks.forEach(tick => {
                const x = indexToX(tick.index);
                if (x >= left && x <= width - right) {
                    const date = new Date(tick.time);
                    
                    let label;
                    
                    if (tick.isDateSeparator) {
                         label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' });
                         ctx.font = 'bold 12px sans-serif'; 
                    } else {
                        ctx.font = '12px sans-serif';
                        if (timeDiff < 48 * 3600 * 1000) {
                            label = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                        } else {
                            label = date.toLocaleDateString([], { month: 'numeric', day: 'numeric' });
                        }
                    }
                    
                    ctx.fillText(label, x, axisY + 5);
                }
            });
        }

        // Draw Crosshair (Handles both mouse hover and pinned touch)
        function drawCrosshair(ctx) {
            if (state.chart.isDragging) return;

            let x, y;

            // Determine crosshair source (Pinned or Mouse)
            if (state.chart.isCrosshairPinned) {
                x = state.chart.pinnedCrosshairPos.x;
                y = state.chart.pinnedCrosshairPos.y;
            } else if (state.mouse.isOverChart) {
                x = state.mouse.x;
                y = state.mouse.y;
            } else {
                return; // No source, don't draw
            }

            const { left, right, top, bottom } = CONFIG.CHART_PADDING;
            const { width, height } = state.chart;

            // Boundary check
            if (x < left || x > width - right || y < top || y > height - bottom) return;

            const crosshairColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-crosshair').trim();
            ctx.strokeStyle = crosshairColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(width - right, y);
            ctx.stroke();

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, height - bottom);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw Price Label
            const crosshairPrice = yToPrice(y);
            const axisX = width - right;

            ctx.fillStyle = crosshairColor;
            ctx.fillRect(axisX + 1, y - 10, right - 1, 20);
            
            ctx.fillStyle = 'white'; 
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(crosshairPrice.toFixed(2), axisX + 5, y);
        }

        function updatePositionOverlays() {
            const overlay = DOM.chartOverlay;
            const linesToKeep = new Set();

            state.openPositions.forEach(pos => {
                const entryId = `line-entry-${pos.id}`;
                const slId = `line-sl-${pos.id}`;
                const tpId = `line-tp-${pos.id}`;
                
                // 進場線
                const entryColor = pos.type === 'BUY' ? 'var(--color-bull)' : 'var(--color-bear)';
                createOrUpdatePositionLine(overlay, entryId, pos.entryPrice, entryColor, `進場價 ${pos.entryPrice.toFixed(2)}`, pos);
                linesToKeep.add(entryId);

                // SL 線
                if (pos.sl) {
                    const potentialPL = calculateProfit(pos, pos.sl);
                    createOrUpdatePositionLine(overlay, slId, pos.sl, 'var(--color-danger)', `停損 ${pos.sl.toFixed(2)}`, null, potentialPL);
                    linesToKeep.add(slId);
                }

                // TP 線
                if (pos.tp) {
                    const potentialPL = calculateProfit(pos, pos.tp);
                    createOrUpdatePositionLine(overlay, tpId, pos.tp, 'var(--color-success)', `停利 ${pos.tp.toFixed(2)}`, null, potentialPL);
                    linesToKeep.add(tpId);
                }
            });

            Array.from(overlay.children).forEach(child => {
                if (child.classList.contains('position-line') && !linesToKeep.has(child.id)) {
                    overlay.removeChild(child);
                }
            });
        }

        function createOrUpdatePositionLine(container, id, price, color, labelText, position = null, potentialPL = null) {
            let line = document.getElementById(id);
            if (!line) {
                line = document.createElement('div');
                line.id = id;
                line.className = 'position-line';
                
                // Layout: [Label] [P/L Display] [Dash]

                const label = document.createElement('div');
                label.className = 'position-label';
                line.appendChild(label); // 1. Label

                const plDisplay = document.createElement('div');
                plDisplay.className = 'position-pl';
                line.appendChild(plDisplay); // 2. P/L Display

                const dash = document.createElement('div');
                dash.className = 'position-line-dash';
                line.appendChild(dash); // 3. Dash

                container.appendChild(line);
            }

            const y = priceToY(price);
            
            // Visibility check
            if (y < CONFIG.CHART_PADDING.top || y > state.chart.height - CONFIG.CHART_PADDING.bottom) {
                line.style.opacity = 0;
            } else {
                line.style.opacity = 1;
                line.style.top = `${y - 10}px`; // Center vertically
            }
            
            line.style.width = `calc(100% - ${CONFIG.CHART_PADDING.right}px)`;

            // 更新內容和樣式
            const dash = line.querySelector('.position-line-dash');
            dash.style.borderTopColor = color;

            const label = line.querySelector('.position-label');
            label.style.backgroundColor = color;
            label.textContent = labelText;

            // 更新損益顯示
            const plDisplay = line.querySelector('.position-pl');
            let displayValue = null;

            if (position) {
                displayValue = position.profit;
            } else if (potentialPL !== null) {
                displayValue = potentialPL;
            }

            if (displayValue !== null) {
                plDisplay.textContent = `$${displayValue.toFixed(2)}`;
                plDisplay.style.color = displayValue >= 0 ? 'var(--color-success)' : 'var(--color-danger';
                plDisplay.style.display = 'block';
            } else {
                plDisplay.style.display = 'none';
            }
        }

        const tradeAnimations = [];

        function addTradeAnimation(type, price, index, profit = 0) {
            tradeAnimations.push({
                type,
                price,
                index,
                profit,
                startTime: performance.now(),
                duration: type === 'CLOSE' ? 1500 : 800,
            });
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function drawTradeAnimations(ctx) {
            const now = performance.now();
            let animationsRunning = false;

            for (let i = tradeAnimations.length - 1; i >= 0; i--) {
                const anim = tradeAnimations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);
                
                const opacity = 1 - progress;

                const x = indexToX(anim.index);
                const y = priceToY(anim.price);

                if (x < CONFIG.CHART_PADDING.left || x > state.chart.width - CONFIG.CHART_PADDING.right) {
                     if (progress >= 1) {
                        tradeAnimations.splice(i, 1);
                    } else {
                        animationsRunning = true;
                    }
                    continue;
                }

                ctx.globalAlpha = opacity;

                if (anim.type === 'BUY' || anim.type === 'SELL') {
                    const color = anim.type === 'BUY' ? getComputedStyle(document.documentElement).getPropertyValue('--color-bull').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-bear').trim();
                    ctx.fillStyle = color;
                    
                    const size = 12 + progress * 5; 
                    const offsetY = anim.type === 'BUY' ? 15 : -15;
                    
                    ctx.beginPath();
                    if (anim.type === 'BUY') {
                        ctx.moveTo(x, y + offsetY);
                        ctx.lineTo(x - size/2, y + offsetY + size);
                        ctx.lineTo(x + size/2, y + offsetY + size);
                    } else {
                        ctx.moveTo(x, y + offsetY);
                        ctx.lineTo(x - size/2, y + offsetY - size);
                        ctx.lineTo(x + size/2, y + offsetY - size);
                    }
                    ctx.closePath();
                    ctx.fill();

                } else if (anim.type === 'CLOSE') {
                    const color = anim.profit >= 0 ? getComputedStyle(document.documentElement).getPropertyValue('--color-success').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim();
                    ctx.fillStyle = color;
                    ctx.font = 'bold 18px sans-serif';
                    ctx.textAlign = 'center';
                    
                    const floatY = y - progress * 60; 
                    ctx.fillText(`$${anim.profit.toFixed(2)}`, x, floatY);
                }

                ctx.globalAlpha = 1;

                if (progress >= 1) {
                    tradeAnimations.splice(i, 1);
                } else {
                    animationsRunning = true;
                }
            }

            if (animationsRunning && !state.isPlaying) {
                requestAnimationFrame(draw); 
            }
        }


        // ----------------------------------------------------------------------------
        // 5. 交易邏輯與帳戶管理 (Trading Logic & Account Management)
        // ----------------------------------------------------------------------------

        function getCurrentPrice() {
            if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return 0;
            const currentBar = state.gameData[state.currentIndex];
            return getAnimatedBar(currentBar).close;
        }

         function openOrder(type, lots, sl = null, tp = null) {
            if (state.isEnded || state.gameData.length === 0) return;

            const entryPrice = getCurrentPrice();

            if (entryPrice <= 0) return;

            // Validation
            if (type === 'BUY') {
                if (sl && sl >= entryPrice) {
                    alert("買單 (BUY) 的停損價格 (SL) 必須低於進場價格。");
                    return;
                }
                if (tp && tp <= entryPrice) {
                    alert("買單 (BUY) 的停利價格 (TP) 必須高於進場價格。");
                    return;
                }
            } else { // SELL
                if (sl && sl <= entryPrice) {
                    alert("賣單 (SELL) 的停損價格 (SL) 必須高於進場價格。");
                    return;
                }
                if (tp && tp >= entryPrice) {
                    alert("賣單 (SELL) 的停利價格 (TP) 必須低於進場價格。");
                    return;
                }
            }

            const position = {
                id: state.orderIdCounter++,
                type: type,
                lots: lots,
                entryPrice: entryPrice,
                entryTime: state.gameData[state.currentIndex].time,
                sl: sl,
                tp: tp,
                profit: 0,
            };

            // NEW: Achievement Check - 14. 拉回買點 (AVERAGE_DOWN)
            const sameTypeCount = state.openPositions.filter(p => p.type === type).length;
            if (sameTypeCount + 1 >= 3) {
                unlockAchievement('AVERAGE_DOWN');
            }

            state.openPositions.push(position);

            addTradeAnimation(type, entryPrice, state.currentIndex);

            updateAccount();
            updateUI();
             if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function closeOrder(id, closePrice, skipAchievementCheck = false) {
            const index = state.openPositions.findIndex(p => p.id === id);
            if (index === -1) return;

            const position = state.openPositions[index];
            const profit = calculateProfit(position, closePrice);

            state.balance += profit;
            
            // Determine close time safely
            let closeTime;
            if (state.gameData && state.gameData.length > 0) {
                let closeIndex = state.currentIndex;
                if (closeIndex >= state.gameData.length) {
                    closeIndex = state.gameData.length - 1;
                }
                closeTime = state.gameData[closeIndex].time;
            } else {
                closeTime = position.entryTime;
            }

            const historyEntry = {
                ...position,
                closePrice: closePrice,
                closeTime: closeTime,
                profit: profit,
            };
            state.tradeHistory.push(historyEntry);
            
            state.openPositions.splice(index, 1);

            // Update achievement stats and check achievements
            if (!skipAchievementCheck) {
                updateAchievementStats(historyEntry);
                checkTradeAchievements(historyEntry);
            }

            addTradeAnimation('CLOSE', closePrice, Math.min(state.currentIndex, state.gameData.length - 1), profit);

            updateAccount();
            updateUI();
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }
         
         function calculateProfit(position, currentPrice) {
            let priceDiff = 0;
            if (position.type === 'BUY') {
                priceDiff = currentPrice - position.entryPrice;
            } else { // SELL
                priceDiff = position.entryPrice - currentPrice;
            }
            return priceDiff * CONFIG.CONTRACT_SIZE * position.lots;
        }

         function updatePositions() {
            if (state.currentIndex >= state.gameData.length || state.gameData.length === 0) return;

            const currentBar = state.gameData[state.currentIndex];
            const animatedBar = getAnimatedBar(currentBar);
            
            const currentPrice = animatedBar.close;
            const currentHigh = animatedBar.high;
            const currentLow = animatedBar.low;

            const positionsToClose = [];

            // Iterate over a copy because closeOrder modifies state.openPositions if triggered
            [...state.openPositions].forEach(pos => {
                // Check if position still exists (might have been closed by SL/TP already in this loop)
                // We use find by ID because the 'pos' object reference might be stale if updates happened
                if (!state.openPositions.find(p => p.id === pos.id)) return;

                pos.profit = calculateProfit(pos, currentPrice);

                // NEW: Achievement Check - 13. 信仰之力 (DIAMOND_HANDS_LOSS)
                if (pos.profit < 0) {
                    // Calculate loss percentage relative to the position value (Price * Size * Lots)
                    const positionValue = pos.entryPrice * CONFIG.CONTRACT_SIZE * pos.lots;
                    if (positionValue > 0) {
                        const lossPercentage = (Math.abs(pos.profit) / positionValue) * 100;
                        if (lossPercentage > 30) {
                            unlockAchievement('DIAMOND_HANDS_LOSS');
                        }
                    }
                }

                // Check SL/TP
                if (pos.type === 'BUY') {
                    if (pos.sl && currentLow <= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } 
                    // Use 'else if' to prevent SL and TP triggering on the same tick if they are very close
                    else if (pos.tp && currentHigh >= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                } else { // SELL
                    if (pos.sl && currentHigh >= pos.sl) {
                        positionsToClose.push({ id: pos.id, price: pos.sl, reason: 'SL' });
                    } 
                    else if (pos.tp && currentLow <= pos.tp) {
                        positionsToClose.push({ id: pos.id, price: pos.tp, reason: 'TP' });
                    }
                }
            });

            // Process closures uniquely
            const closedIds = new Set();
            positionsToClose.forEach(order => {
                if (!closedIds.has(order.id)) {
                    closeOrder(order.id, order.price);
                    closedIds.add(order.id);
                }
            });
        }

        function updateAccount() {
            state.floatingPL = state.openPositions.reduce((sum, pos) => sum + pos.profit, 0);
            state.equity = state.balance + state.floatingPL;

            // Track equity extremes
            if (state.equity > state.achievementStats.maxEquity) {
                state.achievementStats.maxEquity = state.equity;
            }
            if (state.equity < state.achievementStats.minEquity) {
                state.achievementStats.minEquity = state.equity;
            }

            checkEquityAchievements();
        }

        // ----------------------------------------------------------------------------
        // 6. UI 更新與互動 (UI Updates & Interaction)
        // ----------------------------------------------------------------------------

         function updateUI() {
            updateHUD();
            updatePositionsPanel();
            updateHistoryPanel();
            updateControls();
            updateOrderPanel();
        }

         function updateOrderPanel() {
            const hasPositions = state.openPositions.length > 0;
            DOM.btnCloseAllTab.disabled = !hasPositions || state.isEnded;
            
            updateEstimatedPL();
        }

         function updateEstimatedPL() {
            const lots = parseFloat(DOM.inputLots.value);
            const slPrice = parseFloat(DOM.inputSL.value);
            const tpPrice = parseFloat(DOM.inputTP.value);
            const currentPrice = getCurrentPrice();

            DOM.estimateSL.textContent = '';
            DOM.estimateTP.textContent = '';

            if (isNaN(lots) || lots <= 0 || currentPrice <= 0) {
                return;
            }

            // SL 估算
            if (!isNaN(slPrice) && slPrice > 0) {
                const slDistance = Math.abs(currentPrice - slPrice);
                const slPL = slDistance * CONFIG.CONTRACT_SIZE * lots;
                DOM.estimateSL.textContent = `預估損失: -$${slPL.toFixed(2)}`;
            }

            // TP 估算
            if (!isNaN(tpPrice) && tpPrice > 0) {
                const tpDistance = Math.abs(currentPrice - tpPrice);
                const tpPL = tpDistance * CONFIG.CONTRACT_SIZE * lots;
                DOM.estimateTP.textContent = `預估獲利: +$${tpPL.toFixed(2)}`;
            }
        }
        
        function updateHUD() {
            if (state.gameData.length === 0) return;

            let displayIndex = state.currentIndex;
            if (displayIndex >= state.gameData.length) {
                displayIndex = state.gameData.length - 1;
            }

            if (displayIndex < 0) return;

            const currentDate = new Date(state.gameData[displayIndex].time);
            DOM.hudDate.textContent = currentDate.toLocaleString('zh-TW', { 
                year: 'numeric', month: 'numeric', day: 'numeric', 
                hour: '2-digit', minute: '2-digit', hour12: false 
            });
            
            DOM.hudEquity.textContent = `$${state.equity.toFixed(2)}`;
            DOM.hudPL.textContent = `$${state.floatingPL.toFixed(2)}`;
            
            DOM.hudPL.classList.toggle('positive', state.floatingPL > 0);
            DOM.hudPL.classList.toggle('negative', state.floatingPL < 0);

            const progress = (displayIndex / (state.gameData.length - 1)) * 100;
            DOM.hudProgress.style.width = `${Math.min(100, progress)}%`;
        }

        // FIX V6.2: Optimized updatePositionsPanel to prevent DOM thrashing
        // This ensures buttons remain clickable even during rapid updates.
        function updatePositionsPanel() {
            DOM.positionsCount.textContent = state.openPositions.length;

            // 1. Get existing DOM elements
            const existingItems = DOM.positionsList.children;
            
            // 2. Identify current position IDs
            const currentIds = new Set(state.openPositions.map(p => p.id));

            // 3. Remove DOM elements for closed positions
            // Iterate backwards to safely remove elements while iterating
            for (let i = existingItems.length - 1; i >= 0; i--) {
                const item = existingItems[i];
                const id = parseInt(item.dataset.id);
                if (!currentIds.has(id)) {
                    DOM.positionsList.removeChild(item);
                }
            }

            // 4. Add new positions or Update existing ones
            // We iterate through state.openPositions to maintain order if needed, although order isn't strictly guaranteed here.
            state.openPositions.forEach(pos => {
                let item = DOM.positionsList.querySelector(`[data-id="${pos.id}"]`);

                if (!item) {
                    // Create new item if it doesn't exist
                    item = document.createElement('div');
                    item.className = 'trade-item';
                    item.dataset.id = pos.id;

                    // Initial HTML structure with placeholders for dynamic data
                    // We add specific classes (trade-profit, trade-sl, trade-tp) for easy selection later.
                    item.innerHTML = `
                        <div class="trade-header">
                            <span class="trade-type ${pos.type}">#${pos.id} ${pos.type === 'BUY' ? '買入' : '賣出'} ${pos.lots.toFixed(2)}手</span>
                            <span class="trade-profit"></span> <!-- Placeholder for profit -->
                        </div>
                        <div class="trade-details">
                            <div>
                                <div class="trade-detail-label">進場價</div>
                                <div>${pos.entryPrice.toFixed(2)}</div>
                            </div>
                            <div>
                                <div class="trade-detail-label">停損(SL)</div>
                                <div class="trade-sl"></div> <!-- Placeholder for SL -->
                            </div>
                            <div>
                                <div class="trade-detail-label">停利(TP)</div>
                                <div class="trade-tp"></div> <!-- Placeholder for TP -->
                            </div>
                        </div>
                        <div class="trade-actions">
                            <button class="btn btn-small btn-secondary btn-modify">修改</button>
                            <button class="btn btn-small btn-danger btn-close">平倉</button>
                        </div>
                    `;
                    // Append the new item. If we needed strict ordering (e.g., newest first), we'd adjust insertion logic.
                    DOM.positionsList.appendChild(item);
                }

                // Update dynamic parts (Profit, SL, TP)
                const profitElement = item.querySelector('.trade-profit');
                const slElement = item.querySelector('.trade-sl');
                const tpElement = item.querySelector('.trade-tp');

                const profitColor = pos.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)';
                
                // Only update if changed (minor optimization)
                const newProfitText = `$${pos.profit.toFixed(2)}`;
                if (profitElement.textContent !== newProfitText) {
                    profitElement.textContent = newProfitText;
                    profitElement.style.color = profitColor;
                }
                
                const newSLText = pos.sl ? pos.sl.toFixed(2) : 'N/A';
                if (slElement.textContent !== newSLText) {
                    slElement.textContent = newSLText;
                }

                const newTPText = pos.tp ? pos.tp.toFixed(2) : 'N/A';
                if (tpElement.textContent !== newTPText) {
                    tpElement.textContent = newTPText;
                }
            });

            // Note: Event listeners are handled by Event Delegation in setupEventListeners (Bug 3 fix from V6.1), 
            // so we don't need to re-attach them here.
        }

        function updateHistoryPanel() {
            if (DOM.historyList.children.length === state.tradeHistory.length) return;

            DOM.historyList.innerHTML = '';
            const sortedHistory = [...state.tradeHistory].reverse();

            sortedHistory.forEach(trade => {
                const item = document.createElement('div');
                item.className = 'trade-item';
                
                const profitColor = trade.profit >= 0 ? 'var(--color-success)' : 'var(--color-danger)';

                item.innerHTML = `
                    <div class="trade-header">
                        <span class="trade-type ${trade.type}">#${trade.id} ${trade.type === 'BUY' ? '買入' : '賣出'} ${trade.lots.toFixed(2)}手</span>
                        <span style="color: ${profitColor}">$${trade.profit.toFixed(2)}</span>
                    </div>
                    <div class="trade-details">
                        <div>
                            <div class="trade-detail-label">開倉價</div>
                            <div>${trade.entryPrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">平倉價</div>
                            <div>${trade.closePrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div class="trade-detail-label">持有時間</div>
                            <div>${formatDuration(trade.closeTime - trade.entryTime)}</div>
                        </div>
                    </div>
                `;
                DOM.historyList.appendChild(item);
            });
        }

        function updateControls() {
            DOM.btnPlayPause.textContent = state.isPlaying ? '⏸️ 暫停' : '▶️ 播放';
            DOM.btnStepForward.disabled = state.isPlaying || state.isEnded;
            DOM.btnPlayPause.disabled = state.isEnded;
            document.getElementById('btnBuy').disabled = state.isEnded;
            document.getElementById('btnSell').disabled = state.isEnded;
            document.getElementById('btnEndGame').disabled = state.isEnded;
        }

        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);

            // Controls
            DOM.btnPlayPause.addEventListener('click', togglePlayPause);
            DOM.btnStepForward.addEventListener('click', stepForward);
            DOM.speedSelector.addEventListener('click', handleSpeedChange);
            document.getElementById('btnZoomIn').addEventListener('click', () => zoomChart(1.2));
            document.getElementById('btnZoomOut').addEventListener('click', () => zoomChart(1/1.2));
            document.getElementById('btnEndGame').addEventListener('click', handleEndGameClick);


            // Trading Panel Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', handleTabSwitch);
            });

            // Order Inputs (Steppers)
            // FIX: Updated steps (Feature 5). Lots 0.1. Price 5.0.
            setupInputStepper('lotsUp', 'inputLots', 0.1);
            setupInputStepper('lotsDown', 'inputLots', -0.1);
            setupInputStepper('slUp', 'inputSL', 5.0);
            setupInputStepper('slDown', 'inputSL', -5.0);
            setupInputStepper('tpUp', 'inputTP', 5.0);
            setupInputStepper('tpDown', 'inputTP', -5.0);

            // Input change listeners for P/L estimation
            DOM.inputLots.addEventListener('input', updateEstimatedPL);
            DOM.inputSL.addEventListener('input', updateEstimatedPL);
            DOM.inputTP.addEventListener('input', updateEstimatedPL);


            // Trade Buttons
            document.getElementById('btnBuy').addEventListener('click', () => handleTrade('BUY'));
            document.getElementById('btnSell').addEventListener('click', () => handleTrade('SELL'));
            DOM.btnCloseAllTab.addEventListener('click', closeAllOrders);

            // FIX: Event Delegation for Positions List (Bug 3)
            // This mechanism works correctly with the optimized updatePositionsPanel.
            DOM.positionsList.addEventListener('click', (e) => {
                const target = e.target;
                const tradeItem = target.closest('.trade-item');
                if (!tradeItem) return;

                const id = parseInt(tradeItem.dataset.id);

                // Check if the ID is still valid (position exists)
                if (!state.openPositions.find(p => p.id === id)) return;

                if (target.classList.contains('btn-close')) {
                    const currentPrice = getCurrentPrice();
                    closeOrder(id, currentPrice);
                } else if (target.classList.contains('btn-modify')) {
                    modifyOrder(id);
                }
            });


            // Chart Interaction (Mouse)
            DOM.chartWrap.addEventListener('mousemove', handleMouseMove);
            DOM.chartWrap.addEventListener('mouseleave', handleMouseLeave);
            DOM.chartWrap.addEventListener('wheel', handleMouseWheel, { passive: false });
            DOM.chartWrap.addEventListener('mousedown', handleDragStart);
            window.addEventListener('mousemove', handleDragging);
            window.addEventListener('mouseup', handleDragEnd);

            // Chart Interaction (Touch)
            DOM.chartWrap.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd);


            // Modal Buttons
            document.getElementById('eventContinueBtn').addEventListener('click', continueFromEvent);
            document.getElementById('restartButton').addEventListener('click', startGame);
        }
        
        function handleEndGameClick() {
            if (state.isEnded) return;
            
            // Pause game before confirmation
            if (state.isPlaying) {
                togglePlayPause();
            }

            if (confirm("確定要提前結束本次挑戰嗎？")) {
                endGame();
            }
        }

        // Event Handlers Implementation
         function togglePlayPause() {
            if (state.isEnded) return;
            state.isPlaying = !state.isPlaying;
            
            if (state.isPlaying) {
                lastTickTime = 0; 
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                cancelAnimationFrame(animationFrameId);
            }
            updateControls();
        }

        function stepForward() {
            if (state.isPlaying || state.isEnded) return;
            
            finalizeCurrentBar();
            
            if (!advanceSimulation()) {
                endGame();
            } else {
                state.barAnimationProgress = 1; 
                updatePositions();
                updateAccount();
                checkDurationAchievements(); // Check achievements on manual step
                checkDrawdownAchievement(); // NEW
                updateUI();
                checkForEvents();
                
                if (state.chart.scrollOffset > 0) {
                    state.chart.scrollOffset = Math.max(0, state.chart.scrollOffset - 1);
                }
                requestAnimationFrame(draw);
            }
        }
        
        function handleSpeedChange(e) {
            if (e.target.classList.contains('speed-btn')) {
                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                state.speedMultiplier = parseInt(e.target.dataset.speed);
                lastTickTime = 0;
            }
        }

        // FIX: Updated function to re-evaluate tutorial highlight on tab switch (V6.2)
        function handleTabSwitch(e) {
            const target = e.target.closest('.tab-btn');
            if (!target) return;

            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            target.classList.add('active');
            document.getElementById(target.dataset.target).classList.add('active');

            // FIX: Re-evaluate the tutorial highlight after the layout changes (V6.2)
            // This prevents the overlay from blocking the UI if the target element is now hidden.
            if (state.tutorialActive) {
                // Use a slight delay to ensure the DOM is updated (CSS transitions finished) before recalculating bounds
                setTimeout(showTutorialStep, 50); 
            }
        }

        function handleTrade(type) {
            const lots = parseFloat(DOM.inputLots.value);
            const sl = DOM.inputSL.value ? parseFloat(DOM.inputSL.value) : null;
            const tp = DOM.inputTP.value ? parseFloat(DOM.inputTP.value) : null;

            if (isNaN(lots) || lots < 0.01) {
                alert("請輸入有效的手數 (Lots)，最小為 0.01。");
                return;
            }
            
            if (sl !== null && (isNaN(sl) || sl <= 0)) {
                 alert("停損價格 (SL) 必須是正數。");
                return;
            }
             if (tp !== null && (isNaN(tp) || tp <= 0)) {
                alert("停利價格 (TP) 必須是正數。");
                return;
            }

            openOrder(type, lots, sl, tp);
        }

        function closeAllOrders() {
            if (state.openPositions.length === 0 || state.isEnded) return;
            
            const currentPrice = getCurrentPrice();
            // Iterate over a copy to safely modify the original array
            [...state.openPositions].forEach(pos => {
                closeOrder(pos.id, currentPrice);
            });
        }

        function modifyOrder(id) {
            const position = state.openPositions.find(p => p.id === id);
            if (!position) return;

            // Pause game when modifying order
            if (state.isPlaying) {
                togglePlayPause();
            }

            const currentSL = position.sl ? position.sl.toFixed(2) : '';
            const currentTP = position.tp ? position.tp.toFixed(2) : '';

            const newSLInput = prompt(`修改訂單 #${id} 停損 (SL)。\n進場價: ${position.entryPrice.toFixed(2)}\n留空則取消 SL。目前值: ${currentSL}`, currentSL);
            
            if (newSLInput === null) return;

            const newTPInput = prompt(`修改訂單 #${id} 停利 (TP)。\n進場價: ${position.entryPrice.toFixed(2)}\n留空則取消 TP。目前值: ${currentTP}`, currentTP);

            if (newTPInput === null) return;

            let newSL = null;
            if (newSLInput !== '') {
                newSL = parseFloat(newSLInput);
                if (isNaN(newSL) || newSL <= 0) {
                    alert("無效的 SL 價格。");
                    return;
                }
                if (position.type === 'BUY' && newSL >= position.entryPrice) {
                    alert("買單的停損必須低於進場價。");
                    return;
                } else if (position.type === 'SELL' && newSL <= position.entryPrice) {
                    alert("賣單的停損必須高於進場價。");
                    return;
                }
            }

            let newTP = null;
            if (newTPInput !== '') {
                newTP = parseFloat(newTPInput);
                if (isNaN(newTP) || newTP <= 0) {
                    alert("無效的 TP 價格。");
                    return;
                }
                if (position.type === 'BUY' && newTP <= position.entryPrice) {
                    alert("買單的停利必須高於進場價。");
                    return;
                } else if (position.type === 'SELL' && newTP >= position.entryPrice) {
                    alert("賣單的停利必須低於進場價。");
                    return;
                }
            }

            position.sl = newSL;
            position.tp = newTP;
            
            updateUI();
            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        
        // Chart Interaction Handlers (Mouse & Touch)
        
        function handleMouseMove(e) {
            const rect = DOM.chartWrap.getBoundingClientRect();
            state.mouse.x = e.clientX - rect.left;
            state.mouse.y = e.clientY - rect.top;
            state.mouse.isOverChart = true;

            // Unpin crosshair on mouse move (Desktop behavior)
            if (state.chart.isCrosshairPinned && !state.isMobile) {
                state.chart.isCrosshairPinned = false;
            }
            
            if (!state.isPlaying && !state.chart.isDragging) {
                 requestAnimationFrame(draw);
            }
        }

        function handleMouseLeave() {
            state.mouse.isOverChart = false;
             if (!state.isPlaying && !state.chart.isDragging) {
                requestAnimationFrame(draw);
            }
        }

        function handleMouseWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
            zoomChart(zoomFactor);
        }

        function zoomChart(factor) {
            const newWidth = state.chart.candleWidth * factor;
            const newSpacing = state.chart.candleSpacing * factor;

            if (newWidth < 2 || newWidth > 50) return;

            state.chart.candleWidth = newWidth;
            state.chart.candleSpacing = newSpacing;

            validateScrollOffset();

            if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }


        // Panning (Dragging) Logic
        function handleDragStart(e) {
            if (e.button !== 0) return;
            startDrag(e.clientX, e.clientY);
        }

        function handleDragging(e) {
            if (!state.chart.isDragging) return;
            performDrag(e.clientX, e.clientY);
        }

        function handleDragEnd() {
            // Prevent mouse interaction from triggering tap logic on desktop
             if (!state.isMobile && state.chart.isDragging) {
                endDrag();
            }
        }

        // FIX: Updated Touch handlers for better pinning/unpinning logic (Feature 3)
        function handleTouchStart(e) {
            if (e.touches.length === 1 && e.target.closest('#chartWrap')) {
                e.preventDefault();
                // Don't unpin immediately. Wait to see if it's a drag or tap.
                startDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 1 && state.chart.isDragging) {
                e.preventDefault();

                // NEW: If it moves significantly, it's a drag. Unpin now for responsiveness.
                const dx = e.touches[0].clientX - state.chart.dragStartX;
                const dy = e.touches[0].clientY - state.chart.dragStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 10 && state.chart.isCrosshairPinned) {
                    state.chart.isCrosshairPinned = false;
                }

                performDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        }

        function handleTouchEnd(e) {
            if (!state.chart.isDragging) return;

            const touchDuration = Date.now() - state.chart.dragStartTimeStamp;
            const dx = state.chart.dragCurrentX - state.chart.dragStartX;
            const dy = state.chart.dragCurrentY - state.chart.dragStartY;
            const touchDistance = Math.sqrt(dx * dx + dy * dy);

            // Define thresholds for a "tap"
            const isTap = touchDuration < 300 && touchDistance < 10;

            if (isTap) {
                if (state.chart.isCrosshairPinned) {
                    // Case 1: Was pinned, user tapped -> Unpin
                    state.chart.isCrosshairPinned = false;
                } else {
                    // Case 2: Was unpinned, user tapped -> Pin
                    const rect = DOM.chartWrap.getBoundingClientRect();
                    // Use the final touch position (dragCurrentX/Y) relative to the chart wrap for pinning
                    state.chart.pinnedCrosshairPos.x = state.chart.dragCurrentX - rect.left;
                    state.chart.pinnedCrosshairPos.y = state.chart.dragCurrentY - rect.top;
                    state.chart.isCrosshairPinned = true;
                }
            }
            // If it was a drag (not a tap), the unpinning (if needed) happened in handleTouchMove.
            
            endDrag();
        }

        // Updated to handle Y coordinates
        function startDrag(clientX, clientY = 0) {
            state.chart.isDragging = true;
            state.chart.dragStartX = clientX;
            state.chart.dragStartY = clientY; // NEW
            state.chart.dragStartScroll = state.chart.scrollOffset;
            DOM.chartWrap.style.cursor = 'grabbing';
            
            // Store initial touch position and time for tap detection
            state.chart.dragCurrentX = clientX;
            state.chart.dragCurrentY = clientY;
            state.chart.dragStartTimeStamp = Date.now();
        }

        // Updated to handle Y coordinates
        function performDrag(clientX, clientY = 0) {
            const dx = clientX - state.chart.dragStartX;
            const candleUnitWidth = state.chart.candleWidth + state.chart.candleSpacing;
            
            if (candleUnitWidth <= 0) return;

            const candlesDragged = Math.round(dx / candleUnitWidth);
            
            // TradingView style scrolling (Natural)
            state.chart.scrollOffset = state.chart.dragStartScroll + candlesDragged;

            // Update current touch position
            state.chart.dragCurrentX = clientX;
            state.chart.dragCurrentY = clientY;

            validateScrollOffset();

            requestAnimationFrame(draw);
        }

        function endDrag() {
            state.chart.isDragging = false;
            DOM.chartWrap.style.cursor = 'crosshair';
             if (!state.isPlaying) {
                requestAnimationFrame(draw);
            }
        }

        function validateScrollOffset() {
            if (state.gameData.length === 0) {
                state.chart.scrollOffset = 0;
                return;
            }

            const visibleCandles = calculateVisibleCandles();
            const maxOffset = Math.max(0, state.currentIndex + 1 - visibleCandles);
            
            state.chart.scrollOffset = Math.max(0, Math.min(maxOffset, state.chart.scrollOffset));
        }


        // ----------------------------------------------------------------------------
        // 7. 遊戲化功能 (Gamification Features)
        // ----------------------------------------------------------------------------

         function checkForEvents() {
            if (state.isEnded || state.gameData.length === 0) return;

            // Calculate day relative to the start of the simulation for event triggering
            const currentDate = new Date(state.gameData[state.currentIndex].time);
            const startTime = state.gameData[0].time;
            const elapsedMs = currentDate.getTime() - startTime;
            const elapsedDays = Math.floor(elapsedMs / (1000 * 60 * 60 * 24)) + 1;


            const event = state.financialEvents.find(e => e.triggerDay === elapsedDays);

            // Use elapsedDays as the key to ensure events trigger once per simulation run
            const eventKey = `Day${elapsedDays}`;
            
            if (event && !state.triggeredEvents.has(eventKey)) {
                showEventModal(event);
                state.triggeredEvents.add(eventKey);
            }
        }

         function showEventModal(event) {
            if (state.isPlaying) {
                state.wasPlayingBeforeEvent = true;
                state.isPlaying = false;
                cancelAnimationFrame(animationFrameId);
                updateControls();
            } else {
                state.wasPlayingBeforeEvent = false;
            }

            document.getElementById('eventTitle').textContent = `⚠️ ${event.title}`;
            document.getElementById('eventBody').textContent = event.description;
            DOM.eventModal.classList.add('active');
        }

         function continueFromEvent() {
            DOM.eventModal.classList.remove('active');
            if (state.wasPlayingBeforeEvent) {
                togglePlayPause();
            }
        }

        
        function showEndGameModal() {
            const finalRoR = ((state.equity - CONFIG.INITIAL_BALANCE) / CONFIG.INITIAL_BALANCE) * 100;
            
            document.getElementById('finalScore').textContent = `$${state.equity.toFixed(2)}`;
            document.getElementById('finalRoR').textContent = `回報率 (RoR): ${finalRoR.toFixed(2)}%`;
            document.getElementById('finalRoR').style.color = finalRoR >= 0 ? 'var(--color-success)' : 'var(--color-danger)';

            // Display final time
            const minutes = Math.floor(state.elapsedTime / 60);
            const seconds = state.elapsedTime % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalTime').textContent = `總花費時間: ${timeString}`;

            // Stats Calculation
            const totalTrades = state.tradeHistory.length;
            const winningTrades = state.tradeHistory.filter(t => t.profit > 0).length;
            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const totalProfit = state.tradeHistory.reduce((sum, t) => sum + t.profit, 0);

            const statsHTML = `
                <p><strong>交易統計：</strong></p>
                <ul style="list-style-position: inside; padding-left: 10px;">
                    <li>總交易次數: ${totalTrades}</li>
                    <li>勝率: ${winRate.toFixed(2)}%</li>
                    <li>總損益: $${totalProfit.toFixed(2)}</li>
                    <li>模擬期間: 約 ${CONFIG.SIMULATION_DURATION_DAYS} 天</li>
                </ul>
            `;
            document.getElementById('endGameStats').innerHTML = statsHTML;

            // Display Achievements
            displayAchievements();

            DOM.endGameModal.classList.add('active');
        }

        // 7.3 新手導引 (Tutorial)
        // UPDATED V6 Tutorial Steps
        const TUTORIAL_STEPS = [
            { selector: '#challengeInfo', message: '歡迎！本次挑戰目標：在隨機的30天歷史行情中取得最高收益。', action: 'next' },
            { selector: '.chart-container', message: '這裡是 K 線圖表。向右拖曳查看歷史數據。在手機上，點擊圖表可以鎖定十字準心查看價格，再次點擊或拖曳可解除鎖定。', action: 'next' },
            { selector: '.controls', message: '使用這些按鈕控制模擬速度，或點擊「結束挑戰」隨時結算成績。', action: 'next' },
            { selector: '.order-grid', message: '設定停損(SL)、手數和停利(TP)。使用 +/- 按鈕可快速調整（步進值已優化為整數增減）。注意下方的預估損益。', action: 'next' },
            { selector: '.trade-actions-grid', message: '點擊「賣出」或「買入」進行交易。點擊「全部平倉」可快速關閉所有訂單。', action: 'next' },
            { selector: '[data-target="tabPositions"]', message: '點擊「持倉」分頁來查看和管理您當前的訂單。', action: 'next' },
            { selector: '.header', message: '頂部 HUD 顯示您的帳戶狀態、挑戰進度以及花費的現實時間。祝您交易順利！', action: 'next' },
        ];

        let currentTutorialStep = 0;

        function startTutorial() {
            state.tutorialActive = true;
            currentTutorialStep = 0;
            // Temporarily show the hidden challenge info for the tutorial
            document.getElementById('challengeInfo').style.display = 'block'; 
            showTutorialStep();
        }

        function showTutorialStep() {
            if (currentTutorialStep >= TUTORIAL_STEPS.length) {
                endTutorial();
                return;
            }

            const step = TUTORIAL_STEPS[currentTutorialStep];
            const element = document.querySelector(step.selector);

            if (!element) {
                // If element isn't ready yet, wait a bit and try again
                setTimeout(showTutorialStep, 100);
                return;
            }

            highlightElement(element);
            DOM.tutorialText.textContent = step.message;

            // Ensure "Next" button is visible and bound
            // Check added because highlightElement might hide the message if the element is hidden (V6.2)
            if (!DOM.tutorialMessage.classList.contains('hidden')) {
                DOM.tutorialNextBtn.classList.remove('hidden');
                DOM.tutorialNextBtn.onclick = completeTutorialStep;
            }
        }

        function completeTutorialStep() {
            if (!state.tutorialActive) return;
            currentTutorialStep++;
            showTutorialStep();
        }

        function endTutorial() {
            state.tutorialActive = false;
            state.tutorialCompletedOnce = true;
            DOM.tutorialHighlight.classList.add('hidden');
            DOM.tutorialMessage.classList.add('hidden');
            // Hide the challenge info again after tutorial ends
            document.getElementById('challengeInfo').style.display = 'none';
        }

        // FIX: Updated function to handle hidden elements gracefully (V6.2)
        function highlightElement(element) {
            const rect = element.getBoundingClientRect();
            const padding = 10;

            // FIX: Check if the element is hidden (e.g., in an inactive tab) (V6.2)
            // If the element has 0 width/height (or is otherwise not displayed), it's effectively hidden.
            if (rect.width === 0 && rect.height === 0) {
                // If the target element is hidden, we must hide the highlight and message,
                // otherwise the overlay (box-shadow) will block interaction with the visible UI.
                DOM.tutorialHighlight.classList.add('hidden');
                DOM.tutorialMessage.classList.add('hidden');
                return; // Exit early
            }

            // If visible, proceed as normal
            DOM.tutorialHighlight.classList.remove('hidden');
            DOM.tutorialHighlight.style.top = `${rect.top + window.scrollY - padding}px`;
            DOM.tutorialHighlight.style.left = `${rect.left + window.scrollX - padding}px`;
            DOM.tutorialHighlight.style.width = `${rect.width + padding * 2}px`;
            DOM.tutorialHighlight.style.height = `${rect.height + padding * 2}px`;

            DOM.tutorialMessage.classList.remove('hidden');
            
            let messageTop = rect.bottom + window.scrollY + padding + 15;
            let messageLeft = rect.left + window.scrollX;

            // Force re-calculation of message size based on current text
            DOM.tutorialMessage.style.width = 'auto';
            const messageRect = DOM.tutorialMessage.getBoundingClientRect();
            const maxWidth = 300;


            // Boundary checks
            if (messageTop + messageRect.height > window.innerHeight + window.scrollY) {
                messageTop = Math.max(10 + window.scrollY, rect.top + window.scrollY - messageRect.height - padding - 15);
            }
            
            if (messageLeft + Math.min(maxWidth, messageRect.width) > window.innerWidth + window.scrollX) {
                messageLeft = window.innerWidth + window.scrollX - Math.min(maxWidth, messageRect.width) - 20;
            }
            
            messageLeft = Math.max(10 + window.scrollX, messageLeft);

            DOM.tutorialMessage.style.top = `${messageTop}px`;
            DOM.tutorialMessage.style.left = `${messageLeft}px`;
        }


        // ----------------------------------------------------------------------------
        // 8. 成就係統 (Achievement System)
        // ----------------------------------------------------------------------------

        function unlockAchievement(key) {
            if (!state.unlockedAchievements.has(key)) {
                state.unlockedAchievements.add(key);
                const achievement = ACHIEVEMENTS[key];
                if (achievement) {
                    showNotification(`🏆 成就解鎖: ${achievement.title}`, achievement.description);
                }
            }
        }

        // NEW: Handles daily statistics updates for achievements (Feature 6)
        function updateDailyStats() {
            if (state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return;

            const currentTime = state.gameData[state.currentIndex].time;
            const currentDay = new Date(currentTime).toDateString();

            const currentTotalPL = state.equity - CONFIG.INITIAL_BALANCE;

            if (state.achievementStats.currentDay !== currentDay) {
                // Day changed, reset daily stats
                state.achievementStats.currentDay = currentDay;
                state.achievementStats.dailyLossCount = 0;
                // Initialize daily max P/L with the P/L at the start of the day
                state.achievementStats.dailyMaxPL = currentTotalPL;
            }

            // Update daily max P/L
            if (currentTotalPL > state.achievementStats.dailyMaxPL) {
                state.achievementStats.dailyMaxPL = currentTotalPL;
            }
        }

        function updateAchievementStats(closedTrade) {
            // Update consecutive wins/losses
            if (closedTrade.profit > 0) {
                state.achievementStats.consecutiveWins++;
                state.achievementStats.consecutiveLosses = 0;
            } else if (closedTrade.profit < 0) {
                state.achievementStats.consecutiveLosses++;
                state.achievementStats.consecutiveWins = 0;

                // NEW: Update daily loss count (BAD_DAY)
                // Ensure the trade closed on the current simulation day before counting
                const closeDay = new Date(closedTrade.closeTime).toDateString();
                if (closeDay === state.achievementStats.currentDay) {
                   state.achievementStats.dailyLossCount++;
                }
            }
        }

        function checkTradeAchievements(trade) {
            // 1. First Trade
            if (state.tradeHistory.length >= 1) {
                unlockAchievement('FIRST_TRADE');
            }
            // 8. Total Trades
            if (state.tradeHistory.length >= 10) {
                unlockAchievement('TRADER_10');
            }
            // 2. Big Win / 3. Big Loss
            if (trade.profit > 3000) {
                unlockAchievement('BIG_WIN');
            }
            if (trade.profit < -3000) {
                unlockAchievement('BIG_LOSS');
            }
            // 4. Win Streak / 5. Loss Streak
            if (state.achievementStats.consecutiveWins >= 3) {
                unlockAchievement('WIN_STREAK_3');
            }
            if (state.achievementStats.consecutiveLosses >= 3) {
                unlockAchievement('LOSS_STREAK_3');
            }
            // 9. 快槍俠 (QUICK_DRAW) - 1 hour condition
            const durationMs = trade.closeTime - trade.entryTime;
            const durationHours = durationMs / (1000 * 60 * 60);
            if (trade.profit > 0 && durationHours <= 1) {
                unlockAchievement('QUICK_DRAW');
            }
            // 15. 今天盤不好 (BAD_DAY)
            if (state.achievementStats.dailyLossCount >= 3) {
                unlockAchievement('BAD_DAY');
            }
        }

        function checkEquityAchievements() {
            // 10. Double Up
            if (state.equity >= 20000) {
                unlockAchievement('DOUBLE_UP');
            }
            // 11. 破產邊緣 (MARGIN_CALL) - $2000 threshold
            if (state.achievementStats.minEquity < 2000) {
                unlockAchievement('MARGIN_CALL');
            }
        }

        // NEW: Check for RUG_PULL achievement (Drawdown) (Feature 6)
        function checkDrawdownAchievement() {
            // 16. 盤中抽筋 (RUG_PULL)
            const currentTotalPL = state.equity - CONFIG.INITIAL_BALANCE;
            
            // Check if we went from profit to loss AND the drawdown from the daily peak P/L exceeds $2000
            // We check if dailyMaxPL > 0 to ensure there was profit during the day.
            if (state.achievementStats.dailyMaxPL > 0 && state.achievementStats.dailyMaxPL - currentTotalPL > 2000) {
                 // Further check if the current state is a loss, as required by the description
                 if (currentTotalPL < 0) {
                     unlockAchievement('RUG_PULL');
                 }
            }
        }

        function checkDurationAchievements() {
            // Ensure gameData access is safe
            if (!state.gameData || state.gameData.length === 0 || state.currentIndex >= state.gameData.length) return;

            // Use simulation time
            const currentTime = state.gameData[state.currentIndex].time;
            const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;

            state.openPositions.forEach(pos => {
                const duration = currentTime - pos.entryTime;
                if (duration > SEVEN_DAYS_MS) {
                    // 7. 佛系操盤
                    if (pos.profit > 0) {
                        unlockAchievement('HOLD_WIN_7D');
                    // 6. 凹單大師
                    } else if (pos.profit < 0) {
                        unlockAchievement('HOLD_LOSS_7D');
                    }
                }
            });
        }

        function checkFinalAchievements() {
            // 12. 穩健獲利 (CONSISTENT)
            const totalTrades = state.tradeHistory.length;
            if (totalTrades >= 10) {
                const winningTrades = state.tradeHistory.filter(t => t.profit > 0).length;
                const winRate = (winningTrades / totalTrades) * 100;
                if (winRate > 60) {
                    unlockAchievement('CONSISTENT');
                }
            }
        }

        function displayAchievements() {
            const listElement = document.getElementById('achievementsList');
            const sectionElement = document.getElementById('achievementsSection');
            listElement.innerHTML = '';

            if (state.unlockedAchievements.size === 0) {
                sectionElement.style.display = 'none';
                return;
            }

            sectionElement.style.display = 'block';

            // Display achievements in the order they were unlocked (Set preserves insertion order)
            state.unlockedAchievements.forEach(key => {
                const achievement = ACHIEVEMENTS[key];
                if (achievement) {
                    const item = document.createElement('li');
                    item.className = 'achievement-item';
                    item.innerHTML = `
                        <span class="achievement-icon">${achievement.icon}</span>
                        <div>
                            <strong>${achievement.title}</strong>
                            <p style="font-size: 12px; color: var(--color-text-secondary);">${achievement.description}</p>
                        </div>
                    `;
                    listElement.appendChild(item);
                }
            });
        }

        // Notification (Toast) System
        function showNotification(title, message) {
            // Ensure DOM container exists
            if (!DOM.notificationContainer) return;

            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.innerHTML = `<strong>${title}</strong><p>${message}</p>`;
            
            // Prepend so the newest notification is on top
            DOM.notificationContainer.insertBefore(toast, DOM.notificationContainer.firstChild);

            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (DOM.notificationContainer.contains(toast)) {
                        DOM.notificationContainer.removeChild(toast);
                    }
                }, 500); // Wait for fade out transition
            }, 5000);
        }


        // ----------------------------------------------------------------------------
        // 9. 輔助函式 (Utility Functions)
        // ----------------------------------------------------------------------------

         // 設置輸入框的步進按鈕邏輯 (包含初始化)
         // FIX: Updated logic for initialization and stepping (Feature 5)
        function setupInputStepper(buttonId, inputId, step) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            button.addEventListener('click', () => {
                const input = document.getElementById(inputId);
                let currentValue = parseFloat(input.value);
                let newValue;

                // 精度處理
                const stepStr = Math.abs(step).toString();
                const decimalPlaces = (stepStr.split('.')[1] || []).length;
                
                // 確保價格顯示兩位小數
                const displayDecimalPlaces = (inputId === 'inputLots') ? decimalPlaces : 2;

                // 初始化邏輯
                if (isNaN(currentValue) || (currentValue <= 0 && inputId !== 'inputLots')) {
                    if (inputId === 'inputSL' || inputId === 'inputTP') {
                        const currentPrice = getCurrentPrice();
                        if (currentPrice > 0) {
                            // FIX: 從當前市價開始，並對齊到最近的 step 倍數，確保方向正確
                            if (step > 0) {
                                // If pressing UP, initialize to the next multiple of 'step' above current price
                                newValue = Math.ceil(currentPrice / Math.abs(step)) * Math.abs(step);
                                if (newValue <= currentPrice) {
                                    newValue += Math.abs(step);
                                }
                            } else {
                                // If pressing DOWN, initialize to the next multiple of 'step' below current price
                                newValue = Math.floor(currentPrice / Math.abs(step)) * Math.abs(step);
                                if (newValue >= currentPrice) {
                                     newValue -= Math.abs(step);
                                }
                            }
                        } else {
                            return; // 市價不可用則不操作
                        }
                    } else if (inputId === 'inputLots') {
                        // Ensure initialization respects the step (e.g., if step is 0.1, initialize to 0.1)
                        // If pressing down from empty, initialize to minimum lot size
                        if (step > 0) {
                             newValue = Math.abs(step);
                        } else {
                            newValue = 0.01;
                        }
                    }
                } else {
                     newValue = currentValue + step;
                }
                
                // 浮點數校正
                const precisionFactor = Math.pow(10, Math.max(decimalPlaces, displayDecimalPlaces));
                // Safety check if newValue somehow became undefined
                if (newValue === undefined) return; 
                newValue = Math.round(newValue * precisionFactor) / precisionFactor;


                // 邊界檢查
                if (inputId === 'inputLots') {
                     if (newValue < 0.01) newValue = 0.01;
                } else {
                    // SL/TP 必須大於 0
                    if (newValue <= 0) {
                        input.value = '';
                        updateEstimatedPL(); // 更新預估損益
                        return;
                    }
                }
               
                input.value = newValue.toFixed(displayDecimalPlaces);
                updateEstimatedPL(); // 更新預估損益
            });
        }

         function formatDuration(ms) {
            if (ms < 0) ms = 0;
            const minutes = Math.floor(ms / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}天 ${hours % 24}小時`;
            if (hours > 0) return `${hours}小時 ${minutes % 60}分鐘`;
            // Added seconds display for very short durations
            if (minutes === 0) return `${Math.floor(ms / 1000)}秒`;
            return `${minutes}分鐘`;
        }

        // ----------------------------------------------------------------------------
        // 啟動應用程式 (Bootstrap Application)
        // ----------------------------------------------------------------------------
        
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
