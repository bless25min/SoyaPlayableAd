<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>交易獲利挑戰賽</title>
<style>
:root {
  --bg: #f4f7fc;
  --panel: #ffffff;
  --panel-soft: #f9fafc;
  --text: #1a1e2b;
  --muted: #6b7280;
  --border-color: #e5e7eb;
  --accent: #4a72ff;
  --good: #10b981; /* Green for profit */
  --danger: #ef4444; /* Red for loss */
  --grid: rgba(0, 0, 0, 0.05);
  /* Chart Colors: Green for Up, Red for Down */
  --chart-bg: #ffffff;
  --chart-text: #6b7280;
  --chart-up: #10b981;   /* 陽棒顏色 */
  --chart-down: #ef4444; /* 陰棒顏色 */
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0; padding: 0; height: 100%; width: 100%;
  overflow: hidden; background-color: var(--bg); color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex; flex-direction: column; height: 100%; width: 100%;
  max-width: 420px; margin: 0 auto; background-color: var(--panel);
  box-shadow: 0 0 20px rgba(0,0,0,0.05);
}

/* --- 頂部資訊 --- */
.header {
  padding: 8px 16px; border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; text-align: center;
}
.header .stats { display: flex; justify-content: space-around; font-size: 14px; }
.header .stats div { display: flex; flex-direction: column; }
.header .stats .label { font-size: 12px; color: var(--muted); }
.header .stats .value { font-weight: bold; }
.header .pnl-up { color: var(--good); }
.header .pnl-down { color: var(--danger); }
.progress-bar { width: 100%; height: 4px; background: var(--border-color); border-radius: 2px; margin-top: 8px; overflow: hidden; }
.progress-bar-inner { width: 0%; height: 100%; background: var(--accent); transition: width 0.2s linear; }

/* --- 圖表區 --- */
#chartWrap {
  flex-grow: 1; position: relative; background: var(--chart-bg);
  min-height: 0; cursor: grab;
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }

.price-axis {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 60px;
    pointer-events: none;
    border-left: 1px solid var(--border-color);
}
.price-axis-tick {
    position: absolute;
    width: 100%;
    padding-right: 5px;
    font-size: 12px;
    color: var(--chart-text);
    transform: translateY(-50%);
    text-align: right;
}
.price-line {
    position: absolute;
    left: 0;
    right: 60px;
    height: 1px;
    pointer-events: none;
    border-top: 1px dashed var(--muted);
}
.price-line-label {
    position: absolute;
    right: 60px;
    padding: 2px 6px;
    font-size: 12px;
    color: #ffffff;
    border-radius: 4px;
    transform: translate(100%, -50%);
}

/* --- 底部操作區 --- */
.actions-panel {
  flex-shrink: 0; background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.tabs { display: flex; border-bottom: 1px solid var(--border-color); }
.tab-btn {
  flex: 1; padding: 12px; background: none; border: none;
  color: var(--muted); cursor: pointer; border-bottom: 2px solid transparent;
  font-size: 14px;
}
.tab-btn.active { color: var(--text); border-bottom-color: var(--accent); font-weight: bold; }

.tab-content { display: none; padding: 12px; }
.tab-content.active { display: block; }

#trade-panel-content {
    display: grid;
    grid-template-areas:
        "sl lots tp"
        "sell close buy";
    gap: 8px;
    align-items: center;
}
#trade-sl-group { grid-area: sl; }
#trade-lots-group { grid-area: lots; }
#trade-tp-group { grid-area: tp; }
#btnSell { grid-area: sell; }
#btnCloseAll { grid-area: close; background-color: var(--muted); color: white; }
#btnBuy { grid-area: buy; }

.btn { padding: 12px; font-size: 16px; font-weight: bold; border-radius: 8px; border: none; cursor: pointer; transition: transform 0.1s ease, filter 0.1s ease; }
.btn.buy { background: var(--chart-up); color: white; }
.btn.sell { background: var(--chart-down); color: white; }
.btn:active { 
    transform: scale(0.96); 
    filter: brightness(0.9);
}

.playback-controls {
    display: flex; justify-content: center; align-items: center;
    gap: 8px; padding: 8px 0;
}
.playback-controls .btn {
    background: var(--panel-soft); color: var(--text);
    border: 1px solid var(--border-color);
    padding: 8px 10px; font-size: 12px;
}
.playback-controls .btn.active { background: var(--accent); color: white; border-color: var(--accent); }

.input-group { display: flex; flex-direction: column; text-align: center;}
.input-group label { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
.input-group input { text-align: center; width: 100%; background: var(--bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; color: var(--text); font-size: 14px; }

/* Input Stepper Styles */
.input-stepper {
    display: flex;
    align-items: center;
    background: var(--bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
}
.input-stepper input {
    border: none;
    background: transparent;
    flex-grow: 1;
    padding: 8px;
    width: 50px; /* Give it a base width */
}
.stepper-btns {
    display: flex;
    flex-direction: column;
    align-self: stretch;
}
.stepper-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 0 8px;
    color: var(--muted);
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    border-left: 1px solid var(--border-color);
    transition: background-color 0.1s ease;
}
.stepper-btn:first-child {
    border-bottom: 1px solid var(--border-color);
}
.stepper-btn:active {
    background: #e0e2e7;
}


/* Hides the default arrows for number input */
input[type=number]::-webkit-inner-spin-button, 
input[type=number]::-webkit-outer-spin-button { 
  -webkit-appearance: none; 
  margin: 0; 
}
input[type=number] {
  -moz-appearance: textfield;
}


#positions-list, #journal-list { max-height: 25vh; overflow-y: auto; }
.position-item { 
    background: var(--panel-soft); 
    padding: 10px; 
    border-radius: 8px; 
    margin-bottom: 8px; 
    display: grid; 
    grid-template-columns: 1fr 1fr;
    grid-template-areas: 
        "info pnl"
        "sl tp"
        "actions actions";
    gap: 8px; 
    align-items: center;
}
.position-item-info { grid-area: info; }
.position-item-pnl { grid-area: pnl; text-align: right; font-weight: bold; }
.position-item-sl { grid-area: sl; }
.position-item-tp { grid-area: tp; }
.position-item-actions { grid-area: actions; display: flex; gap: 8px; }

.position-item .side-buy { color: var(--good); font-weight: bold; }
.position-item .side-sell { color: var(--danger); font-weight: bold; }
.position-item .pnl-up { color: var(--good); }
.position-item .pnl-down { color: var(--danger); }
.position-item .close-btn, .position-item .modify-btn { flex: 1; padding: 6px; font-size: 12px; }
.position-item .close-btn { background: var(--danger); color: white; }
.position-item .modify-btn { background: var(--accent); color: white; }
.position-item .input-group { margin-bottom: 0; }
.position-item .input-group input { padding: 6px; font-size: 12px; }

.journal-item {
    background: var(--panel-soft); 
    padding: 10px; 
    border-radius: 8px; 
    margin-bottom: 8px; 
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 4px 16px;
    font-size: 12px;
}
.journal-item-info { grid-column: 1 / 2; }
.journal-item-pnl { grid-column: 2 / 3; grid-row: 1 / 3; text-align: right; font-weight: bold; font-size: 14px; align-self: center; }
.journal-item-time { grid-column: 1 / 2; color: var(--muted); }
.journal-item .pnl-up { color: var(--good); }
.journal-item .pnl-down { color: var(--danger); }


/* --- 彈窗 & 新手導引 --- */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.5);
  backdrop-filter: blur(4px); z-index: 9997;
  display: flex; justify-content: center; align-items: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: min(90vw, 380px); background: var(--panel);
  border: 1px solid var(--border-color); border-radius: 16px;
  padding: 24px; text-align: center;
  transform: scale(0.9); transition: transform 0.3s ease;
  box-shadow: 0 10px 30px rgba(0,0,0,0.1);
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-header { font-weight: bold; margin-bottom: 16px; font-size: 20px; }
.event-modal-icon { font-size: 48px; margin-bottom: 12px; }
.event-modal-desc { color: var(--muted); margin-bottom: 20px; text-align: left; line-height: 1.6; }

#tutorial-overlay {
    z-index: 10000;
    background: none;
    backdrop-filter: none;
    pointer-events: all;
}
#tutorial-highlight {
    position: absolute;
    border-radius: 8px;
    box-shadow: 0 0 0 9999px rgba(0,0,0,0.7);
    transition: all 0.3s ease-in-out;
    pointer-events: none;
}
#tutorial-box {
    position: absolute;
    background: var(--panel);
    padding: 16px;
    border-radius: 12px;
    width: 280px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    transition: all 0.3s ease-in-out;
}
#tutorial-text {
    margin-bottom: 16px;
    line-height: 1.6;
}
#tutorial-nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#tutorial-dots {
    display: flex;
    gap: 6px;
}
.tutorial-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--border-color);
}
.tutorial-dot.active {
    background: var(--accent);
}

.glowing-btn {
    animation: glowing 1.5s infinite;
}

@keyframes glowing {
    0% { box-shadow: 0 0 5px var(--accent); }
    50% { box-shadow: 0 0 20px var(--accent); }
    100% { box-shadow: 0 0 5px var(--accent); }
}

/* End Game Modal Styles */
.end-game-stats {
    display: flex;
    justify-content: space-around;
    margin: 24px 0;
    text-align: center;
}
.end-game-stats .label {
    font-size: 14px;
    color: var(--muted);
}
.end-game-stats .value {
    font-size: 24px;
    font-weight: bold;
    display: block;
    margin-top: 4px;
}
#endGameModal .btn {
    width: 100%;
    margin-top: 8px;
}
#endGameModal .cta-btn {
    background-color: var(--accent);
    color: white;
    text-decoration: none;
    display: inline-block;
    line-height: 1.5;
}

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <div class="stats">
        <div><span class="label">模擬日期</span><span class="value" id="current-date">--</span></div>
        <div><span class="label">帳戶淨值</span><span class="value" id="equity">$10000.00</span></div>
        <div><span class="label">總損益</span><span class="value" id="total-pnl">$0.00</span></div>
    </div>
    <div class="progress-bar"><div id="progress-bar-inner" class="progress-bar-inner"></div></div>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div id="price-lines-container"></div>
    <div class="price-axis" id="price-axis"></div>
  </div>
  <div class="actions-panel">
    <div class="tabs">
        <button class="tab-btn active" data-tab="trade-panel">交易</button>
        <button class="tab-btn" data-tab="positions-panel">持倉</button>
        <button class="tab-btn" data-tab="journal-panel">紀錄</button>
    </div>
    <div id="trade-panel" class="tab-content active">
        <div id="trade-panel-content">
            <div id="trade-sl-group" class="input-group">
                <label for="trade-sl">停損 SL</label>
                <div class="input-stepper">
                    <input id="trade-sl" type="number" placeholder="價格" data-step="0.5">
                    <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-sl" data-direction="up">▲</button>
                        <button class="stepper-btn" data-target="trade-sl" data-direction="down">▼</button>
                    </div>
                </div>
            </div>
            <div id="trade-lots-group" class="input-group">
                <label for="trade-lots">手數</label>
                <div class="input-stepper">
                    <input id="trade-lots" type="number" value="0.1" step="0.01" min="0.01">
                    <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-lots" data-direction="up">▲</button>
                        <button class="stepper-btn" data-target="trade-lots" data-direction="down">▼</button>
                    </div>
                </div>
            </div>
            <div id="trade-tp-group" class="input-group">
                <label for="trade-tp">停利 TP</label>
                <div class="input-stepper">
                     <input id="trade-tp" type="number" placeholder="價格" data-step="0.5">
                     <div class="stepper-btns">
                        <button class="stepper-btn" data-target="trade-tp" data-direction="up">▲</button>
                        <button class="stepper-btn" data-target="trade-tp" data-direction="down">▼</button>
                    </div>
                </div>
            </div>
            <button class="btn sell" id="btnSell">Sell</button>
            <button class="btn" id="btnCloseAll">平倉</button>
            <button class="btn buy" id="btnBuy">Buy</button>
        </div>
    </div>
    <div id="positions-panel" class="tab-content">
        <div id="positions-list"></div>
    </div>
    <div id="journal-panel" class="tab-content">
        <div id="journal-list"></div>
    </div>
    <div class="playback-controls">
        <button class="btn" id="play-pause-btn">▶</button>
        <button class="btn" id="step-btn">逐K →</button>
        <div id="speed-controls">
            <button class="btn speed-btn active" data-speed="400">0.25x</button>
            <button class="btn speed-btn" data-speed="200">0.5x</button>
            <button class="btn speed-btn" data-speed="100">1x</button>
            <button class="btn speed-btn" data-speed="50">2x</button>
            <button class="btn speed-btn" data-speed="10">5x</button>
        </div>
        <button class="btn" id="zoom-out">-</button>
        <button class="btn" id="zoom-in">+</button>
    </div>
  </div>
</div>

<!-- 事件 Modal -->
<div id="eventModal" class="modal-overlay">
    <div class="modal-content event-modal-content">
      <div class="event-modal-icon">📰</div>
      <h2 class="modal-header" id="event-title"></h2>
      <p class="event-modal-desc" id="event-desc"></p>
      <button class="btn" id="event-continue-btn">繼續</button>
    </div>
</div>

<!-- 新手導引 Modal -->
<div id="tutorial-overlay" class="modal-overlay">
    <div id="tutorial-highlight"></div>
    <div id="tutorial-box">
        <p id="tutorial-text"></p>
        <div id="tutorial-nav">
            <button class="btn" id="tutorial-skip">略過</button>
            <div id="tutorial-dots"></div>
            <button class="btn" id="tutorial-next">下一步</button>
        </div>
    </div>
</div>

<!-- 挑戰結束 Modal -->
<div id="endGameModal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-header">挑戰結束！</h2>
      <div class="end-game-stats">
          <div>
              <span class="label">最終淨值</span>
              <span class="value" id="final-equity">$0.00</span>
          </div>
          <div>
              <span class="label">總損益</span>
              <span class="value" id="final-pnl">$0.00</span>
          </div>
      </div>
      <a href="https://www.fxvic.com.tw/" target="_blank" class="btn cta-btn" id="cta-btn">瞭解如何取得高分</a>
      <button class="btn" id="restart-btn">再次挑戰</button>
    </div>
</div>


<script>
// ===== 財經事件數據 (省略) =====
const EVENTS = {
  "2025-01-03": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "俗稱「非農」的美國就業數據是市場最關注的指標之一。數據好壞將劇烈影響黃金價格，市場屏息以待！" },
  "2025-01-20": { time: "12:00", title: "🇺🇸 美國總統就職典禮", desc: "新任美國總統將於華盛頓特區宣誓就職。就職演說通常會概述新政府的施政藍圖，內容可能涉及國內外政策、經濟方向等，這些都可能成為市場關注的焦點。" },
  "2025-01-30": { time: "20:45", title: "🇪🇺 歐洲央行 (ECB) 利率決策會議", desc: "歐洲央行管理委員會將召開貨幣政策會議並發布利率決策聲明。市場將關注其對歐元区經濟前景和通膨路徑的最新評估。" },
  "2025-02-07": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "本月非農數據公布，將再次考驗市場對美國經濟復甦力度的信心。" },
  "2025-03-05": { time: "10:00", title: "🇨🇳 中國全國人民代表大會年會開幕", desc: "中國將公布當年度的GDP增長目標、財政預算等主要經濟指標，並闡述相關政策方向。" },
  "2025-03-07": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "連續第三個月的非農數據，市場將尋找勞動力市場是否持續穩定的線索。" },
  "2025-03-19": { time: "03:00", title: "🇺🇸 聯準會利率決策 (FOMC)", desc: "聯準會將發布利率決策，會議將包含最新的經濟預測摘要 (SEP) 和「點陣圖」，揭示未來利率路徑預期。" },
  "2025-04-04": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "第二季度的首次非農報告，將為市場對上半年的經濟預測定下基調。" },
  "2025-04-10": { time: "20:45", title: "🇪🇺 歐洲央行 (ECB) 利率決策會議", desc: "在第一季經濟數據公布之後，市場將關注歐洲央行是否會根據最新數據調整其貨幣政策立場。" },
  "2025-04-21": { time: "09:00", title: "IMF 《世界經濟展望》報告", desc: "國際貨幣基金組織將更新對全球主要經濟體的增長預測，並分析全球面臨的潛在風險。" },
  "2025-05-02": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "春季的就業市場表現如何？本次非農數據將提供關鍵答案。" },
  "2025-05-09": { time: "15:00", title: "🇷🇺 俄羅斯勝利日閱兵", desc: "俄羅斯總統通常會發表演說，市場會關注其發言是否包含任何新的地緣政治信號。" },
  "2025-06-06": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "夏季前的最後一次重要就業報告，可能影響聯準會下半年的政策預期。" },
  "2025-06-13": { time: "14:00", title: "G7 領袖峰會開幕", desc: "七國集團峰會在加拿大舉行，會議議程涵蓋全球經濟、氣候變遷、地緣政治等多項議題。" },
  "2025-07-01": { time: "10:00", title: "🇨🇳 中國共產黨成立週年紀念日", desc: "相關活動和聲明可能會傳達關於中國未來發展方向的信號。" },
  "2025-07-03": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "因7月4日為美國獨立日假期，本月非農數據提前至週四公布。" },
  "2025-07-30": { time: "21:30", title: "🇺🇸 美國第二季GDP初值", desc: "該數據是衡量美國經濟健康狀況的重要指標，將提供對第二季度經濟活動的初步評估。" },
  "2025-08-01": { time: "21:30", title: "🇺🇸 美國非農就業數據 (NFP)", desc: "八月的非農報告，將為夏末的市場情緒定調。" },
  "2025-08-15": { time: "12:00", title: "🇮🇳 印度獨立紀念日", desc: "印度總理將發表演說，闡述未來政府的施政重點，尤其是在經濟發展和外交政策方面。" }
};

// ===== 遊戲設定 =====
const CONFIG = {
  gameDurationMonths: 1,
  minBarsInView: 20,
  maxBarsInView: 200,
  initialBalance: 10000,
  timeAxisHeight: 25, // px
};

// ===== 遊戲狀態與 DOM 元素 =====
let state = {};
const el = id => document.getElementById(id);
let canvas, ctx, chartWrap;
let CHART_COLORS = {};
let hasPlayedOnce = false;

// ===== 數據處理 =====
function loadData() {
  return new Promise((resolve) => {
    // ******** FINAL FIX: Embed data directly to prevent all loading issues ********
    const rawData = `DATE	TIME	OPEN	HIGH	LOW	CLOSE
2025.01.02	00:00:00	2333.93	2334.32	2332.41	2332.93
2025.01.02	00:15:00	2332.93	2333.48	2332.51	2333.18
2025.01.02	00:30:00	2333.18	2333.74	2332.53	2333.56
2025.01.02	00:45:00	2333.56	2334.21	2333.32	2333.82
2025.01.02	01:00:00	2333.82	2334.88	2333.64	2334.72
2025.01.02	01:15:00	2334.72	2335.21	2334.11	2334.34
2025.01.02	01:30:00	2334.34	2334.49	2333.42	2333.72
2025.01.02	01:45:00	2333.72	2334.12	2333.11	2333.91
2025.01.02	02:00:00	2333.91	2334.01	2332.84	2333.05
2025.01.02	02:15:00	2333.05	2333.15	2331.45	2331.75
2025.01.02	02:30:00	2331.75	2332.65	2331.55	2332.45
2025.01.02	02:45:00	2332.45	2333.55	2332.35	2333.35
2025.01.02	03:00:00	2333.35	2333.45	2332.25	2332.55
2025.01.02	03:15:00	2332.55	2332.65	2331.45	2331.65
2025.01.02	03:30:00	2331.65	2332.25	2331.55	2332.05
2025.01.02	03:45:00	2332.05	2332.15	2331.05	2331.25
2025.01.02	04:00:00	2331.25	2332.35	2331.15	2332.15
2025.01.02	04:15:00	2332.15	2332.25	2331.05	2331.35
2025.01.02	04:30:00	2331.35	2331.45	2330.25	2330.55
2025.01.02	04:45:00	2330.55	2330.65	2329.45	2329.65
2025.01.02	05:00:00	2329.65	2330.75	2329.55	2330.55
2025.01.02	05:15:00	2330.55	2330.65	2329.45	2329.75
2025.01.02	05:30:00	2329.75	2329.85	2328.65	2328.95
2025.01.02	05:45:00	2328.95	2329.05	2327.85	2328.15
2025.01.02	06:00:00	2328.15	2329.25	2328.05	2329.05
2025.01.02	06:15:00	2329.05	2329.15	2327.95	2328.25
2025.01.02	06:30:00	2328.25	2328.35	2327.15	2327.45
2025.01.02	06:45:00	2327.45	2327.55	2326.35	2326.65
2025.01.02	07:00:00	2326.65	2327.75	2326.55	2327.55
2025.01.02	07:15:00	2327.55	2327.65	2326.45	2326.75
2025.01.02	07:30:00	2326.75	2326.85	2325.65	2325.95
2025.01.02	07:45:00	2325.95	2326.05	2324.85	2325.15
2025.01.02	08:00:00	2325.15	2326.25	2325.05	2326.05
2025.01.02	08:15:00	2326.05	2326.15	2324.95	2325.25
2025.01.02	08:30:00	2325.25	2325.35	2324.15	2324.45
2025.01.02	08:45:00	2324.45	2324.55	2323.35	2323.65
2025.01.02	09:00:00	2323.65	2324.75	2323.55	2324.55
2025.01.02	09:15:00	2324.55	2324.65	2323.45	2323.75
2025.01.02	09:30:00	2323.75	2323.85	2322.65	2322.95
2025.01.02	09:45:00	2322.95	2323.05	2321.85	2322.15
2025.01.02	10:00:00	2322.15	2323.25	2322.05	2323.05
2025.01.02	10:15:00	2323.05	2323.15	2321.95	2322.25
2025.01.02	10:30:00	2322.25	2322.35	2321.15	2321.45
2025.01.02	10:45:00	2321.45	2321.55	2320.35	2320.65
2025.01.02	11:00:00	2320.65	2321.75	2320.55	2321.55
2025.01.02	11:15:00	2321.55	2321.65	2320.45	2320.75
2025.01.02	11:30:00	2320.75	2320.85	2319.65	2319.95
2025.01.02	11:45:00	2319.95	2320.05	2318.85	2319.15
2025.01.02	12:00:00	2319.15	2320.25	2319.05	2320.05
2025.01.02	12:15:00	2320.05	2320.15	2318.95	2319.25
2025.01.02	12:30:00	2319.25	2319.35	2318.15	2318.45
2025.01.02	12:45:00	2318.45	2318.55	2317.35	2317.65
2025.01.02	13:00:00	2317.65	2318.75	2317.55	2318.55
2025.01.02	13:15:00	2318.55	2318.65	2317.45	2317.75
2025.01.02	13:30:00	2317.75	2317.85	2316.65	2316.95
2025.01.02	13:45:00	2316.95	2317.05	2315.85	2316.15
2025.01.02	14:00:00	2316.15	2317.25	2316.05	2317.05
2025.01.02	14:15:00	2317.05	2317.15	2315.95	2316.25
2025.01.02	14:30:00	2316.25	2316.35	2315.15	2315.45
2025.01.02	14:45:00	2315.45	2315.55	2314.35	2314.65
2025.01.02	15:00:00	2314.65	2315.75	2314.55	2315.55
2025.01.02	15:15:00	2315.55	2315.65	2314.45	2314.75
2025.01.02	15:30:00	2314.75	2314.85	2313.65	2313.95
2025.01.02	15:45:00	2313.95	2314.05	2312.85	2313.15
2025.01.02	16:00:00	2313.15	2314.25	2313.05	2314.05
2025.01.02	16:15:00	2314.05	2314.15	2312.95	2313.25
2025.01.02	16:30:00	2313.25	2313.35	2312.15	2312.45
2025.01.02	16:45:00	2312.45	2312.55	2311.35	2311.65
2025.01.02	17:00:00	2311.65	2312.75	2311.55	2312.55
2025.01.02	17:15:00	2312.55	2312.65	2311.45	2311.75
2025.01.02	17:30:00	2311.75	2311.85	2310.65	2310.95
2025.01.02	17:45:00	2310.95	2311.05	2309.85	2310.15
2025.01.02	18:00:00	2310.15	2311.25	2310.05	2311.05
2025.01.02	18:15:00	2311.05	2311.15	2309.95	2310.25
2025.01.02	18:30:00	2310.25	2310.35	2309.15	2309.45
2025.01.02	18:45:00	2309.45	2309.55	2308.35	2308.65
2025.01.02	19:00:00	2308.65	2309.75	2308.55	2309.55
2025.01.02	19:15:00	2309.55	2309.65	2308.45	2308.75
2025.01.02	19:30:00	2308.75	2308.85	2307.65	2307.95
2025.01.02	19:45:00	2307.95	2308.05	2306.85	2307.15
2025.01.02	20:00:00	2307.15	2308.25	2307.05	2308.05
2025.01.02	20:15:00	2308.05	2308.15	2306.95	2307.25
2025.01.02	20:30:00	2307.25	2307.35	2306.15	2306.45
2025.01.02	20:45:00	2306.45	2306.55	2305.35	2305.65
2025.01.02	21:00:00	2305.65	2306.75	2305.55	2306.55
2025.01.02	21:15:00	2306.55	2306.65	2305.45	2305.75
2025.01.02	21:30:00	2305.75	2305.85	2304.65	2304.95
2025.01.02	21:45:00	2304.95	2305.05	2303.85	2304.15
2025.01.02	22:00:00	2304.15	2305.25	2304.05	2305.05
2025.01.02	22:15:00	2305.05	2305.15	2303.95	2304.25
2025.01.02	22:30:00	2304.25	2304.35	2303.15	2303.45
2025.01.02	22:45:00	2303.45	2303.55	2302.35	2302.65
2025.01.02	23:00:00	2302.65	2303.75	2302.55	2303.55
2025.01.02	23:15:00	2303.55	2303.65	2302.45	2302.75
2025.01.02	23:30:00	2302.75	2302.85	2301.65	2301.95
2025.01.02	23:45:00	2301.95	2302.05	2300.85	2301.15
2025.01.03	00:00:00	2301.15	2302.25	2301.05	2302.05
2025.01.03	00:15:00	2302.05	2302.15	2300.95	2301.25
2025.01.03	00:30:00	2301.25	2301.35	2300.15	2300.45
2025.01.03	00:45:00	2300.45	2300.55	2299.35	2299.65
2025.01.03	01:00:00	2299.65	2300.75	2299.55	2300.55
2025.01.03	01:15:00	2300.55	2300.65	2299.45	2299.75
2025.01.03	01:30:00	2299.75	2299.85	2298.65	2298.95
2025.01.03	01:45:00	2298.95	2299.05	2297.85	2298.15
2025.01.03	02:00:00	2298.15	2299.25	2298.05	2299.05
2025.01.03	02:15:00	2299.05	2299.15	2297.95	2298.25
2025.01.03	02:30:00	2298.25	2298.35	2297.15	2297.45
2025.01.03	02:45:00	2297.45	2297.55	2296.35	2296.65
2025.01.03	03:00:00	2296.65	2297.75	2296.55	2297.55
2025.01.03	03:15:00	2297.55	2297.65	2296.45	2296.75
2025.01.03	03:30:00	2296.75	2296.85	2295.65	2295.95
2025.01.03	03:45:00	2295.95	2296.05	2294.85	2295.15
2025.01.03	04:00:00	2295.15	2296.25	2295.05	2296.05
2025.01.03	04:15:00	2296.05	2296.15	2294.95	2295.25
2025.01.03	04:30:00	2295.25	2295.35	2294.15	2294.45
2025.01.03	04:45:00	2294.45	2294.55	2293.35	2293.65
2025.01.03	05:00:00	2293.65	2294.75	2293.55	2294.55
2025.01.03	05:15:00	2294.55	2294.65	2293.45	2293.75
2025.01.03	05:30:00	2293.75	2293.85	2292.65	2292.95
2025.01.03	05:45:00	2292.95	2293.05	2291.85	2292.15
2025.01.03	06:00:00	2292.15	2293.25	2292.05	2293.05
2025.01.03	06:15:00	2293.05	2293.15	2291.95	2292.25
2025.01.03	06:30:00	2292.25	2292.35	2291.15	2291.45
2025.01.03	06:45:00	2291.45	2291.55	2290.35	2290.65
2025.01.03	07:00:00	2290.65	2291.75	2290.55	2291.55
2025.01.03	07:15:00	2291.55	2291.65	2290.45	2290.75
2025.01.03	07:30:00	2290.75	2290.85	2289.65	2289.95
2025.01.03	07:45:00	2289.95	2290.05	2288.85	2289.15
2025.01.03	08:00:00	2289.15	2290.25	2289.05	2290.05
2025.01.03	08:15:00	2290.05	2290.15	2288.95	2289.25
2025.01.03	08:30:00	2289.25	2289.35	2288.15	2288.45
2025.01.03	08:45:00	2288.45	2288.55	2287.35	2287.65
2025.01.03	09:00:00	2287.65	2288.75	2287.55	2288.55
2025.01.03	09:15:00	2288.55	2288.65	2287.45	2287.75
2025.01.03	09:30:00	2287.75	2287.85	2286.65	2286.95
2025.01.03	09:45:00	2286.95	2287.05	2285.85	2286.15
2025.01.03	10:00:00	2286.15	2287.25	2286.05	2287.05
2025.01.03	10:15:00	2287.05	2287.15	2285.95	2286.25
2025.01.03	10:30:00	2286.25	2286.35	2285.15	2285.45
2025.01.03	10:45:00	2285.45	2285.55	2284.35	2284.65
2025.01.03	11:00:00	2284.65	2285.75	2284.55	2285.55
2025.01.03	11:15:00	2285.55	2285.65	2284.45	2284.75
2025.01.03	11:30:00	2284.75	2284.85	2283.65	2283.95
2025.01.03	11:45:00	2283.95	2284.05	2282.85	2283.15
2025.01.03	12:00:00	2283.15	2284.25	2283.05	2284.05
2025.01.03	12:15:00	2284.05	2284.15	2282.95	2283.25
2025.01.03	12:30:00	2283.25	2283.35	2282.15	2282.45
2025.01.03	12:45:00	2282.45	2282.55	2281.35	2281.65
2025.01.03	13:00:00	2281.65	2282.75	2281.55	2282.55
2025.01.03	13:15:00	2282.55	2282.65	2281.45	2281.75
2025.01.03	13:30:00	2281.75	2281.85	2280.65	2280.95
2025.01.03	13:45:00	2280.95	2281.05	2279.85	2280.15
2025.01.03	14:00:00	2280.15	2281.25	2280.05	2281.05
2025.01.03	14:15:00	2281.05	2281.15	2279.95	2280.25
2025.01.03	14:30:00	2280.25	2280.35	2279.15	2279.45
2025.01.03	14:45:00	2279.45	2279.55	2278.35	2278.65
2025.01.03	15:00:00	2278.65	2279.75	2278.55	2279.55
2025.01.03	15:15:00	2279.55	2279.65	2278.45	2278.75
2025.01.03	15:30:00	2278.75	2278.85	2277.65	2277.95
2025.01.03	15:45:00	2277.95	2278.05	2276.85	2277.15
2025.01.03	16:00:00	2277.15	2278.25	2277.05	2278.05
2025.01.03	16:15:00	2278.05	2278.15	2276.95	2277.25
2025.01.03	16:30:00	2277.25	2277.35	2276.15	2276.45
2025.01.03	16:45:00	2276.45	2276.55	2275.35	2275.65
2025.01.03	17:00:00	2275.65	2276.75	2275.55	2276.55
2-025.01.03	17:15:00	2276.55	2276.65	2275.45	2275.75
2025.01.03	17:30:00	2275.75	2275.85	2274.65	2274.95
2025.01.03	17:45:00	2274.95	2275.05	2273.85	2274.15
2025.01.03	18:00:00	2274.15	2275.25	2274.05	2275.05
2025.01.03	18:15:00	2275.05	2275.15	2273.95	2274.25
2025.01.03	18:30:00	2274.25	2274.35	2273.15	2273.45
2025.01.03	18:45:00	2273.45	2273.55	2272.35	2272.65
2025.01.03	19:00:00	2272.65	2273.75	2272.55	2273.55
2025.01.03	19:15:00	2273.55	2273.65	2272.45	2272.75
2025.01.03	19:30:00	2272.75	2272.85	2271.65	2271.95
2025.01.03	19:45:00	2271.95	2272.05	2270.85	2271.15
2025.01.03	20:00:00	2271.15	2272.25	2271.05	2272.05
2025.01.03	20:15:00	2272.05	2272.15	2270.95	2271.25
2025.01.03	20:30:00	2271.25	2271.35	2270.15	2270.45
2025.01.03	20:45:00	2270.45	2270.55	2269.35	2269.65
2025.01.03	21:00:00	2269.65	2270.75	2269.55	2270.55
2025.01.03	21:15:00	2270.55	2270.65	2269.45	2269.75
2025.01.03	21:30:00	2269.75	2285.85	2269.65	2285.45
2025.01.03	21:45:00	2285.45	2286.55	2284.35	2284.65
2025.01.03	22:00:00	2284.65	2285.75	2284.55	2285.55
2025.01.03	22:15:00	2285.55	2285.65	2284.45	2284.75
2025.01.03	22:30:00	2284.75	2284.85	2283.65	2283.95
2025.01.03	22:45:00	2283.95	2284.05	2282.85	2283.15
2025.01.03	23:00:00	2283.15	2284.25	2283.05	2284.05
2025.01.03	23:15:00	2284.05	2284.15	2282.95	2283.25
2025.01.03	23:30:00	2283.25	2283.35	2282.15	2282.45
2025.01.03	23:45:00	2282.45	2282.55	2281.35	2281.65
`;
    try {
        state.fullDataset = parseOHLC(rawData);
        resolve(true);
    } catch (error) {
        console.error("無法解析內嵌數據:", error);
        el('current-date').textContent = "數據錯誤";
        resolve(false);
    }
  });
}

function parseOHLC(text) {
  const lines = text.split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
  if (lines.length < 2) return [];
  return lines.slice(1).map(line => {
    const parts = line.split('\t');
    if (parts.length < 6) return null;
    const dateStr = parts[0].replace(/\./g, '-');
    const timeStr = parts[1];
    return {
      date: new Date(`${dateStr}T${timeStr}`),
      o: parseFloat(parts[2]), h: parseFloat(parts[3]),
      l: parseFloat(parts[4]), c: parseFloat(parts[5]),
    };
  }).filter(Boolean);
}

// ===== 遊戲流程 =====
function startGame() {
  if (!state.fullDataset || state.fullDataset.length < 200) {
      console.error("市場數據不足或載入失敗，無法開始遊戲。");
      el('current-date').textContent = "數據錯誤";
      return;
  }
  
  state.gameData = [];
  state.currentBarIndex = 0;
  state.positions = [];
  state.journal = [];
  state.chartAnimations = [];
  state.account = { balance: CONFIG.initialBalance, equity: CONFIG.initialBalance };
  state.isPaused = true;
  clearInterval(state.gameTimer);
  state.animationSpeed = 400; 
  document.querySelector('.speed-btn.active').classList.remove('active');
  document.querySelector('.speed-btn[data-speed="400"]').classList.add('active');

  state.view = { barsInView: 100, offset: 0 };
  state.pan = { isPanning: false, startX: 0, startOffset: 0 };
  state.barAnimation = { progress: 1, isAnimating: false };

  const minStartDate = new Date('2025-01-01T00:00:00');
  const maxStartDate = new Date('2025-07-15T00:00:00');
  
  const minStartIndex = state.fullDataset.findIndex(b => b.date >= minStartDate);
  const maxStartIndex = state.fullDataset.findIndex(b => b.date >= maxStartDate);
  
  if (minStartIndex === -1 || maxStartIndex === -1) {
      console.error("在數據集中找不到指定的日期範圍");
      return;
  }

  const randomStartIndex = Math.floor(Math.random() * (maxStartIndex - minStartIndex + 1)) + minStartIndex;
  
  const startDate = state.fullDataset[randomStartIndex].date;
  let endDate = new Date(startDate);
  endDate.setMonth(endDate.getMonth() + CONFIG.gameDurationMonths);

  let endIndex = state.fullDataset.findIndex(b => b.date >= endDate);
  if (endIndex === -1) endIndex = state.fullDataset.length - 1;
  
  state.gameData = state.fullDataset.slice(randomStartIndex, endIndex);
  state.currentBarIndex = 0;
  state.view.offset = state.currentBarIndex - state.view.barsInView;

  updateHUD();
  updatePositionsList();
  updateJournalList();
  draw();
  el('play-pause-btn').textContent = '▶';
  el('play-pause-btn').disabled = false;
  el('step-btn').disabled = false;
  
  if (!hasPlayedOnce) {
    setTimeout(() => {
        startTutorial();
        hasPlayedOnce = true;
    }, 100);
  }
}

function gameLoop() {
    if (state.isPaused || state.barAnimation.isAnimating) return;
    
    const bar = state.gameData[state.currentBarIndex];
    if (bar) {
        const dateStr = bar.date.toISOString().slice(0, 10);
        const event = EVENTS[dateStr];
        if (event && bar.date.getUTCHours() * 60 + bar.date.getUTCMinutes() >= parseInt(event.time.split(':')[0]) * 60) {
            if (!event.triggered) {
                pauseGame();
                showEventModal(event);
                event.triggered = true;
                return;
            }
        }
    }

    state.currentBarIndex++;
    if (state.currentBarIndex >= state.gameData.length) {
        pauseGame();
        showEndScreen();
        return;
    }
    
    animateBar();
}

function animateBar() {
    state.barAnimation.isAnimating = true;
    let startTime = performance.now();

    function frame(currentTime) {
        const elapsedTime = currentTime - startTime;
        let progress = elapsedTime / state.animationSpeed;
        if (progress >= 1) {
            progress = 1;
            state.barAnimation.isAnimating = false;
        }
        
        updatePositions();
        updateHUD();
        if (state.view.offset + state.view.barsInView < state.currentBarIndex + 10) {
            state.view.offset = state.currentBarIndex - state.view.barsInView + 10;
        }
        draw(progress);

        if (progress < 1) {
            requestAnimationFrame(frame);
        }
    }
    requestAnimationFrame(frame);
}


function stepForward() {
    pauseGame();
    if (state.currentBarIndex < state.gameData.length - 1) {
        state.currentBarIndex++;
        updatePositions();
        updateHUD();
        if (state.view.offset + state.view.barsInView < state.currentBarIndex + 10) {
            state.view.offset = state.currentBarIndex - state.view.barsInView + 10;
        }
        draw();
    } else {
        showEndScreen();
    }
}

function pauseGame() {
    state.isPaused = true;
    clearInterval(state.gameTimer);
    el('play-pause-btn').classList.remove('active');
    el('play-pause-btn').textContent = '▶';
}

function resumeGame() {
    state.isPaused = false;
    clearInterval(state.gameTimer);
    state.gameTimer = setInterval(gameLoop, state.animationSpeed);
    el('play-pause-btn').classList.add('active');
    el('play-pause-btn').textContent = '❚❚';
}

// ===== 交易邏輯 =====
function logTransaction(position, exitPrice, exitTime) {
    const pnl = (exitPrice - position.entryPrice) * (position.side === 'buy' ? 1 : -1) * position.lots * 100;
    state.journal.unshift({
        ...position,
        exitPrice,
        exitTime,
        pnl
    });
    updateJournalList();
}

function openOrder(side) {
    const lots = parseFloat(el('trade-lots').value);
    const sl = parseFloat(el('trade-sl').value) || null;
    const tp = parseFloat(el('trade-tp').value) || null;

    if (!lots || lots <= 0) {
        console.error("請輸入有效的手數");
        return;
    }
    const currentPrice = state.gameData[state.currentBarIndex].c;
    const entryTime = state.gameData[state.currentBarIndex].date;
    
    state.positions.push({ id: Date.now(), side, entryPrice: currentPrice, entryTime, lots, sl, tp, pnl: 0 });
    
    addChartAnimation(currentPrice, side, 'open');
    
    updatePositionsList();
    draw();
}

function closePosition(positionId) {
    const index = state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;

    const position = state.positions[index];
    const exitPrice = state.gameData[state.currentBarIndex].c;
    const exitTime = state.gameData[state.currentBarIndex].date;
    const finalPnl = (exitPrice - position.entryPrice) * (position.side === 'buy' ? 1 : -1) * position.lots * 100;
    
    logTransaction(position, exitPrice, exitTime);
    addChartAnimation(exitPrice, position.side, 'close', finalPnl);

    state.account.balance += finalPnl;
    state.positions.splice(index, 1);
    
    updatePositionsList();
    updateHUD();
    draw();
}

function closeAllPositions() {
    if (state.positions.length === 0) return;
    const exitPrice = state.gameData[state.currentBarIndex].c;
    const exitTime = state.gameData[state.currentBarIndex].date;

    for (let i = state.positions.length - 1; i >= 0; i--) {
        const position = state.positions[i];
        const finalPnl = (exitPrice - position.entryPrice) * (position.side === 'buy' ? 1 : -1) * position.lots * 100;
        logTransaction(position, exitPrice, exitTime);
        addChartAnimation(exitPrice, position.side, 'close', finalPnl);
        state.account.balance += finalPnl;
    }
    state.positions = [];
    updatePositionsList();
    updateHUD();
    draw();
}

function modifyPosition(positionId) {
    const position = state.positions.find(p => p.id === positionId);
    if (!position) return;

    const slInput = el(`pos-sl-${positionId}`);
    const tpInput = el(`pos-tp-${positionId}`);

    const newSl = parseFloat(slInput.value) || null;
    const newTp = parseFloat(tpInput.value) || null;
    
    position.sl = newSl;
    position.tp = newTp;

    draw(); 
    
    const itemEl = slInput.closest('.position-item');
    itemEl.style.transition = 'none';
    itemEl.style.backgroundColor = 'var(--accent)';
    setTimeout(() => {
        itemEl.style.transition = 'background-color 0.5s ease';
        itemEl.style.backgroundColor = '';
    }, 100);
}


function updatePositions() {
    if (!state.gameData || state.currentBarIndex >= state.gameData.length) return;
    const currentBar = state.gameData[state.currentBarIndex];
    let totalPnl = 0;
    for (let i = state.positions.length - 1; i >= 0; i--) {
        const p = state.positions[i];
        const direction = p.side === 'buy' ? 1 : -1;
        p.pnl = (currentBar.c - p.entryPrice) * direction * p.lots * 100;
        totalPnl += p.pnl;
        
        const hitSL = (p.sl && ((p.side === 'buy' && currentBar.l <= p.sl) || (p.side === 'sell' && currentBar.h >= p.sl)));
        const hitTP = (p.tp && ((p.side === 'buy' && currentBar.h >= p.tp) || (p.side === 'sell' && currentBar.l <= p.tp)));
        
        if (hitSL || hitTP) {
            const exitPrice = hitSL ? p.sl : p.tp;
            const finalPnl = (exitPrice - p.entryPrice) * direction * p.lots * 100;
            logTransaction(p, exitPrice, currentBar.date);
            addChartAnimation(exitPrice, p.side, 'close', finalPnl);
            state.account.balance += finalPnl;
            state.positions.splice(i, 1);
            updatePositionsList();
        }
    }
    state.account.equity = state.account.balance + totalPnl;
}

// ===== UI 更新 =====
function updateHUD() {
    const currentDate = state.gameData[state.currentBarIndex]?.date;
    if(currentDate) el('current-date').textContent = currentDate.toISOString().slice(0, 10);
    el('equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - state.account.balance;
    const pnlEl = el('total-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = `value ${totalPnl >= 0 ? 'pnl-up' : 'pnl-down'}`;
    const progress = (state.currentBarIndex + 1) / state.gameData.length * 100;
    el('progress-bar-inner').style.width = `${progress}%`;
}
function updatePositionsList() {
    const listEl = el('positions-list');
    if (state.positions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">目前沒有持倉</p>';
        return;
    }
    listEl.innerHTML = state.positions.map(p => {
        const pnlClass = p.pnl >= 0 ? 'pnl-up' : 'pnl-down';
        const sideClass = p.side === 'buy' ? 'side-buy' : 'side-sell';
        const sideText = p.side === 'buy' ? '買入' : '賣出';
        
        return `
        <div class="position-item">
            <div class="position-item-info">
                <span class="${sideClass}">${sideText}</span> ${p.lots} 手 @ ${p.entryPrice.toFixed(2)}
            </div>
            <div class="position-item-pnl ${pnlClass}">
                ${p.pnl.toFixed(2)}
            </div>
            <div class="position-item-sl input-group">
                <label for="pos-sl-${p.id}">停損 SL</label>
                <input id="pos-sl-${p.id}" type="number" placeholder="無" value="${p.sl || ''}">
            </div>
            <div class="position-item-tp input-group">
                <label for="pos-tp-${p.id}">停利 TP</label>
                <input id="pos-tp-${p.id}" type="number" placeholder="無" value="${p.tp || ''}">
            </div>
            <div class="position-item-actions">
                <button class="btn modify-btn" onclick="modifyPosition(${p.id})">修改</button>
                <button class="btn close-btn" onclick="closePosition(${p.id})">平倉</button>
            </div>
        </div>`;
    }).join('');
}

function updateJournalList() {
    const listEl = el('journal-list');
    if (state.journal.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">沒有交易紀錄</p>';
        return;
    }
    listEl.innerHTML = state.journal.map(j => {
        const pnlClass = j.pnl >= 0 ? 'pnl-up' : 'pnl-down';
        const sideText = j.side === 'buy' ? '買入' : '賣出';
        const pnlText = `${j.pnl >= 0 ? '+' : ''}${j.pnl.toFixed(2)}`;
        const timeFormat = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
        const entryTimeStr = j.entryTime.toLocaleTimeString('en-GB', timeFormat);
        const exitTimeStr = j.exitTime.toLocaleTimeString('en-GB', timeFormat);

        return `
        <div class="journal-item">
            <div class="journal-item-info">
                ${sideText} ${j.lots} 手 @ ${j.entryPrice.toFixed(2)} → ${j.exitPrice.toFixed(2)}
            </div>
            <div class="journal-item-time">
                ${entryTimeStr} → ${exitTimeStr}
            </div>
            <div class="journal-item-pnl ${pnlClass}">
                ${pnlText}
            </div>
        </div>`;
    }).join('');
}


function showEventModal(event) {
    el('event-title').textContent = event.title;
    el('event-desc').textContent = event.desc;
    el('eventModal').classList.add('visible');
}

function showEndScreen() {
    el('final-equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - CONFIG.initialBalance;
    const pnlEl = el('final-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = `value ${totalPnl >= 0 ? 'pnl-up' : 'pnl-down'}`;
    
    el('endGameModal').classList.add('visible');
    el('play-pause-btn').disabled = true;
    el('step-btn').disabled = true;
}

// ===== 繪圖輔助函式 =====
function drawPriceAxis(yMin, yMax, chartH) {
    const priceAxisEl = el('price-axis');
    priceAxisEl.innerHTML = '';
    const numTicks = Math.max(2, Math.floor(chartH / 60));

    for (let i = 0; i <= numTicks; i++) {
        const price = yMin + (i / numTicks) * (yMax - yMin);
        const yPos = chartH - (i / numTicks) * chartH;
        const tick = document.createElement('div');
        tick.className = 'price-axis-tick';
        tick.style.top = `${yPos}px`;
        tick.textContent = price.toFixed(2);
        priceAxisEl.appendChild(tick);
    }
}

function drawCurrentPriceLine(y) {
    const priceLinesContainer = el('price-lines-container');
    priceLinesContainer.innerHTML = '';

    if (!state.gameData || state.currentBarIndex >= state.gameData.length) return;

    const currentPrice = state.gameData[state.currentBarIndex].c;
    const yPos = y(currentPrice);
    
    const rect = canvas.getBoundingClientRect();
    if (yPos < 0 || yPos > rect.height - CONFIG.timeAxisHeight) return;

    const isUp = state.currentBarIndex > 0 && currentPrice >= state.gameData[state.currentBarIndex - 1].c;
    const color = isUp ? CHART_COLORS.up : CHART_COLORS.down;

    const line = document.createElement('div');
    line.className = 'price-line';
    line.style.top = `${yPos}px`;
    
    const label = document.createElement('div');
    label.className = 'price-line-label';
    label.style.top = `${yPos}px`;
    label.style.backgroundColor = color;
    label.textContent = currentPrice.toFixed(2);

    priceLinesContainer.appendChild(line);
    priceLinesContainer.appendChild(label);
}

function drawTimeAxis(ctx, W, H, startIdx, endIdx, barWidth, offset) {
    ctx.fillStyle = CHART_COLORS.text;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const labelMod = Math.ceil(state.view.barsInView / (W / 100)); // Approx one label every 100px
    for (let i = Math.floor(startIdx); i < endIdx; i++) {
        if (i < 0 || i >= state.gameData.length || i % labelMod !== 0) continue;
        
        const bar = state.gameData[i];
        const x = (i - offset) * barWidth + barWidth / 2;

        const date = bar.date;
        const timeStr = `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        ctx.fillText(timeStr, x, H - CONFIG.timeAxisHeight + 5);
    }
}

function addChartAnimation(price, side, type, pnl) {
    state.chartAnimations.push({
        price,
        side,
        type, // 'open' or 'close'
        pnl, // only for 'close' type
        startTime: performance.now(),
        duration: 800 
    });
    if (state.isPaused) {
        requestAnimationFrame(() => draw()); 
    }
}


// ===== 繪圖 =====
function draw(animationProgress = 1) {
  if (state.chartAnimations.length > 0 && !state.barAnimation.isAnimating) {
      requestAnimationFrame(() => draw());
  }
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = rect.height;
  const chartH = H - CONFIG.timeAxisHeight;
  
  ctx.fillStyle = CHART_COLORS.bg;
  ctx.fillRect(0, 0, W, H);

  if (!state.gameData || state.gameData.length === 0) return;
  const startIdx = Math.floor(state.view.offset);
  const endIdx = startIdx + Math.floor(state.view.barsInView);
  const dataInView = state.gameData.slice(Math.max(0, startIdx), Math.min(state.currentBarIndex + 1, endIdx));
  if (dataInView.length === 0) return;
  
  const hi = Math.max(...dataInView.map(b => b.h));
  const lo = Math.min(...dataInView.map(b => b.l));
  const pad = (hi - lo) * 0.1 || 1;
  const yMax = hi + pad, yMin = lo - pad;
  const barWidth = W / state.view.barsInView;
  const y = v => chartH - ((v - yMin) / (yMax - yMin) * chartH);
  
  drawPriceAxis(yMin, yMax, chartH);
  drawCurrentPriceLine(y);
  drawTimeAxis(ctx, W, H, startIdx, endIdx, barWidth, state.view.offset);

  // 繪製日期分隔線
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 4]);
  for (let i = Math.floor(startIdx); i < endIdx; i++) {
      if (i <= 0 || i >= state.gameData.length) continue;
      
      const bar = state.gameData[i];
      const prevBar = state.gameData[i - 1];
      if (bar.date.getDate() !== prevBar.date.getDate()) {
          const x = (i - state.view.offset) * barWidth;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, chartH);
          ctx.stroke();
      }
  }
  ctx.setLineDash([]);

  // 繪製 K 棒
  for (let i = 0; i < dataInView.length; i++) {
    const barIndex = startIdx + i;
    const b = dataInView[i];
    const x = (barIndex - state.view.offset) * barWidth + barWidth / 2;
    const isLastBar = barIndex === state.currentBarIndex;
    
    const progress = isLastBar ? animationProgress : 1;
    const up = b.c >= b.o;
    const openY = y(b.o);
    let lowY, highY, closeY;

    if (isLastBar && progress < 1) {
        const wickProgress = Math.max(0, Math.min(1, progress / 0.5));
        const bodyProgress = Math.max(0, Math.min(1, (progress - 0.5) / 0.5));

        const currentLow = b.o + (b.l - b.o) * wickProgress;
        const currentHigh = b.o + (b.h - b.o) * wickProgress;
        const currentClose = b.o + (b.c - b.o) * bodyProgress;

        lowY = y(currentLow);
        highY = y(currentHigh);
        closeY = y(currentClose);
    } else {
        lowY = y(b.l);
        highY = y(b.h);
        closeY = y(b.c);
    }

    const color = up ? CHART_COLORS.up : CHART_COLORS.down;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 1.5;
    
    ctx.beginPath();
    ctx.moveTo(x, highY);
    ctx.lineTo(x, lowY);
    ctx.stroke();
    
    const w = Math.max(2, barWidth * 0.7);
    ctx.fillRect(x - w / 2, Math.min(openY, closeY), w, Math.max(1, Math.abs(openY - closeY)));
  }
  
  // 繪製持倉線 & 損益標籤
  state.positions.forEach(p => {
    ctx.font = 'bold 12px sans-serif';
    ctx.textBaseline = 'middle';
    
    const entryY = y(p.entryPrice);
    if (entryY <= chartH && entryY >= 0) {
        ctx.strokeStyle = p.side === 'buy' ? CHART_COLORS.up : CHART_COLORS.down;
        ctx.setLineDash([2, 4]);
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, entryY); ctx.lineTo(W - 60, entryY); ctx.stroke();
        
        const pnlText = `${p.pnl >= 0 ? '+' : ''}${p.pnl.toFixed(2)}`;
        const labelText = `${p.side.toUpperCase()} @ ${p.entryPrice.toFixed(2)} (${pnlText})`;
        ctx.textAlign = 'left';
        ctx.fillStyle = p.pnl >= 0 ? CHART_COLORS.up : CHART_COLORS.down;
        ctx.fillRect(5, entryY - 10, ctx.measureText(labelText).width + 8, 20);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(labelText, 9, entryY);
    }

    if (p.sl) {
        const slY = y(p.sl);
        if (slY <= chartH && slY >= 0) {
            ctx.strokeStyle = CHART_COLORS.down;
            ctx.beginPath(); ctx.moveTo(0, slY); ctx.lineTo(W - 60, slY); ctx.stroke();
            ctx.textAlign = 'right';
            ctx.fillStyle = CHART_COLORS.down;
            ctx.fillText(`SL ${p.sl.toFixed(2)}`, W - 65, slY);
        }
    }
    if (p.tp) {
        const tpY = y(p.tp);
        if (tpY <= chartH && tpY >= 0) {
            ctx.strokeStyle = CHART_COLORS.up;
            ctx.beginPath(); ctx.moveTo(0, tpY); ctx.lineTo(W - 60, tpY); ctx.stroke();
            ctx.textAlign = 'right';
            ctx.fillStyle = CHART_COLORS.up;
            ctx.fillText(`TP ${p.tp.toFixed(2)}`, W - 65, tpY);
        }
    }
    ctx.setLineDash([]);
  });

  // 繪製成交動畫
  const now = performance.now();
  state.chartAnimations = state.chartAnimations.filter(anim => {
      const elapsed = now - anim.startTime;
      if (elapsed > anim.duration) return false;

      const progress = elapsed / anim.duration;
      const x = (state.currentBarIndex - state.view.offset) * barWidth + barWidth / 2;
      const animY = y(anim.price);
      
      ctx.globalAlpha = 1 - progress;
      const color = anim.side === 'buy' ? CHART_COLORS.up : CHART_COLORS.down;

      if (anim.type === 'open') {
          const arrowSize = 10 + progress * 10;
          ctx.fillStyle = color;
          ctx.beginPath();
          if (anim.side === 'buy') {
              ctx.moveTo(x, animY + arrowSize);
              ctx.lineTo(x - arrowSize / 2, animY);
              ctx.lineTo(x + arrowSize / 2, animY);
          } else { // sell
              ctx.moveTo(x, animY - arrowSize);
              ctx.lineTo(x - arrowSize / 2, animY);
              ctx.lineTo(x + arrowSize / 2, animY);
          }
          ctx.closePath();
          ctx.fill();
      } else { // close
          ctx.font = `bold ${14 + progress * 8}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = anim.pnl >= 0 ? CHART_COLORS.up : CHART_COLORS.down;
          const pnlText = `${anim.pnl >= 0 ? '+' : ''}${anim.pnl.toFixed(2)}`;
          ctx.fillText(pnlText, x, animY - 15 - (progress * 30));
      }
      
      ctx.globalAlpha = 1;
      return true;
  });
}

// ===== 互動控制 =====
function setupInteraction() {
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);
    chartWrap.addEventListener('wheel', e => { e.preventDefault(); handleZoom(e.deltaY < 0 ? 1 : -1); }, { passive: false });
    const startPan = (x) => { state.pan.isPanning = true; state.pan.startX = x; state.pan.startOffset = state.view.offset; };
    const movePan = (x) => { if (!state.pan.isPanning) return; const dx = x - state.pan.startX; const barWidth = chartWrap.clientWidth / state.view.barsInView; state.view.offset = state.pan.startOffset - dx / barWidth; clampOffset(true); draw(); };
    const endPan = () => { state.pan.isPanning = false; };
    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);
    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5) : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    clampOffset(true);
    draw();
}
function clampOffset(isUserAction = false) {
    const maxOffset = state.currentBarIndex - (isUserAction ? state.view.barsInView : 5);
    state.view.offset = Math.max(0, Math.min(state.view.offset, maxOffset));
}

// ===== Input Stepper Logic =====
function setupSteppers() {
    el('trade-panel-content').addEventListener('click', e => {
        const button = e.target.closest('.stepper-btn');
        if (!button) return;

        const targetInputId = button.dataset.target;
        const direction = button.dataset.direction;
        const input = el(targetInputId);

        if (!input) return;

        let currentValue = parseFloat(input.value);
        const step = parseFloat(input.step || input.dataset.step || 1);
        
        if (['trade-sl', 'trade-tp'].includes(targetInputId) && isNaN(currentValue)) {
            if (state.gameData && state.gameData[state.currentBarIndex]) {
                const currentPrice = state.gameData[state.currentBarIndex].c;
                input.value = currentPrice.toFixed(2);
                return;
            }
        }

        if (isNaN(currentValue)) currentValue = 0;

        let newValue = direction === 'up' ? currentValue + step : currentValue - step;
        
        if (targetInputId === 'trade-lots') {
            const min = parseFloat(input.min);
            if (!isNaN(min) && newValue < min) {
                newValue = min;
            }
        }
        
        const decimals = (String(step).split('.')[1] || '').length;
        input.value = newValue.toFixed(decimals);
    });
}

// ===== 新手導引邏輯 =====
let tutorialStep = 0;
const tutorialSteps = [
    {
        elementId: null,
        text: '歡迎來到交易挑戰賽！您的目標是在一個月的模擬時間內，盡可能地獲利。',
        position: 'center'
    },
    {
        elementId: 'chartWrap',
        text: '這裡是市場走勢圖。綠色 K 棒代表上漲，紅色 K 棒代表下跌。您可以拖曳或使用滾輪縮放。',
        position: 'bottom'
    },
    {
        elementId: 'trade-panel-content',
        text: '在這裡設定手數、停損與停利，然後點擊「Buy」或「Sell」來下單。',
        position: 'top'
    },
    {
        elementId: 'playback-controls',
        text: '使用這些按鈕來控制時間。點擊「▶」讓市場自動前進，或點擊「逐K→」一根一根地觀看。',
        position: 'top'
    }
];

function showTutorialStep(stepIndex) {
    const step = tutorialSteps[stepIndex];
    const overlay = el('tutorial-overlay');
    const highlight = el('tutorial-highlight');
    const box = el('tutorial-box');
    const text = el('tutorial-text');
    const nextBtn = el('tutorial-next');
    const dots = el('tutorial-dots');

    text.textContent = step.text;

    dots.innerHTML = tutorialSteps.map((_, i) => 
        `<div class="tutorial-dot ${i === stepIndex ? 'active' : ''}"></div>`
    ).join('');
    
    // FIX: Use a timeout to ensure the DOM is ready for getBoundingClientRect
    setTimeout(() => {
        if (step.elementId) {
            const target = el(step.elementId);
            if (!target) {
                console.error(`Tutorial Error: Element with ID "${step.elementId}" not found.`);
                endTutorial();
                return;
            }
            const rect = target.getBoundingClientRect();
            
            highlight.style.left = `${rect.left - 5}px`;
            highlight.style.top = `${rect.top - 5}px`;
            highlight.style.width = `${rect.width + 10}px`;
            highlight.style.height = `${rect.height + 10}px`;
            
            if (step.position === 'top') {
                box.style.top = `${rect.top - box.offsetHeight - 15}px`;
                box.style.left = `${rect.left + rect.width / 2 - box.offsetWidth / 2}px`;
            } else if (step.position === 'bottom') {
                box.style.top = `${rect.bottom + 15}px`;
                box.style.left = `${rect.left + rect.width / 2 - box.offsetWidth / 2}px`;
            }
        } else { 
            highlight.style.width = '0px';
            highlight.style.height = '0px';
            highlight.style.left = '50%';
            highlight.style.top = '50%';
            box.style.top = `50%`;
            box.style.left = `50%`;
            box.style.transform = 'translate(-50%, -50%)';
        }
    }, 50);

    if (stepIndex === tutorialSteps.length - 1) {
        nextBtn.textContent = '開始挑戰！';
    } else {
        nextBtn.textContent = '下一步';
    }

    overlay.classList.add('visible');
}

function endTutorial() {
    el('tutorial-overlay').classList.remove('visible');
    el('play-pause-btn').classList.add('glowing-btn');
    setTimeout(() => {
        el('play-pause-btn').classList.remove('glowing-btn');
    }, 3000);
}

function startTutorial() {
    tutorialStep = 0;
    showTutorialStep(tutorialStep);
}

// ===== 初始化 =====
async function init() {
  canvas = el('chart');
  ctx = canvas.getContext('2d');
  chartWrap = el('chartWrap');
  
  const dataLoaded = await loadData();
  
  if (dataLoaded) {
    const style = getComputedStyle(document.documentElement);
    CHART_COLORS.up = style.getPropertyValue('--chart-up').trim();
    CHART_COLORS.down = style.getPropertyValue('--chart-down').trim();
    CHART_COLORS.bg = style.getPropertyValue('--chart-bg').trim();
    CHART_COLORS.text = style.getPropertyValue('--chart-text').trim();

    el('btnBuy').addEventListener('click', () => openOrder('buy'));
    el('btnSell').addEventListener('click', () => openOrder('sell'));
    el('btnCloseAll').addEventListener('click', closeAllPositions);
    
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if(btn.dataset.tab === 'positions-panel') {
                pauseGame();
                updatePositionsList();
            } else if (btn.dataset.tab === 'journal-panel') {
                pauseGame();
                updateJournalList();
            }
            document.querySelector('.tab-btn.active').classList.remove('active');
            document.querySelector('.tab-content.active').classList.remove('active');
            btn.classList.add('active');
            el(btn.dataset.tab).classList.add('active');
        });
    });
    
    el('eventModal').addEventListener('click', (e) => {
        if (e.target === el('eventModal') || e.target.id === 'event-continue-btn') {
            el('eventModal').classList.remove('visible');
            resumeGame();
        }
    });

    el('play-pause-btn').addEventListener('click', () => {
        el('play-pause-btn').classList.remove('glowing-btn');
        state.isPaused ? resumeGame() : pauseGame();
    });
    el('step-btn').addEventListener('click', () => {
        el('play-pause-btn').classList.remove('glowing-btn');
        stepForward();
    });
    el('speed-controls').addEventListener('click', (e) => {
        if (e.target.classList.contains('speed-btn')) {
            document.querySelector('.speed-btn.active').classList.remove('active');
            e.target.classList.add('active');
            state.animationSpeed = parseInt(e.target.dataset.speed);
            if (!state.isPaused) {
                resumeGame();
            }
        }
    });
    
    // Tutorial navigation
    el('tutorial-next').addEventListener('click', () => {
        tutorialStep++;
        if (tutorialStep >= tutorialSteps.length) {
            endTutorial();
        } else {
            showTutorialStep(tutorialStep);
        }
    });
    el('tutorial-skip').addEventListener('click', endTutorial);

    // End Game Modal Button
    el('restart-btn').addEventListener('click', () => {
        el('endGameModal').classList.remove('visible');
        startGame();
    });


    setupInteraction();
    setupSteppers(); 
    startGame();
  }
}

document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
