<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>æƒ…å¢ƒå¼äº¤æ˜“æ¨¡æ“¬å™¨</title>
<style>
:root {
  --bg: #1a1e2b;
  --panel: #2a2f42;
  --panel-soft: #242838;
  --text: #eef3ff;
  --muted: #8a93b0;
  --border-color: #4b5169;
  --accent: #4a72ff;
  --good: #28c782;
  --danger: #ff5f6d;
  --grid: rgba(75, 81, 105, 0.5);
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: var(--bg);
  color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
  background-color: var(--panel);
}

/* --- é ‚éƒ¨è³‡è¨Š --- */
.header {
  text-align: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}
.header h1 { margin: 0; font-size: 18px; color: var(--accent); }
.header p { margin: 4px 0 0; color: var(--muted); font-size: 13px; line-height: 1.4; }

/* --- åœ–è¡¨å€ --- */
#chartWrap {
  flex-grow: 1;
  position: relative;
  background: var(--panel-soft);
  min-height: 0;
  cursor: grab;
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }
.decision-line {
  position: absolute;
  top: 0;
  bottom: 0;
  border-left: 2px dashed var(--accent);
  pointer-events: none;
  opacity: 0.7;
}
.price-tag {
  position: absolute;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  color: white;
  transform: translateY(-50%);
  pointer-events: none;
  backdrop-filter: blur(2px);
}
.time-axis-label {
    position: absolute;
    bottom: 8px;
    color: var(--muted);
    font-size: 12px;
    transform: translateX(-50%);
}
.zoom-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
}
.zoom-btn {
    width: 32px;
    height: 32px;
    background: rgba(42, 47, 66, 0.8);
    border: 1px solid var(--border-color);
    color: var(--text);
    border-radius: 8px;
    font-size: 20px;
    cursor: pointer;
}

/* --- åº•éƒ¨æ“ä½œå€ --- */
.actions-panel {
  flex-shrink: 0;
  padding: 16px;
  background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.main-actions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
.main-actions .btn {
  padding: 16px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  transition: transform 0.1s ease;
}
.btn.buy { background: var(--good); color: white; }
.btn.sell { background: var(--danger); color: white; }
.btn:active { transform: scale(0.97); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }

/* --- çµæœå½ˆçª— --- */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.7);
  backdrop-filter: blur(4px); z-index: 9997;
  display: flex; justify-content: center; align-items: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: min(90vw, 320px); background: var(--panel);
  border: 1px solid var(--border-color); border-radius: 16px;
  padding: 24px; text-align: center;
  transform: scale(0.9); transition: transform 0.3s ease;
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-title { font-size: 32px; font-weight: bold; margin: 0 0 8px; }
.modal-title.win { color: var(--good); }
.modal-title.loss { color: var(--danger); }
.modal-subtitle { font-size: 16px; color: var(--muted); margin: 0 0 24px; }
.modal-content .btn { width: 100%; margin-top: 8px; }
.btn.cta { background: var(--accent); color: white; }
.btn.retry { background: var(--panel-soft); color: var(--text); }

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <h1 id="game-title">ç­‰å¾…å¸‚å ´è¡Œæƒ…...</h1>
    <p id="game-subtitle">è¼‰å…¥æ•¸æ“šä¸­ï¼Œè«‹ç¨å€™ã€‚</p>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div class="zoom-controls">
        <button id="zoom-in" class="zoom-btn">+</button>
        <button id="zoom-out" class="zoom-btn">-</button>
    </div>
  </div>
  <div class="actions-panel">
    <div class="main-actions">
      <button class="btn buy" id="btnBuy">è²·å…¥ (çœ‹æ¼²)</button>
      <button class="btn sell" id="btnSell">è³£å‡º (çœ‹è·Œ)</button>
    </div>
  </div>
</div>

<div id="resultModal" class="modal-overlay">
  <div class="modal-content">
    <h2 id="result-title" class="modal-title"></h2>
    <p id="result-subtitle" class="modal-subtitle"></p>
    <button class="btn cta" id="btnCta">æ¢ç´¢å®Œæ•´åŠŸèƒ½</button>
    <button class="btn retry" id="btnRetry">å†ç©ä¸€æ¬¡</button>
  </div>
</div>

<script>
// ===== è²¡ç¶“äº‹ä»¶æ•¸æ“šèˆ‡æè¿° =====
const EVENTS = {
  "2025-01-03": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-01-15": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹æ¶ˆè²»è€…ç‰©åƒ¹æŒ‡æ•¸ (CPI)", type: "CPI" },
  "2025-01-29": { time: "03:00", text: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºè­° (FOMC)", type: "FOMC" },
  "2025-02-07": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-03-07": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-03-19": { time: "03:00", text: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºè­° (FOMC)", type: "FOMC" },
  "2025-04-04": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-05-01": { time: "03:00", text: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºè­° (FOMC)", type: "FOMC" },
  "2025-05-02": { time: "21:30", text: "ï¿½ğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-06-06": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
  "2025-06-19": { time: "03:00", text: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºè­° (FOMC)", type: "FOMC" },
  "2025-07-31": { time: "03:00", text: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºè­° (FOMC)", type: "FOMC" },
  "2025-08-01": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", type: "NFP" },
};

const EVENT_DESCRIPTIONS = {
    "NFP": "ä»Šæ™šå°‡å…¬å¸ƒä¿—ç¨±ã€Œéè¾²ã€çš„ç¾åœ‹å°±æ¥­æ•¸æ“šï¼Œé€™æ˜¯å¸‚å ´æœ€é—œæ³¨çš„æŒ‡æ¨™ä¹‹ä¸€ã€‚æ•¸æ“šå¥½å£å°‡åŠ‡çƒˆå½±éŸ¿é»ƒé‡‘åƒ¹æ ¼ï¼Œå¸‚å ´å±æ¯ä»¥å¾…ï¼",
    "CPI": "é€šè†¨æ•¸æ“š CPI å³å°‡å‡ºçˆï¼é€™å€‹æ•¸å­—å°‡æ±ºå®šè¯æº–æœƒçš„ä¸‹ä¸€æ­¥æ£‹ã€‚é«˜æ–¼é æœŸå¯èƒ½å°è‡´é‡‘åƒ¹ä¸‹è·Œï¼Œåä¹‹å‰‡å¯èƒ½ä¸Šæ¼²ã€‚",
    "FOMC": "å‡Œæ™¨ä¸‰é»ï¼Œè¯æº–æœƒå°‡å®£å¸ƒæœ€æ–°çš„åˆ©ç‡æ±ºç­–ã€‚ä¸»å¸­é®‘å¨çˆ¾çš„ç™¼è¨€æ›´æ˜¯ç„¦é»ä¸­çš„ç„¦é»ï¼Œä»»ä½•é·¹æ´¾æˆ–é´¿æ´¾çš„æš—ç¤ºéƒ½å¯èƒ½å¼•ç™¼å¸‚å ´å·¨éœ‡ã€‚",
    "DEFAULT": "å¸‚å ´æ­£è™•æ–¼é—œéµæ™‚åˆ»ï¼Œå¤šç©ºé›™æ–¹æ¿€çƒˆäº¤æˆ°ã€‚è«‹æ ¹æ“šçœ¼å‰çš„ç·šç´¢ï¼Œåšå‡ºä½ çš„åˆ¤æ–·ï¼"
};

// ===== éŠæˆ²è¨­å®š =====
const CONFIG = {
  futureBars: 30,
  animationSpeed: 60,
  minBarsInView: 20,  // æ”¾å¤§æ™‚æœ€å°‘é¡¯ç¤ºå¹¾æ ¹ K æ£’
  maxBarsInView: 200, // ç¸®å°æ™‚æœ€å¤šé¡¯ç¤ºå¹¾æ ¹ K æ£’
};

// ===== éŠæˆ²ç‹€æ…‹èˆ‡ DOM å…ƒç´  =====
const state = { 
    fullDataset: [], 
    currentGameData: [], 
    isRevealing: false,
    view: {
        barsInView: 100, // é è¨­é¡¯ç¤º 100 æ ¹
        offset: 0, // è¦–åœ–åç§»é‡ (ä»¥ K æ£’ç‚ºå–®ä½)
    },
    pan: {
        isPanning: false,
        startX: 0,
        startOffset: 0,
    }
};
const el = id => document.getElementById(id);
const canvas = el('chart'), ctx = canvas.getContext('2d');
const buyBtn = el('btnBuy'), sellBtn = el('btnSell');
const resultModal = el('resultModal'), resultTitle = el('result-title'), resultSubtitle = el('result-subtitle');
const btnCta = el('btnCta'), btnRetry = el('btnRetry');
const gameTitle = el('game-title'), gameSubtitle = el('game-subtitle');
const chartWrap = el('chartWrap');

// ===== æ•¸æ“šè™•ç† =====
async function loadData() {
  try {
    const response = await fetch('XAUUSD_M15.csv');
    if (!response.ok) throw new Error('Network response was not ok');
    const text = await response.text();
    state.fullDataset = parseOHLC(text);
  } catch (error) {
    console.error("ç„¡æ³•è¼‰å…¥æˆ–è§£æ CSV æ•¸æ“š:", error);
    gameTitle.textContent = "éŒ¯èª¤";
    gameSubtitle.textContent = "ç„¡æ³•è¼‰å…¥å¸‚å ´æ•¸æ“šï¼Œè«‹åˆ·æ–°é é¢ã€‚";
  }
}

function parseOHLC(text) {
  const lines = text.split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
  if (lines.length < 2) return [];
  return lines.slice(1).map(line => {
    const parts = line.split('\t');
    if (parts.length < 6) return null;
    const dateStr = parts[0].replace(/\./g, '-');
    const timeStr = parts[1];
    return {
      date: new Date(`${dateStr}T${timeStr}`),
      o: parseFloat(parts[2]), h: parseFloat(parts[3]),
      l: parseFloat(parts[4]), c: parseFloat(parts[5]),
    };
  }).filter(Boolean);
}

// ===== éŠæˆ²æµç¨‹ =====
function startGame() {
  if (state.fullDataset.length < 200) return; // ç¢ºä¿æœ‰è¶³å¤ æ•¸æ“š

  state.isRevealing = false;
  buyBtn.disabled = false;
  sellBtn.disabled = false;
  resultModal.classList.remove('visible');
  
  // éš¨æ©Ÿé¸å–ä¸€å€‹æ±ºç­–é» (è‡³å°‘é›¢æ•¸æ“šçµå°¾æœ‰ futureBars çš„è·é›¢)
  const decisionIndex = Math.floor(Math.random() * (state.fullDataset.length - CONFIG.futureBars - 100)) + 100;
  const decisionDate = state.fullDataset[decisionIndex].date;
  
  // æ‰¾åˆ°æ˜¨å¤© 00:00 çš„ç´¢å¼•
  let yesterday = new Date(decisionDate);
  yesterday.setDate(yesterday.getDate() - 1);
  yesterday.setHours(0, 0, 0, 0);
  
  let startIndex = state.fullDataset.findIndex(bar => bar.date >= yesterday);
  if (startIndex === -1) startIndex = 0;

  state.currentGameData = state.fullDataset.slice(startIndex, decisionIndex + CONFIG.futureBars);
  state.historyBars = decisionIndex - startIndex;

  // é‡ç½®è¦–åœ–
  state.view.barsInView = 100;
  state.view.offset = state.historyBars - state.view.barsInView; // è®“æ±ºç­–ç·šåœ¨æœ€å³é‚Š

  // è¨­ç½®äº‹ä»¶æƒ…å¢ƒ
  let eventFound = false;
  for (let i = state.historyBars; i < state.currentGameData.length; i++) {
      const bar = state.currentGameData[i];
      const dateStr = bar.date.toISOString().slice(0, 10);
      if (EVENTS[dateStr]) {
          gameTitle.textContent = EVENTS[dateStr].text;
          gameSubtitle.textContent = EVENT_DESCRIPTIONS[EVENTS[dateStr].type] || EVENT_DESCRIPTIONS.DEFAULT;
          eventFound = true;
          break;
      }
  }
  if (!eventFound) {
      gameTitle.textContent = "é—œéµçš„æŠ‰æ“‡æ™‚åˆ»";
      gameSubtitle.textContent = EVENT_DESCRIPTIONS.DEFAULT;
  }

  draw();
}

function handleChoice(choice) {
  if (state.isRevealing) return;
  state.isRevealing = true;
  buyBtn.disabled = true;
  sellBtn.disabled = true;
  gameTitle.textContent = "æ­æ›‰çµæœ...";

  const startPrice = state.currentGameData[state.historyBars - 1].c;
  const endPrice = state.currentGameData[state.currentGameData.length - 1].c;
  const isWin = (choice === 'buy' && endPrice >= startPrice) || (choice === 'sell' && endPrice < startPrice);

  let currentBar = state.historyBars;
  const revealInterval = setInterval(() => {
    currentBar++;
    if (currentBar > state.currentGameData.length) {
      clearInterval(revealInterval);
      showResult(isWin, startPrice, endPrice);
    } else {
      state.view.offset = currentBar - state.view.barsInView; // è®“å‹•ç•«è·Ÿéš¨
      draw(currentBar);
    }
  }, CONFIG.animationSpeed);
}

function showResult(isWin, startPrice, endPrice) {
  const profit = Math.abs(endPrice - startPrice) * 10 * (Math.random() * 0.5 + 0.8);
  resultTitle.textContent = isWin ? 'é æ¸¬æˆåŠŸï¼' : 'å†æ¥å†å²';
  resultTitle.className = `modal-title ${isWin ? 'win' : 'loss'}`;
  resultSubtitle.textContent = `${isWin ? 'ç²åˆ©' : 'è™§æ'} ${isWin ? '+' : '-'}$${profit.toFixed(2)}`;
  resultModal.classList.add('visible');
}

// ===== ç¹ªåœ– =====
function draw(visibleBars = state.historyBars) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  ctx.clearRect(0, 0, W, H);
  
  const startIdx = Math.floor(state.view.offset);
  const endIdx = startIdx + Math.floor(state.view.barsInView);
  const dataInView = state.currentGameData.slice(Math.max(0, startIdx), Math.min(state.currentGameData.length, endIdx));
  if (dataInView.length === 0) return;

  const hi = Math.max(...dataInView.map(b => b.h));
  const lo = Math.min(...dataInView.map(b => b.l));
  const pad = (hi - lo) * 0.15 || 5;
  const yMax = hi + pad, yMin = lo - pad;
  const barWidth = W / state.view.barsInView;
  const y = v => H - ((v - yMin) / (yMax - yMin) * H);

  // ç¹ªè£½æ—¥æœŸåˆ†éš”ç·šå’Œæ™‚é–“æ¨™ç±¤
  document.querySelectorAll('.time-axis-label').forEach(el => el.remove());
  let lastDateStr = '';
  for (let i = startIdx; i < endIdx; i++) {
    if (i < 0 || i >= state.currentGameData.length) continue;
    const bar = state.currentGameData[i];
    const currentDateStr = bar.date.toISOString().slice(0, 10);
    if (i > 0 && currentDateStr !== lastDateStr) {
      const x = (i - startIdx) * barWidth;
      ctx.strokeStyle = 'rgba(138, 147, 176, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      ctx.setLineDash([]);
      
      const label = document.createElement('div');
      label.className = 'time-axis-label';
      label.textContent = currentDateStr.slice(5);
      label.style.left = `${x}px`;
      el('chartWrap').appendChild(label);
    }
    lastDateStr = currentDateStr;
  }

  // ç¹ªè£½ K æ£’
  for (let i = 0; i < dataInView.length; i++) {
    const b = dataInView[i];
    const x = i * barWidth + barWidth / 2;
    const up = b.c >= b.o;
    ctx.strokeStyle = up ? 'var(--good)' : 'var(--danger)';
    ctx.fillStyle = up ? 'rgba(40, 199, 130, 0.3)' : 'rgba(255, 95, 109, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x, y(b.h)); ctx.lineTo(x, y(b.l)); ctx.stroke();
    const w = Math.max(2, barWidth * 0.7);
    const y1 = y(b.o), y2 = y(b.c);
    ctx.fillRect(x - w / 2, Math.min(y1, y2), w, Math.max(1, Math.abs(y1 - y2)));
  }

  // ç¹ªè£½æ±ºç­–ç·šå’Œåƒ¹æ ¼æ¨™ç±¤
  document.querySelectorAll('.decision-line, .price-tag').forEach(el => el.remove());
  const decisionBarIndex = state.historyBars - 1;
  if (decisionBarIndex >= startIdx && decisionBarIndex < endIdx) {
      const decisionLineX = (decisionBarIndex - startIdx) * barWidth;
      const line = document.createElement('div');
      line.className = 'decision-line';
      line.style.left = `${decisionLineX}px`;
      chartWrap.appendChild(line);
      
      const startPrice = state.currentGameData[decisionBarIndex].c;
      const startTag = document.createElement('div');
      startTag.className = 'price-tag';
      startTag.textContent = startPrice.toFixed(2);
      startTag.style.left = `${decisionLineX + 5}px`;
      startTag.style.top = `${y(startPrice)}px`;
      startTag.style.background = 'var(--accent)';
      chartWrap.appendChild(startTag);
  }
  
  if (visibleBars > state.historyBars) {
      const lastBarIndex = visibleBars - 1;
      if (lastBarIndex >= startIdx && lastBarIndex < endIdx) {
          const endPrice = state.currentGameData[lastBarIndex].c;
          const endTag = document.createElement('div');
          endTag.className = 'price-tag';
          endTag.textContent = endPrice.toFixed(2);
          endTag.style.left = `${(lastBarIndex - startIdx) * barWidth + 5}px`;
          endTag.style.top = `${y(endPrice)}px`;
          endTag.style.background = endPrice >= state.currentGameData[decisionBarIndex].c ? 'var(--good)' : 'var(--danger)';
          chartWrap.appendChild(endTag);
      }
  }
}

// ===== äº’å‹•æ§åˆ¶ =====
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 
        ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5)
        : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    
    clampOffset();
    draw();
}

function clampOffset() {
    state.view.offset = Math.max(0, Math.min(state.view.offset, state.currentGameData.length - state.view.barsInView));
}

function setupInteraction() {
    // Zoom buttons
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);

    // Mouse wheel zoom
    chartWrap.addEventListener('wheel', e => {
        e.preventDefault();
        handleZoom(e.deltaY < 0 ? 1 : -1);
    }, { passive: false });

    // Panning
    const startPan = (x) => {
        if (state.isRevealing) return;
        state.pan.isPanning = true;
        state.pan.startX = x;
        state.pan.startOffset = state.view.offset;
    };
    const movePan = (x) => {
        if (!state.pan.isPanning) return;
        const dx = x - state.pan.startX;
        const barWidth = chartWrap.clientWidth / state.view.barsInView;
        state.view.offset = state.pan.startOffset - dx / barWidth;
        clampOffset();
        draw();
    };
    const endPan = () => {
        state.pan.isPanning = false;
    };

    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);

    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}

// ===== åˆå§‹åŒ– =====
async function init() {
  await loadData();
  
  buyBtn.addEventListener('click', () => handleChoice('buy'));
  sellBtn.addEventListener('click', () => handleChoice('sell'));
  btnRetry.addEventListener('click', startGame);
  btnCta.addEventListener('click', () => window.open('https://example.com', '_blank'));

  setupInteraction();
  new ResizeObserver(() => draw()).observe(chartWrap);

  startGame();
}

init();

</script>
</body>
</html>
ï¿½
