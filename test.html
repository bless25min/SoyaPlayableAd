<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>情境式交易模擬器</title>
<style>
:root {
  --bg: #1a1e2b;
  --panel: #2a2f42;
  --panel-soft: #242838;
  --text: #eef3ff;
  --muted: #8a93b0;
  --border-color: #4b5169;
  --accent: #4a72ff;
  --good: #28c782;
  --danger: #ff5f6d;
  --grid: rgba(75, 81, 105, 0.5);
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: var(--bg);
  color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
  background-color: var(--panel);
}

/* --- 頂部資訊 --- */
.header {
  text-align: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}
.header h1 { margin: 0; font-size: 18px; color: var(--accent); }
.header p { margin: 4px 0 0; color: var(--muted); font-size: 13px; line-height: 1.4; }

/* --- 圖表區 --- */
#chartWrap {
  flex-grow: 1;
  position: relative;
  background: var(--panel-soft);
  min-height: 0;
  cursor: grab;
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }
.decision-line {
  position: absolute;
  top: 0;
  bottom: 0;
  border-left: 2px dashed var(--accent);
  pointer-events: none;
  opacity: 0.7;
}
.price-tag {
  position: absolute;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  color: white;
  transform: translateY(-50%);
  pointer-events: none;
  backdrop-filter: blur(2px);
}
.time-axis-label {
    position: absolute;
    bottom: 8px;
    color: var(--muted);
    font-size: 12px;
    transform: translateX(-50%);
}
.zoom-controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
}
.zoom-btn {
    width: 32px;
    height: 32px;
    background: rgba(42, 47, 66, 0.8);
    border: 1px solid var(--border-color);
    color: var(--text);
    border-radius: 8px;
    font-size: 20px;
    cursor: pointer;
}

/* --- 底部操作區 --- */
.actions-panel {
  flex-shrink: 0;
  padding: 16px;
  background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.main-actions {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
.main-actions .btn {
  padding: 16px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  transition: transform 0.1s ease;
}
.btn.buy { background: var(--good); color: white; }
.btn.sell { background: var(--danger); color: white; }
.btn:active { transform: scale(0.97); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }

/* --- 結果彈窗 --- */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.7);
  backdrop-filter: blur(4px); z-index: 9997;
  display: flex; justify-content: center; align-items: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: min(90vw, 320px); background: var(--panel);
  border: 1px solid var(--border-color); border-radius: 16px;
  padding: 24px; text-align: center;
  transform: scale(0.9); transition: transform 0.3s ease;
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-title { font-size: 32px; font-weight: bold; margin: 0 0 8px; }
.modal-title.win { color: var(--good); }
.modal-title.loss { color: var(--danger); }
.modal-subtitle { font-size: 16px; color: var(--muted); margin: 0 0 24px; }
.modal-content .btn { width: 100%; margin-top: 8px; }
.btn.cta { background: var(--accent); color: white; }
.btn.retry { background: var(--panel-soft); color: var(--text); }

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <h1 id="game-title">等待市場行情...</h1>
    <p id="game-subtitle">載入數據中，請稍候。</p>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div class="zoom-controls">
        <button id="zoom-in" class="zoom-btn">+</button>
        <button id="zoom-out" class="zoom-btn">-</button>
    </div>
  </div>
  <div class="actions-panel">
    <div class="main-actions">
      <button class="btn buy" id="btnBuy">買入 (看漲)</button>
      <button class="btn sell" id="btnSell">賣出 (看跌)</button>
    </div>
  </div>
</div>

<div id="resultModal" class="modal-overlay">
  <div class="modal-content">
    <h2 id="result-title" class="modal-title"></h2>
    <p id="result-subtitle" class="modal-subtitle"></p>
    <button class="btn cta" id="btnCta">探索完整功能</button>
    <button class="btn retry" id="btnRetry">再玩一次</button>
  </div>
</div>

<script>
// ===== 財經事件數據與描述 =====
const EVENTS = {
  "2025-01-03": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-01-15": { time: "21:30", text: "🇺🇸 美國消費者物價指數 (CPI)", type: "CPI" },
  "2025-01-29": { time: "03:00", text: "🇺🇸 聯準會利率決議 (FOMC)", type: "FOMC" },
  "2025-02-07": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-03-07": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-03-19": { time: "03:00", text: "🇺🇸 聯準會利率決議 (FOMC)", type: "FOMC" },
  "2025-04-04": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-05-01": { time: "03:00", text: "🇺🇸 聯準會利率決議 (FOMC)", type: "FOMC" },
  "2025-05-02": { time: "21:30", text: "�🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-06-06": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
  "2025-06-19": { time: "03:00", text: "🇺🇸 聯準會利率決議 (FOMC)", type: "FOMC" },
  "2025-07-31": { time: "03:00", text: "🇺🇸 聯準會利率決議 (FOMC)", type: "FOMC" },
  "2025-08-01": { time: "21:30", text: "🇺🇸 美國非農就業數據 (NFP)", type: "NFP" },
};

const EVENT_DESCRIPTIONS = {
    "NFP": "今晚將公布俗稱「非農」的美國就業數據，這是市場最關注的指標之一。數據好壞將劇烈影響黃金價格，市場屏息以待！",
    "CPI": "通膨數據 CPI 即將出爐！這個數字將決定聯準會的下一步棋。高於預期可能導致金價下跌，反之則可能上漲。",
    "FOMC": "凌晨三點，聯準會將宣布最新的利率決策。主席鮑威爾的發言更是焦點中的焦點，任何鷹派或鴿派的暗示都可能引發市場巨震。",
    "DEFAULT": "市場正處於關鍵時刻，多空雙方激烈交戰。請根據眼前的線索，做出你的判斷！"
};

// ===== 遊戲設定 =====
const CONFIG = {
  futureBars: 30,
  animationSpeed: 60,
  minBarsInView: 20,  // 放大時最少顯示幾根 K 棒
  maxBarsInView: 200, // 縮小時最多顯示幾根 K 棒
};

// ===== 遊戲狀態與 DOM 元素 =====
const state = { 
    fullDataset: [], 
    currentGameData: [], 
    isRevealing: false,
    view: {
        barsInView: 100, // 預設顯示 100 根
        offset: 0, // 視圖偏移量 (以 K 棒為單位)
    },
    pan: {
        isPanning: false,
        startX: 0,
        startOffset: 0,
    }
};
const el = id => document.getElementById(id);
const canvas = el('chart'), ctx = canvas.getContext('2d');
const buyBtn = el('btnBuy'), sellBtn = el('btnSell');
const resultModal = el('resultModal'), resultTitle = el('result-title'), resultSubtitle = el('result-subtitle');
const btnCta = el('btnCta'), btnRetry = el('btnRetry');
const gameTitle = el('game-title'), gameSubtitle = el('game-subtitle');
const chartWrap = el('chartWrap');

// ===== 數據處理 =====
async function loadData() {
  try {
    const response = await fetch('XAUUSD_M15.csv');
    if (!response.ok) throw new Error('Network response was not ok');
    const text = await response.text();
    state.fullDataset = parseOHLC(text);
  } catch (error) {
    console.error("無法載入或解析 CSV 數據:", error);
    gameTitle.textContent = "錯誤";
    gameSubtitle.textContent = "無法載入市場數據，請刷新頁面。";
  }
}

function parseOHLC(text) {
  const lines = text.split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
  if (lines.length < 2) return [];
  return lines.slice(1).map(line => {
    const parts = line.split('\t');
    if (parts.length < 6) return null;
    const dateStr = parts[0].replace(/\./g, '-');
    const timeStr = parts[1];
    return {
      date: new Date(`${dateStr}T${timeStr}`),
      o: parseFloat(parts[2]), h: parseFloat(parts[3]),
      l: parseFloat(parts[4]), c: parseFloat(parts[5]),
    };
  }).filter(Boolean);
}

// ===== 遊戲流程 =====
function startGame() {
  if (state.fullDataset.length < 200) return; // 確保有足夠數據

  state.isRevealing = false;
  buyBtn.disabled = false;
  sellBtn.disabled = false;
  resultModal.classList.remove('visible');
  
  // 隨機選取一個決策點 (至少離數據結尾有 futureBars 的距離)
  const decisionIndex = Math.floor(Math.random() * (state.fullDataset.length - CONFIG.futureBars - 100)) + 100;
  const decisionDate = state.fullDataset[decisionIndex].date;
  
  // 找到昨天 00:00 的索引
  let yesterday = new Date(decisionDate);
  yesterday.setDate(yesterday.getDate() - 1);
  yesterday.setHours(0, 0, 0, 0);
  
  let startIndex = state.fullDataset.findIndex(bar => bar.date >= yesterday);
  if (startIndex === -1) startIndex = 0;

  state.currentGameData = state.fullDataset.slice(startIndex, decisionIndex + CONFIG.futureBars);
  state.historyBars = decisionIndex - startIndex;

  // 重置視圖
  state.view.barsInView = 100;
  state.view.offset = state.historyBars - state.view.barsInView; // 讓決策線在最右邊

  // 設置事件情境
  let eventFound = false;
  for (let i = state.historyBars; i < state.currentGameData.length; i++) {
      const bar = state.currentGameData[i];
      const dateStr = bar.date.toISOString().slice(0, 10);
      if (EVENTS[dateStr]) {
          gameTitle.textContent = EVENTS[dateStr].text;
          gameSubtitle.textContent = EVENT_DESCRIPTIONS[EVENTS[dateStr].type] || EVENT_DESCRIPTIONS.DEFAULT;
          eventFound = true;
          break;
      }
  }
  if (!eventFound) {
      gameTitle.textContent = "關鍵的抉擇時刻";
      gameSubtitle.textContent = EVENT_DESCRIPTIONS.DEFAULT;
  }

  draw();
}

function handleChoice(choice) {
  if (state.isRevealing) return;
  state.isRevealing = true;
  buyBtn.disabled = true;
  sellBtn.disabled = true;
  gameTitle.textContent = "揭曉結果...";

  const startPrice = state.currentGameData[state.historyBars - 1].c;
  const endPrice = state.currentGameData[state.currentGameData.length - 1].c;
  const isWin = (choice === 'buy' && endPrice >= startPrice) || (choice === 'sell' && endPrice < startPrice);

  let currentBar = state.historyBars;
  const revealInterval = setInterval(() => {
    currentBar++;
    if (currentBar > state.currentGameData.length) {
      clearInterval(revealInterval);
      showResult(isWin, startPrice, endPrice);
    } else {
      state.view.offset = currentBar - state.view.barsInView; // 讓動畫跟隨
      draw(currentBar);
    }
  }, CONFIG.animationSpeed);
}

function showResult(isWin, startPrice, endPrice) {
  const profit = Math.abs(endPrice - startPrice) * 10 * (Math.random() * 0.5 + 0.8);
  resultTitle.textContent = isWin ? '預測成功！' : '再接再厲';
  resultTitle.className = `modal-title ${isWin ? 'win' : 'loss'}`;
  resultSubtitle.textContent = `${isWin ? '獲利' : '虧損'} ${isWin ? '+' : '-'}$${profit.toFixed(2)}`;
  resultModal.classList.add('visible');
}

// ===== 繪圖 =====
function draw(visibleBars = state.historyBars) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  ctx.clearRect(0, 0, W, H);
  
  const startIdx = Math.floor(state.view.offset);
  const endIdx = startIdx + Math.floor(state.view.barsInView);
  const dataInView = state.currentGameData.slice(Math.max(0, startIdx), Math.min(state.currentGameData.length, endIdx));
  if (dataInView.length === 0) return;

  const hi = Math.max(...dataInView.map(b => b.h));
  const lo = Math.min(...dataInView.map(b => b.l));
  const pad = (hi - lo) * 0.15 || 5;
  const yMax = hi + pad, yMin = lo - pad;
  const barWidth = W / state.view.barsInView;
  const y = v => H - ((v - yMin) / (yMax - yMin) * H);

  // 繪製日期分隔線和時間標籤
  document.querySelectorAll('.time-axis-label').forEach(el => el.remove());
  let lastDateStr = '';
  for (let i = startIdx; i < endIdx; i++) {
    if (i < 0 || i >= state.currentGameData.length) continue;
    const bar = state.currentGameData[i];
    const currentDateStr = bar.date.toISOString().slice(0, 10);
    if (i > 0 && currentDateStr !== lastDateStr) {
      const x = (i - startIdx) * barWidth;
      ctx.strokeStyle = 'rgba(138, 147, 176, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      ctx.setLineDash([]);
      
      const label = document.createElement('div');
      label.className = 'time-axis-label';
      label.textContent = currentDateStr.slice(5);
      label.style.left = `${x}px`;
      el('chartWrap').appendChild(label);
    }
    lastDateStr = currentDateStr;
  }

  // 繪製 K 棒
  for (let i = 0; i < dataInView.length; i++) {
    const b = dataInView[i];
    const x = i * barWidth + barWidth / 2;
    const up = b.c >= b.o;
    ctx.strokeStyle = up ? 'var(--good)' : 'var(--danger)';
    ctx.fillStyle = up ? 'rgba(40, 199, 130, 0.3)' : 'rgba(255, 95, 109, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x, y(b.h)); ctx.lineTo(x, y(b.l)); ctx.stroke();
    const w = Math.max(2, barWidth * 0.7);
    const y1 = y(b.o), y2 = y(b.c);
    ctx.fillRect(x - w / 2, Math.min(y1, y2), w, Math.max(1, Math.abs(y1 - y2)));
  }

  // 繪製決策線和價格標籤
  document.querySelectorAll('.decision-line, .price-tag').forEach(el => el.remove());
  const decisionBarIndex = state.historyBars - 1;
  if (decisionBarIndex >= startIdx && decisionBarIndex < endIdx) {
      const decisionLineX = (decisionBarIndex - startIdx) * barWidth;
      const line = document.createElement('div');
      line.className = 'decision-line';
      line.style.left = `${decisionLineX}px`;
      chartWrap.appendChild(line);
      
      const startPrice = state.currentGameData[decisionBarIndex].c;
      const startTag = document.createElement('div');
      startTag.className = 'price-tag';
      startTag.textContent = startPrice.toFixed(2);
      startTag.style.left = `${decisionLineX + 5}px`;
      startTag.style.top = `${y(startPrice)}px`;
      startTag.style.background = 'var(--accent)';
      chartWrap.appendChild(startTag);
  }
  
  if (visibleBars > state.historyBars) {
      const lastBarIndex = visibleBars - 1;
      if (lastBarIndex >= startIdx && lastBarIndex < endIdx) {
          const endPrice = state.currentGameData[lastBarIndex].c;
          const endTag = document.createElement('div');
          endTag.className = 'price-tag';
          endTag.textContent = endPrice.toFixed(2);
          endTag.style.left = `${(lastBarIndex - startIdx) * barWidth + 5}px`;
          endTag.style.top = `${y(endPrice)}px`;
          endTag.style.background = endPrice >= state.currentGameData[decisionBarIndex].c ? 'var(--good)' : 'var(--danger)';
          chartWrap.appendChild(endTag);
      }
  }
}

// ===== 互動控制 =====
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 
        ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5)
        : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    
    clampOffset();
    draw();
}

function clampOffset() {
    state.view.offset = Math.max(0, Math.min(state.view.offset, state.currentGameData.length - state.view.barsInView));
}

function setupInteraction() {
    // Zoom buttons
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);

    // Mouse wheel zoom
    chartWrap.addEventListener('wheel', e => {
        e.preventDefault();
        handleZoom(e.deltaY < 0 ? 1 : -1);
    }, { passive: false });

    // Panning
    const startPan = (x) => {
        if (state.isRevealing) return;
        state.pan.isPanning = true;
        state.pan.startX = x;
        state.pan.startOffset = state.view.offset;
    };
    const movePan = (x) => {
        if (!state.pan.isPanning) return;
        const dx = x - state.pan.startX;
        const barWidth = chartWrap.clientWidth / state.view.barsInView;
        state.view.offset = state.pan.startOffset - dx / barWidth;
        clampOffset();
        draw();
    };
    const endPan = () => {
        state.pan.isPanning = false;
    };

    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);

    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}

// ===== 初始化 =====
async function init() {
  await loadData();
  
  buyBtn.addEventListener('click', () => handleChoice('buy'));
  sellBtn.addEventListener('click', () => handleChoice('sell'));
  btnRetry.addEventListener('click', startGame);
  btnCta.addEventListener('click', () => window.open('https://example.com', '_blank'));

  setupInteraction();
  new ResizeObserver(() => draw()).observe(chartWrap);

  startGame();
}

init();

</script>
</body>
</html>
�
