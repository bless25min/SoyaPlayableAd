<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>äº¤æ˜“ç²åˆ©æŒ‘æˆ°è³½</title>
<style>
:root {
  --bg: #f4f7fc;
  --panel: #ffffff;
  --panel-soft: #f9fafc;
  --text: #1a1e2b;
  --muted: #6b7280;
  --border-color: #e5e7eb;
  --accent: #4a72ff;
  --good: #10b981;
  --danger: #ef4444;
  --grid: rgba(0, 0, 0, 0.05);
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0; padding: 0; height: 100%; width: 100%;
  overflow: hidden; background-color: var(--bg); color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex; flex-direction: column; height: 100%; width: 100%;
  max-width: 420px; margin: 0 auto; background-color: var(--panel);
  box-shadow: 0 0 20px rgba(0,0,0,0.05);
}

/* --- é ‚éƒ¨è³‡è¨Š --- */
.header {
  padding: 8px 16px; border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; text-align: center;
}
.header .stats { display: flex; justify-content: space-around; font-size: 14px; }
.header .stats div { display: flex; flex-direction: column; }
.header .stats .label { font-size: 12px; color: var(--muted); }
.header .stats .value { font-weight: bold; }
.header .pnl-up { color: var(--good); }
.header .pnl-down { color: var(--danger); }
.progress-bar { width: 100%; height: 4px; background: var(--border-color); border-radius: 2px; margin-top: 8px; overflow: hidden; }
.progress-bar-inner { width: 0%; height: 100%; background: var(--accent); transition: width 0.2s linear; }

/* --- åœ–è¡¨å€ --- */
#chartWrap {
  flex-grow: 1; position: relative; background: var(--panel-soft);
  min-height: 0; cursor: grab;
  background: radial-gradient(ellipse at center, #f9fafc 0%, #f4f7fc 100%);
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }

.price-axis {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 60px;
    pointer-events: none;
    border-left: 1px solid var(--border-color);
}
.price-axis-tick {
    position: absolute;
    width: 100%;
    padding-right: 5px;
    font-size: 12px;
    color: var(--muted);
    transform: translateY(-50%);
    text-align: right;
}
.price-line {
    position: absolute;
    left: 0;
    right: 60px;
    height: 1px;
    pointer-events: none;
    border-top-style: dashed;
}
.price-line-label {
    position: absolute;
    right: 65px;
    padding: 2px 6px;
    font-size: 12px;
    color: white;
    border-radius: 4px;
    transform: translateY(-50%);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.pnl-tag {
    position: absolute;
    font-size: 12px;
    padding: 2px 6px;
    border-radius: 4px;
    transform: translateY(-50%);
}

/* --- åº•éƒ¨æ“ä½œå€ --- */
.actions-panel {
  flex-shrink: 0; background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.tabs { display: flex; border-bottom: 1px solid var(--border-color); }
.tab-btn {
  flex: 1; padding: 12px; background: none; border: none;
  color: var(--muted); cursor: pointer; border-bottom: 2px solid transparent;
  font-size: 14px;
}
.tab-btn.active { color: var(--text); border-bottom-color: var(--accent); font-weight: bold; }

.tab-content { display: none; padding: 12px; }
.tab-content.active { display: block; }

#trade-panel-content { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.btn { padding: 12px; font-size: 16px; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; transition: transform 0.1s ease; }
.btn.buy { background: var(--good); color: white; }
.btn.sell { background: var(--danger); color: white; }
.btn:active { transform: scale(0.97); }

.playback-controls {
    display: flex; justify-content: center; align-items: center;
    gap: 8px; padding: 8px 0;
}
.playback-controls .btn {
    background: var(--panel-soft); color: var(--text);
    border: 1px solid var(--border-color);
    padding: 8px 10px; font-size: 12px;
}
.playback-controls .btn.active { background: var(--accent); color: white; border-color: var(--accent); }

.input-group { display: flex; flex-direction: column; }
.input-group label { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
.input-group input { width: 100%; background: var(--bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; color: var(--text); font-size: 14px; }

#positions-list { max-height: 25vh; overflow-y: auto; }
.position-item { background: var(--panel-soft); padding: 10px; border-radius: 8px; margin-bottom: 8px; display: grid; grid-template-columns: 40px 1fr 1fr 70px; align-items: center; gap: 8px; }
.position-item .side-buy { color: var(--good); font-weight: bold; }
.position-item .side-sell { color: var(--danger); font-weight: bold; }
.position-item .pnl-up { color: var(--good); }
.position-item .pnl-down { color: var(--danger); }
.position-item .close-btn { padding: 6px; font-size: 12px; background: var(--border-color); }

/* --- å½ˆçª— --- */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.5);
  backdrop-filter: blur(4px); z-index: 9997;
  display: flex; justify-content: center; align-items: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: min(90vw, 380px); background: var(--panel);
  border: 1px solid var(--border-color); border-radius: 16px;
  padding: 24px; text-align: center;
  transform: scale(0.9); transition: transform 0.3s ease;
  box-shadow: 0 10px 30px rgba(0,0,0,0.1);
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-header { font-weight: bold; margin-bottom: 16px; font-size: 20px; }
.modal-body .input-group { margin-bottom: 12px; text-align: left; }
.modal-footer { margin-top: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;}
.modal-footer .btn { width: 100%; }
.btn.cancel { background-color: var(--border-color); color: var(--muted); }

.event-modal-icon { font-size: 48px; margin-bottom: 12px; }
.event-modal-desc { color: var(--muted); margin-bottom: 20px; text-align: left; line-height: 1.6; }

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <div class="stats">
        <div><span class="label">æ¨¡æ“¬æ—¥æœŸ</span><span class="value" id="current-date">--</span></div>
        <div><span class="label">å¸³æˆ¶æ·¨å€¼</span><span class="value" id="equity">$10000.00</span></div>
        <div><span class="label">ç¸½æç›Š</span><span class="value" id="total-pnl">$0.00</span></div>
    </div>
    <div class="progress-bar"><div id="progress-bar-inner" class="progress-bar-inner"></div></div>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div id="price-lines-container"></div>
    <div class="price-axis" id="price-axis"></div>
  </div>
  <div class="actions-panel">
    <div class="tabs">
        <button class="tab-btn active" data-tab="trade-panel">äº¤æ˜“</button>
        <button class="tab-btn" data-tab="positions-panel">æŒå€‰</button>
        <button class="tab-btn" data-tab="journal-panel">ç´€éŒ„</button>
    </div>
    <div id="trade-panel" class="tab-content active">
        <div id="trade-panel-content">
            <button class="btn sell" id="btnSell">å¸‚åƒ¹è³£å‡º</button>
            <button class="btn buy" id="btnBuy">å¸‚åƒ¹è²·å…¥</button>
        </div>
    </div>
    <div id="positions-panel" class="tab-content">
        <div id="positions-list"></div>
    </div>
    <div id="journal-panel" class="tab-content">
        <div id="journal-list" style="max-height: 25vh; overflow-y: auto;"></div>
    </div>
    <div class="playback-controls">
        <button class="btn" id="play-pause-btn">â–¶</button>
        <button class="btn" id="step-btn">é€K â†’</button>
        <div id="speed-controls">
            <button class="btn speed-btn active" data-speed="400">0.25x</button>
            <button class="btn speed-btn" data-speed="200">0.5x</button>
            <button class="btn speed-btn" data-speed="100">1x</button>
            <button class="btn speed-btn" data-speed="50">2x</button>
            <button class="btn speed-btn" data-speed="10">5x</button>
        </div>
        <button class="btn" id="zoom-out">-</button>
        <button class="btn" id="zoom-in">+</button>
    </div>
  </div>
</div>

<!-- ä¸‹å–® Modal -->
<div id="orderModal" class="modal-overlay">
    <div class="modal-content">
      <h2 class="modal-header" id="order-title">å»ºç«‹è¨‚å–®</h2>
      <div class="modal-body">
        <div class="input-group">
            <label for="order-lots">æ‰‹æ•¸</label>
            <input id="order-lots" type="number" value="0.1" step="0.01" min="0.01">
        </div>
        <div class="input-group">
            <label for="order-sl">åœæåƒ¹ (å¯é¸)</label>
            <input id="order-sl" type="number" placeholder="ä¾‹å¦‚: 2300.50">
        </div>
        <div class="input-group">
            <label for="order-tp">åœåˆ©åƒ¹ (å¯é¸)</label>
            <input id="order-tp" type="number" placeholder="ä¾‹å¦‚: 2350.50">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn cancel" id="cancelOrderBtn">å–æ¶ˆ</button>
        <button class="btn" id="confirmOrderBtn">ç¢ºèª</button>
      </div>
    </div>
</div>


<!-- äº‹ä»¶ Modal -->
<div id="eventModal" class="modal-overlay">
    <div class="modal-content event-modal-content">
      <div class="event-modal-icon">ğŸ“°</div>
      <h2 class="modal-header" id="event-title"></h2>
      <p class="event-modal-desc" id="event-desc"></p>
      <button class="btn" id="event-continue-btn">ç¹¼çºŒ</button>
    </div>
</div>

<script>
// ===== è²¡ç¶“äº‹ä»¶æ•¸æ“š (çœç•¥) =====
const EVENTS = {
  "2025-01-03": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "ä¿—ç¨±ã€Œéè¾²ã€çš„ç¾åœ‹å°±æ¥­æ•¸æ“šæ˜¯å¸‚å ´æœ€é—œæ³¨çš„æŒ‡æ¨™ä¹‹ä¸€ã€‚æ•¸æ“šå¥½å£å°‡åŠ‡çƒˆå½±éŸ¿é»ƒé‡‘åƒ¹æ ¼ï¼Œå¸‚å ´å±æ¯ä»¥å¾…ï¼" },
  "2025-01-20": { time: "12:00", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹ç¸½çµ±å°±è·å…¸ç¦®", desc: "æ–°ä»»ç¾åœ‹ç¸½çµ±å°‡æ–¼è¯ç››é “ç‰¹å€å®£èª“å°±è·ã€‚å°±è·æ¼”èªªé€šå¸¸æœƒæ¦‚è¿°æ–°æ”¿åºœçš„æ–½æ”¿è—åœ–ï¼Œå…§å®¹å¯èƒ½æ¶‰åŠåœ‹å…§å¤–æ”¿ç­–ã€ç¶“æ¿Ÿæ–¹å‘ç­‰ï¼Œé€™äº›éƒ½å¯èƒ½æˆç‚ºå¸‚å ´é—œæ³¨çš„ç„¦é»ã€‚" },
  "2025-01-30": { time: "20:45", title: "ğŸ‡ªğŸ‡º æ­æ´²å¤®è¡Œ (ECB) åˆ©ç‡æ±ºç­–æœƒè­°", desc: "æ­æ´²å¤®è¡Œç®¡ç†å§”å“¡æœƒå°‡å¬é–‹è²¨å¹£æ”¿ç­–æœƒè­°ä¸¦ç™¼å¸ƒåˆ©ç‡æ±ºç­–è²æ˜ã€‚å¸‚å ´å°‡é—œæ³¨å…¶å°æ­å…ƒåŒºç¶“æ¿Ÿå‰æ™¯å’Œé€šè†¨è·¯å¾‘çš„æœ€æ–°è©•ä¼°ã€‚" },
  "2025-02-07": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "æœ¬æœˆéè¾²æ•¸æ“šå…¬å¸ƒï¼Œå°‡å†æ¬¡è€ƒé©—å¸‚å ´å°ç¾åœ‹ç¶“æ¿Ÿå¾©ç”¦åŠ›åº¦çš„ä¿¡å¿ƒã€‚" },
  "2025-03-05": { time: "10:00", title: "ğŸ‡¨ğŸ‡³ ä¸­åœ‹å…¨åœ‹äººæ°‘ä»£è¡¨å¤§æœƒå¹´æœƒé–‹å¹•", desc: "ä¸­åœ‹å°‡å…¬å¸ƒç•¶å¹´åº¦çš„GDPå¢é•·ç›®æ¨™ã€è²¡æ”¿é ç®—ç­‰ä¸»è¦ç¶“æ¿ŸæŒ‡æ¨™ï¼Œä¸¦é—¡è¿°ç›¸é—œæ”¿ç­–æ–¹å‘ã€‚" },
  "2025-03-07": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "é€£çºŒç¬¬ä¸‰å€‹æœˆçš„éè¾²æ•¸æ“šï¼Œå¸‚å ´å°‡å°‹æ‰¾å‹å‹•åŠ›å¸‚å ´æ˜¯å¦æŒçºŒç©©å®šçš„ç·šç´¢ã€‚" },
  "2025-03-19": { time: "03:00", title: "ğŸ‡ºğŸ‡¸ è¯æº–æœƒåˆ©ç‡æ±ºç­– (FOMC)", desc: "è¯æº–æœƒå°‡ç™¼å¸ƒåˆ©ç‡æ±ºç­–ï¼Œæœƒè­°å°‡åŒ…å«æœ€æ–°çš„ç¶“æ¿Ÿé æ¸¬æ‘˜è¦ (SEP) å’Œã€Œé»é™£åœ–ã€ï¼Œæ­ç¤ºæœªä¾†åˆ©ç‡è·¯å¾‘é æœŸã€‚" },
  "2025-04-04": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "ç¬¬äºŒå­£åº¦çš„é¦–æ¬¡éè¾²å ±å‘Šï¼Œå°‡ç‚ºå¸‚å ´å°ä¸ŠåŠå¹´çš„ç¶“æ¿Ÿé æ¸¬å®šä¸‹åŸºèª¿ã€‚" },
  "2025-04-10": { time: "20:45", title: "ğŸ‡ªğŸ‡º æ­æ´²å¤®è¡Œ (ECB) åˆ©ç‡æ±ºç­–æœƒè­°", desc: "åœ¨ç¬¬ä¸€å­£ç¶“æ¿Ÿæ•¸æ“šå…¬å¸ƒä¹‹å¾Œï¼Œå¸‚å ´å°‡é—œæ³¨æ­æ´²å¤®è¡Œæ˜¯å¦æœƒæ ¹æ“šæœ€æ–°æ•¸æ“šèª¿æ•´å…¶è²¨å¹£æ”¿ç­–ç«‹å ´ã€‚" },
  "2025-04-21": { time: "09:00", title: "IMF ã€Šä¸–ç•Œç¶“æ¿Ÿå±•æœ›ã€‹å ±å‘Š", desc: "åœ‹éš›è²¨å¹£åŸºé‡‘çµ„ç¹”å°‡æ›´æ–°å°å…¨çƒä¸»è¦ç¶“æ¿Ÿé«”çš„å¢é•·é æ¸¬ï¼Œä¸¦åˆ†æå…¨çƒé¢è‡¨çš„æ½›åœ¨é¢¨éšªã€‚" },
  "2025-05-02": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "æ˜¥å­£çš„å°±æ¥­å¸‚å ´è¡¨ç¾å¦‚ä½•ï¼Ÿæœ¬æ¬¡éè¾²æ•¸æ“šå°‡æä¾›é—œéµç­”æ¡ˆã€‚" },
  "2025-05-09": { time: "15:00", title: "ğŸ‡·ğŸ‡º ä¿„ç¾…æ–¯å‹åˆ©æ—¥é–±å…µ", desc: "ä¿„ç¾…æ–¯ç¸½çµ±é€šå¸¸æœƒç™¼è¡¨æ¼”èªªï¼Œå¸‚å ´æœƒé—œæ³¨å…¶ç™¼è¨€æ˜¯å¦åŒ…å«ä»»ä½•æ–°çš„åœ°ç·£æ”¿æ²»ä¿¡è™Ÿã€‚" },
  "2025-06-06": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "å¤å­£å‰çš„æœ€å¾Œä¸€æ¬¡é‡è¦å°±æ¥­å ±å‘Šï¼Œå¯èƒ½å½±éŸ¿è¯æº–æœƒä¸‹åŠå¹´çš„æ”¿ç­–é æœŸã€‚" },
  "2025-06-13": { time: "14:00", title: "G7 é ˜è¢–å³°æœƒé–‹å¹•", desc: "ä¸ƒåœ‹é›†åœ˜å³°æœƒåœ¨åŠ æ‹¿å¤§èˆ‰è¡Œï¼Œæœƒè­°è­°ç¨‹æ¶µè“‹å…¨çƒç¶“æ¿Ÿã€æ°£å€™è®Šé·ã€åœ°ç·£æ”¿æ²»ç­‰å¤šé …è­°é¡Œã€‚" },
  "2025-07-01": { time: "10:00", title: "ğŸ‡¨ğŸ‡³ ä¸­åœ‹å…±ç”¢é»¨æˆç«‹é€±å¹´ç´€å¿µæ—¥", desc: "ç›¸é—œæ´»å‹•å’Œè²æ˜å¯èƒ½æœƒå‚³é”é—œæ–¼ä¸­åœ‹æœªä¾†ç™¼å±•æ–¹å‘çš„ä¿¡è™Ÿã€‚" },
  "2025-07-03": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "å› 7æœˆ4æ—¥ç‚ºç¾åœ‹ç¨ç«‹æ—¥å‡æœŸï¼Œæœ¬æœˆéè¾²æ•¸æ“šæå‰è‡³é€±å››å…¬å¸ƒã€‚" },
  "2025-07-30": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹ç¬¬äºŒå­£GDPåˆå€¼", desc: "è©²æ•¸æ“šæ˜¯è¡¡é‡ç¾åœ‹ç¶“æ¿Ÿå¥åº·ç‹€æ³çš„é‡è¦æŒ‡æ¨™ï¼Œå°‡æä¾›å°ç¬¬äºŒå­£åº¦ç¶“æ¿Ÿæ´»å‹•çš„åˆæ­¥è©•ä¼°ã€‚" },
  "2025-08-01": { time: "21:30", title: "ğŸ‡ºğŸ‡¸ ç¾åœ‹éè¾²å°±æ¥­æ•¸æ“š (NFP)", desc: "å…«æœˆçš„éè¾²å ±å‘Šï¼Œå°‡ç‚ºå¤æœ«çš„å¸‚å ´æƒ…ç·’å®šèª¿ã€‚" },
  "2025-08-15": { time: "12:00", title: "ğŸ‡®ğŸ‡³ å°åº¦ç¨ç«‹ç´€å¿µæ—¥", desc: "å°åº¦ç¸½ç†å°‡ç™¼è¡¨æ¼”èªªï¼Œé—¡è¿°æœªä¾†æ”¿åºœçš„æ–½æ”¿é‡é»ï¼Œå°¤å…¶æ˜¯åœ¨ç¶“æ¿Ÿç™¼å±•å’Œå¤–äº¤æ”¿ç­–æ–¹é¢ã€‚" }
};

// ===== éŠæˆ²è¨­å®š =====
const CONFIG = {
  gameDurationMonths: 1,
  minBarsInView: 20,
  maxBarsInView: 200,
  initialBalance: 10000,
};

// ===== éŠæˆ²ç‹€æ…‹èˆ‡ DOM å…ƒç´  =====
let state = {};
const el = id => document.getElementById(id);
let canvas, ctx, chartWrap;

// ===== æ•¸æ“šè™•ç† =====
function loadData() {
  return new Promise(async (resolve) => {
    try {
      // ******** FIX: Changed file path to be relative ********
      const response = await fetch('XAUUSD_M15.csv');
      if (!response.ok) throw new Error('Network response was not ok');
      const text = await response.text();
      state.fullDataset = parseOHLC(text);
      resolve(true);
    } catch (error) {
      console.error("ç„¡æ³•è¼‰å…¥æˆ–è§£æ CSV æ•¸æ“š:", error);
      el('current-date').textContent = "æ•¸æ“šéŒ¯èª¤";
      resolve(false);
    }
  });
}

function parseOHLC(text) {
  const lines = text.split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
  if (lines.length < 2) return [];
  return lines.slice(1).map(line => {
    const parts = line.split('\t');
    if (parts.length < 6) return null;
    const dateStr = parts[0].replace(/\./g, '-');
    const timeStr = parts[1];
    return {
      date: new Date(`${dateStr}T${timeStr}`),
      o: parseFloat(parts[2]), h: parseFloat(parts[3]),
      l: parseFloat(parts[4]), c: parseFloat(parts[5]),
    };
  }).filter(Boolean);
}

// ===== éŠæˆ²æµç¨‹ =====
function startGame() {
  if (!state.fullDataset || state.fullDataset.length < 200) {
      // Do not use alert, as it might be blocked. Log to console instead.
      console.error("å¸‚å ´æ•¸æ“šä¸è¶³æˆ–è¼‰å…¥å¤±æ•—ï¼Œç„¡æ³•é–‹å§‹éŠæˆ²ã€‚");
      el('current-date').textContent = "æ•¸æ“šéŒ¯èª¤";
      return;
  }
  
  state.gameData = [];
  state.currentBarIndex = 0;
  state.positions = [];
  state.journal = [];
  state.account = { balance: CONFIG.initialBalance, equity: CONFIG.initialBalance };
  state.isPaused = true;
  clearInterval(state.gameTimer);
  state.animationSpeed = 400; 
  document.querySelector('.speed-btn.active').classList.remove('active');
  document.querySelector('.speed-btn[data-speed="400"]').classList.add('active');

  state.view = { barsInView: 100, offset: 0 };
  state.pan = { isPanning: false, startX: 0, startOffset: 0 };
  state.barAnimation = { progress: 1, isAnimating: false };

  const minStartDate = new Date('2025-01-01T00:00:00');
  const maxStartDate = new Date('2025-07-15T00:00:00');
  
  const minStartIndex = state.fullDataset.findIndex(b => b.date >= minStartDate);
  const maxStartIndex = state.fullDataset.findIndex(b => b.date >= maxStartDate);
  
  if (minStartIndex === -1 || maxStartIndex === -1) {
      console.error("åœ¨æ•¸æ“šé›†ä¸­æ‰¾ä¸åˆ°æŒ‡å®šçš„æ—¥æœŸç¯„åœ");
      return;
  }

  const randomStartIndex = Math.floor(Math.random() * (maxStartIndex - minStartIndex + 1)) + minStartIndex;
  
  const startDate = state.fullDataset[randomStartIndex].date;
  let endDate = new Date(startDate);
  endDate.setMonth(endDate.getMonth() + CONFIG.gameDurationMonths);

  let endIndex = state.fullDataset.findIndex(b => b.date >= endDate);
  if (endIndex === -1) endIndex = state.fullDataset.length - 1;
  
  state.gameData = state.fullDataset.slice(randomStartIndex, endIndex);
  state.currentBarIndex = 0;
  state.view.offset = state.currentBarIndex - state.view.barsInView;

  updateHUD();
  updatePositionsList();
  draw();
  el('play-pause-btn').textContent = 'â–¶';
}

function gameLoop() {
    if (state.isPaused || state.barAnimation.isAnimating) return;
    
    const bar = state.gameData[state.currentBarIndex];
    if (bar) {
        const dateStr = bar.date.toISOString().slice(0, 10);
        const event = EVENTS[dateStr];
        if (event && bar.date.getUTCHours() * 60 + bar.date.getUTCMinutes() >= parseInt(event.time.split(':')[0]) * 60) {
            if (!event.triggered) {
                pauseGame();
                showEventModal(event);
                event.triggered = true;
                return;
            }
        }
    }

    state.currentBarIndex++;
    if (state.currentBarIndex >= state.gameData.length) {
        pauseGame();
        // Do not use alert. Maybe show a final modal. For now, just log.
        console.log(`æŒ‘æˆ°çµæŸï¼æœ€çµ‚æ·¨å€¼: $${state.account.equity.toFixed(2)}`);
        el('play-pause-btn').disabled = true;
        el('step-btn').disabled = true;
        return;
    }
    
    animateBar();
}

function animateBar() {
    state.barAnimation.isAnimating = true;
    let startTime = performance.now();

    function frame(currentTime) {
        const elapsedTime = currentTime - startTime;
        let progress = elapsedTime / state.animationSpeed;
        if (progress >= 1) {
            progress = 1;
            state.barAnimation.isAnimating = false;
        }
        
        updatePositions();
        updateHUD();
        if (state.view.offset + state.view.barsInView < state.currentBarIndex + 10) {
            state.view.offset = state.currentBarIndex - state.view.barsInView + 10;
        }
        draw(progress);

        if (progress < 1) {
            requestAnimationFrame(frame);
        }
    }
    requestAnimationFrame(frame);
}


function stepForward() {
    pauseGame();
    if (state.currentBarIndex < state.gameData.length - 1) {
        state.currentBarIndex++;
        updatePositions();
        updateHUD();
        if (state.view.offset + state.view.barsInView < state.currentBarIndex + 10) {
            state.view.offset = state.currentBarIndex - state.view.barsInView + 10;
        }
        draw();
    }
}

function pauseGame() {
    state.isPaused = true;
    clearInterval(state.gameTimer);
    el('play-pause-btn').textContent = 'â–¶';
}

function resumeGame() {
    state.isPaused = false;
    clearInterval(state.gameTimer);
    state.gameTimer = setInterval(gameLoop, state.animationSpeed);
    el('play-pause-btn').textContent = 'âšâš';
}

// ===== äº¤æ˜“é‚è¼¯ =====
function openOrder(side) {
    const lots = parseFloat(el('order-lots').value);
    const sl = parseFloat(el('order-sl').value) || null;
    const tp = parseFloat(el('order-tp').value) || null;
    if (!lots || lots <= 0) {
        // Simple validation, no alert
        console.error("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ‰‹æ•¸");
        return;
    }
    const currentPrice = state.gameData[state.currentBarIndex].c;
    
    state.positions.push({ id: Date.now(), side, entryPrice: currentPrice, lots, sl, tp, pnl: 0 });
    updatePositionsList();
    draw();
}
function closePosition(positionId) {
    const index = state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;
    const position = state.positions[index];
    state.account.balance += position.pnl;
    state.positions.splice(index, 1);
    updatePositionsList();
    updateHUD();
    draw();
}
function updatePositions() {
    if (!state.gameData || state.currentBarIndex >= state.gameData.length) return;
    const currentBar = state.gameData[state.currentBarIndex];
    let totalPnl = 0;
    for (let i = state.positions.length - 1; i >= 0; i--) {
        const p = state.positions[i];
        const direction = p.side === 'buy' ? 1 : -1;
        p.pnl = (currentBar.c - p.entryPrice) * direction * p.lots * 100; // å‡è¨­1æ‰‹=100å–®ä½
        totalPnl += p.pnl;
        
        const hitSL = (p.sl && ((p.side === 'buy' && currentBar.l <= p.sl) || (p.side === 'sell' && currentBar.h >= p.sl)));
        const hitTP = (p.tp && ((p.side === 'buy' && currentBar.h >= p.tp) || (p.side === 'sell' && currentBar.l <= p.tp)));
        
        if (hitSL || hitTP) {
            const exitPrice = hitSL ? p.sl : p.tp;
            const finalPnl = (exitPrice - p.entryPrice) * direction * p.lots * 100;
            state.account.balance += finalPnl;
            state.positions.splice(i, 1);
        }
    }
    state.account.equity = state.account.balance + totalPnl;
}

// ===== UI æ›´æ–° =====
function updateHUD() {
    const currentDate = state.gameData[state.currentBarIndex]?.date;
    if(currentDate) el('current-date').textContent = currentDate.toISOString().slice(0, 10);
    el('equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - state.account.balance;
    const pnlEl = el('total-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = `value ${totalPnl >= 0 ? 'pnl-up' : 'pnl-down'}`;
    const progress = (state.currentBarIndex + 1) / state.gameData.length * 100;
    el('progress-bar-inner').style.width = `${progress}%`;
}
function updatePositionsList() {
    const listEl = el('positions-list');
    if (state.positions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">ç›®å‰æ²’æœ‰æŒå€‰</p>';
        return;
    }
    listEl.innerHTML = state.positions.map(p => {
        const pnlClass = p.pnl > 0 ? 'pnl-up' : (p.pnl < 0 ? 'pnl-down' : '');
        return `<div class="position-item"><span class="side-${p.side}">${p.side === 'buy' ? 'è²·å…¥' : 'è³£å‡º'}</span><div>${p.lots} æ‰‹ @ ${p.entryPrice.toFixed(2)}</div><div class="${pnlClass}">${p.pnl.toFixed(2)}</div><button class="btn close-btn" onclick="closePosition(${p.id})">å¹³å€‰</button></div>`;
    }).join('');
}
function showEventModal(event) {
    el('event-title').textContent = event.title;
    el('event-desc').textContent = event.desc;
    el('eventModal').classList.add('visible');
}

// ===== ç¹ªåœ– =====
function draw(animationProgress = 1) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);
  if (!state.gameData || state.gameData.length === 0) return;
  const startIdx = Math.floor(state.view.offset);
  const endIdx = startIdx + Math.floor(state.view.barsInView);
  const dataInView = state.gameData.slice(Math.max(0, startIdx), Math.min(state.currentBarIndex + 1, endIdx));
  if (dataInView.length === 0) return;
  const hi = Math.max(...dataInView.map(b => b.h));
  const lo = Math.min(...dataInView.map(b => b.l));
  const pad = (hi - lo) * 0.15 || 5;
  const yMax = hi + pad, yMin = lo - pad;
  const barWidth = W / state.view.barsInView;
  const y = v => H - ((v - yMin) / (yMax - yMin) * H);
  
  // ç¹ªè£½æ—¥æœŸåˆ†éš”ç·š
  let lastDateStr = '';
  for (let i = startIdx; i < endIdx; i++) {
    if (i < 0 || i >= state.currentBarIndex + 1) continue;
    const bar = state.gameData[i];
    if (!bar) continue;
    const currentDateStr = bar.date.toISOString().slice(0, 10);
    if (i > 0 && currentDateStr !== lastDateStr) {
      const x = (i - state.view.offset) * barWidth;
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      ctx.setLineDash([]);
    }
    lastDateStr = currentDateStr;
  }

  // ç¹ªè£½ K æ£’
  for (let i = 0; i < dataInView.length; i++) {
    const barIndex = startIdx + i;
    const b = dataInView[i];
    const x = (barIndex - state.view.offset) * barWidth + barWidth / 2;
    const isLastBar = barIndex === state.currentBarIndex;
    
    const progress = isLastBar ? animationProgress : 1;
    const up = b.c >= b.o;
    const openY = y(b.o);
    let lowY = y(b.l);
    let highY = y(b.h);
    let closeY = y(b.c);

    if (isLastBar && progress < 1) {
        const wick1Target = up ? lowY : highY;
        const wick2Target = up ? highY : lowY;
        const wick1Progress = Math.max(0, Math.min(1, progress / 0.4));
        const wick2Progress = Math.max(0, Math.min(1, (progress - 0.4) / 0.4));
        const bodyProgress = Math.max(0, Math.min(1, (progress - 0.8) / 0.2));
        
        const currentWick1Y = openY + (wick1Target - openY) * wick1Progress;
        const currentWick2Y = openY + (wick2Target - openY) * wick2Progress;
        const currentCloseY = openY + (closeY - openY) * bodyProgress;

        lowY = Math.min(openY, currentWick1Y, currentWick2Y);
        highY = Math.max(openY, currentWick1Y, currentWick2Y);
        closeY = currentCloseY;
    }

    ctx.strokeStyle = up ? 'var(--good)' : 'var(--danger)';
    ctx.fillStyle = up ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x, highY); ctx.lineTo(x, lowY); ctx.stroke();
    const w = Math.max(2, barWidth * 0.7);
    ctx.fillRect(x - w / 2, Math.min(openY, closeY), w, Math.max(1, Math.abs(openY - closeY)));
  }
  
  // ç¹ªè£½æŒå€‰ç·š
  state.positions.forEach(p => {
    const entryY = y(p.entryPrice);
    ctx.strokeStyle = p.side === 'buy' ? 'var(--good)' : 'var(--danger)';
    ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.moveTo(0, entryY); ctx.lineTo(W, entryY); ctx.stroke();
    if (p.sl) { ctx.strokeStyle = 'var(--danger)'; const slY = y(p.sl); ctx.beginPath(); ctx.moveTo(0, slY); ctx.lineTo(W, slY); ctx.stroke(); }
    if (p.tp) { ctx.strokeStyle = 'var(--good)'; const tpY = y(p.tp); ctx.beginPath(); ctx.moveTo(0, tpY); ctx.lineTo(W, tpY); ctx.stroke(); }
    ctx.setLineDash([]);
  });
}

// ===== äº’å‹•æ§åˆ¶ =====
function setupInteraction() {
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);
    chartWrap.addEventListener('wheel', e => { e.preventDefault(); handleZoom(e.deltaY < 0 ? 1 : -1); }, { passive: false });
    const startPan = (x) => { state.pan.isPanning = true; state.pan.startX = x; state.pan.startOffset = state.view.offset; };
    const movePan = (x) => { if (!state.pan.isPanning) return; const dx = x - state.pan.startX; const barWidth = chartWrap.clientWidth / state.view.barsInView; state.view.offset = state.pan.startOffset - dx / barWidth; clampOffset(true); draw(); };
    const endPan = () => { state.pan.isPanning = false; };
    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);
    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5) : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    clampOffset(true);
    draw();
}
function clampOffset(isUserAction = false) {
    const maxOffset = state.currentBarIndex - (isUserAction ? state.view.barsInView : 5);
    state.view.offset = Math.max(0, Math.min(state.view.offset, maxOffset));
}


// ===== åˆå§‹åŒ– =====
async function init() {
  canvas = el('chart');
  ctx = canvas.getContext('2d');
  chartWrap = el('chartWrap');
  
  const dataLoaded = await loadData();
  
  if (dataLoaded) {
    const orderModal = el('orderModal');
    const orderTitle = el('order-title');
    const confirmOrderBtn = el('confirmOrderBtn');
    const cancelOrderBtn = el('cancelOrderBtn');

    const showOrderModal = (side) => {
        pauseGame();
        orderTitle.textContent = side === 'buy' ? 'å»ºç«‹è²·å…¥è¨‚å–®' : 'å»ºç«‹è³£å‡ºè¨‚å–®';
        confirmOrderBtn.className = `btn ${side}`;
        confirmOrderBtn.textContent = side === 'buy' ? 'ç¢ºèªè²·å…¥' : 'ç¢ºèªè³£å‡º';
        // é‡æ–°ç¶å®š onclick äº‹ä»¶ï¼Œé¿å…é‡è¤‡è§¸ç™¼
        confirmOrderBtn.onclick = () => { 
            openOrder(side); 
            orderModal.classList.remove('visible'); 
        };
        orderModal.classList.add('visible');
    };

    el('btnBuy').addEventListener('click', () => showOrderModal('buy'));
    el('btnSell').addEventListener('click', () => showOrderModal('sell'));
    cancelOrderBtn.addEventListener('click', () => orderModal.classList.remove('visible'));
    
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if(btn.dataset.tab === 'positions-panel') {
                pauseGame();
                updatePositionsList();
            }
            document.querySelector('.tab-btn.active').classList.remove('active');
            document.querySelector('.tab-content.active').classList.remove('active');
            btn.classList.add('active');
            el(btn.dataset.tab).classList.add('active');
        });
    });
    
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.remove('visible');
            }
        });
    });

    el('event-continue-btn').addEventListener('click', () => {
        el('eventModal').classList.remove('visible');
        resumeGame();
    });

    el('play-pause-btn').addEventListener('click', () => {
        state.isPaused ? resumeGame() : pauseGame();
    });
    el('step-btn').addEventListener('click', stepForward);
    el('speed-controls').addEventListener('click', (e) => {
        if (e.target.classList.contains('speed-btn')) {
            document.querySelector('.speed-btn.active').classList.remove('active');
            e.target.classList.add('active');
            state.animationSpeed = parseInt(e.target.dataset.speed);
            if (!state.isPaused) {
                resumeGame(); // ç«‹å³å¥—ç”¨æ–°é€Ÿåº¦
            }
        }
    });

    setupInteraction();
    startGame();
  }
}

document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
