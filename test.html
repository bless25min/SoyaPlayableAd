<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>äº¤æ˜“ç²åˆ©æŒ‘æˆ°è³½</title>
<style>
:root {
  --bg: #1a1e2b;
  --panel: #2a2f42;
  --panel-soft: #242838;
  --text: #eef3ff;
  --muted: #8a93b0;
  --border-color: #4b5169;
  --accent: #4a72ff;
  --good: #28c782;
  --danger: #ff5f6d;
  --grid: rgba(75, 81, 105, 0.5);
}

* { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-tap-highlight-color: transparent; }

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: var(--bg);
  color: var(--text);
  font-size: 14px;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  max-width: 420px;
  margin: 0 auto;
  background-color: var(--panel);
}

/* --- é ‚éƒ¨è³‡è¨Š --- */
.header {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
  text-align: center;
}
.header .stats { display: flex; justify-content: space-around; font-size: 14px; }
.header .stats div { display: flex; flex-direction: column; }
.header .stats .label { font-size: 12px; color: var(--muted); }
.header .stats .value { font-weight: bold; }
.header .pnl-up { color: var(--good); }
.header .pnl-down { color: var(--danger); }
.progress-bar { width: 100%; height: 4px; background: var(--panel-soft); border-radius: 2px; margin-top: 8px; overflow: hidden; }
.progress-bar-inner { width: 0%; height: 100%; background: var(--accent); transition: width 0.2s linear; }


/* --- åœ–è¡¨å€ --- */
#chartWrap {
  flex-grow: 1;
  position: relative;
  background: var(--panel-soft);
  min-height: 0;
  cursor: grab;
}
#chartWrap:active { cursor: grabbing; }
#chart { width: 100%; height: 100%; display: block; }
.price-tag {
  position: absolute;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  color: white;
  transform: translateY(-50%);
  pointer-events: none;
  backdrop-filter: blur(2px);
}
.time-axis-label {
    position: absolute;
    bottom: 8px;
    color: var(--muted);
    font-size: 12px;
    transform: translateX(-50%);
}
.zoom-controls {
    position: absolute;
    bottom: 30px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
}
.zoom-btn {
    width: 32px;
    height: 32px;
    background: rgba(42, 47, 66, 0.8);
    border: 1px solid var(--border-color);
    color: var(--text);
    border-radius: 8px;
    font-size: 20px;
    cursor: pointer;
}

/* --- åº•éƒ¨æ“ä½œå€ --- */
.actions-panel {
  flex-shrink: 0;
  padding: 12px;
  background: var(--panel);
  border-top: 1px solid var(--border-color);
}
.main-actions {
  display: grid;
  grid-template-columns: 1fr 1fr 80px;
  gap: 12px;
}
.main-actions .btn {
  padding: 14px;
  font-size: 16px;
  font-weight: bold;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  transition: transform 0.1s ease;
}
.btn.buy { background: var(--good); color: white; }
.btn.sell { background: var(--danger); color: white; }
.btn.manage { background: var(--panel-soft); color: var(--text); }
.btn:active { transform: scale(0.97); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }

/* --- å½ˆçª— --- */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.7);
  backdrop-filter: blur(4px); z-index: 9997;
  display: flex; justify-content: center; align-items: flex-end;
  opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
}
.modal-overlay.visible { opacity: 1; pointer-events: auto; }
.modal-content {
  width: 100%;
  max-width: 420px;
  background: var(--panel);
  border-top-left-radius: 16px;
  border-top-right-radius: 16px;
  padding: 16px;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}
.modal-overlay.visible .modal-content { transform: translateY(0); }
.modal-header { font-weight: bold; margin-bottom: 16px; font-size: 18px; }
.modal-body .input-group { margin-bottom: 12px; }
.input-group label { font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block; }
.input-group input { width: 100%; background: var(--panel-soft); border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; color: var(--text); font-size: 16px; }
.modal-footer .btn { width: 100%; }

#positions-list { max-height: 40vh; overflow-y: auto; }
.position-item { background: var(--panel-soft); padding: 10px; border-radius: 8px; margin-bottom: 8px; display: grid; grid-template-columns: 40px 1fr 1fr 70px; align-items: center; gap: 8px; }
.position-item .side-buy { color: var(--good); font-weight: bold; }
.position-item .side-sell { color: var(--danger); font-weight: bold; }
.position-item .pnl-up { color: var(--good); }
.position-item .pnl-down { color: var(--danger); }
.position-item .close-btn { padding: 6px; font-size: 12px; background: var(--border-color); }

</style>
</head>
<body>

<div class="app-container">
  <div class="header">
    <div class="stats">
        <div><span class="label">æ¨¡æ“¬æ—¥æœŸ</span><span class="value" id="current-date">--</span></div>
        <div><span class="label">å¸³æˆ¶æ·¨å€¼</span><span class="value" id="equity">$10000.00</span></div>
        <div><span class="label">ç¸½æç›Š</span><span class="value" id="total-pnl">$0.00</span></div>
    </div>
    <div class="progress-bar"><div id="progress-bar-inner" class="progress-bar-inner"></div></div>
  </div>
  <div id="chartWrap">
    <canvas id="chart"></canvas>
    <div class="zoom-controls">
        <button id="zoom-in" class="zoom-btn">+</button>
        <button id="zoom-out" class="zoom-btn">-</button>
    </div>
  </div>
  <div class="actions-panel">
    <div class="main-actions">
      <button class="btn buy" id="btnBuy">è²·å…¥</button>
      <button class="btn sell" id="btnSell">è³£å‡º</button>
      <button class="btn manage" id="btnManage">éƒ¨ä½</button>
    </div>
  </div>
</div>

<!-- ä¸‹å–®å½ˆçª— -->
<div id="orderModal" class="modal-overlay">
  <div class="modal-content">
    <h2 class="modal-header" id="order-title">å»ºç«‹è¨‚å–®</h2>
    <div class="modal-body">
        <div class="input-group">
            <label for="lots">æ‰‹æ•¸</label>
            <input id="lots" type="number" value="0.1" step="0.01" min="0.01">
        </div>
        <div class="input-group">
            <label for="slPrice">åœæåƒ¹ (å¯é¸)</label>
            <input id="slPrice" type="number" placeholder="ä¾‹å¦‚ 2300.50">
        </div>
        <div class="input-group">
            <label for="tpPrice">åœåˆ©åƒ¹ (å¯é¸)</label>
            <input id="tpPrice" type="number" placeholder="ä¾‹å¦‚ 2350.50">
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn" id="confirmOrderBtn">ç¢ºèª</button>
    </div>
  </div>
</div>

<!-- éƒ¨ä½ç®¡ç†å½ˆçª— -->
<div id="positionsModal" class="modal-overlay">
  <div class="modal-content">
    <h2 class="modal-header">ç›®å‰æŒå€‰</h2>
    <div class="modal-body" id="positions-list">
        <!-- æŒå€‰é …ç›®æœƒå‹•æ…‹æ’å…¥é€™è£¡ -->
    </div>
  </div>
</div>

<script>
// ===== è²¡ç¶“äº‹ä»¶æ•¸æ“š (çœç•¥ä»¥ç¯€çœç©ºé–“) =====
const EVENTS = { "2025-01-03": { time: "21:30", text: "ğŸ‡ºğŸ‡¸ NFP", type: "NFP" }, /* ... æ›´å¤šäº‹ä»¶ ... */ };
const EVENT_DESCRIPTIONS = { "NFP": "...", /* ... æ›´å¤šæè¿° ... */ };

// ===== éŠæˆ²è¨­å®š =====
const CONFIG = {
  gameDurationMonths: 1,
  animationSpeed: 10,
  minBarsInView: 20,
  maxBarsInView: 200,
  initialBalance: 10000,
};

// ===== éŠæˆ²ç‹€æ…‹èˆ‡ DOM å…ƒç´  =====
let state = {};
const el = id => document.getElementById(id);
const canvas = el('chart'), ctx = canvas.getContext('2d');
// ... (çœç•¥å…¶ä»– DOM å…ƒç´ ç²å–)

// ===== æ•¸æ“šè™•ç† =====
async function loadData() {
  try {
    const response = await fetch('XAUUSD_M15.csv');
    state.fullDataset = parseOHLC(await response.text());
  } catch (error) { console.error("æ•¸æ“šè¼‰å…¥å¤±æ•—:", error); }
}

function parseOHLC(text) {
  const lines = text.split(/\r?\n/).filter(l => l && !/^\s*$/.test(l));
  return lines.slice(1).map(line => {
    const parts = line.split('\t');
    if (parts.length < 6) return null;
    const dateStr = parts[0].replace(/\./g, '-');
    const timeStr = parts[1];
    return { date: new Date(`${dateStr}T${timeStr}`), o: parseFloat(parts[2]), h: parseFloat(parts[3]), l: parseFloat(parts[4]), c: parseFloat(parts[5]) };
  }).filter(Boolean);
}

// ===== éŠæˆ²æµç¨‹ =====
function resetState() {
    state = {
        ...state,
        gameData: [],
        startIndex: 0,
        endIndex: 0,
        currentBarIndex: 0,
        positions: [],
        account: { balance: CONFIG.initialBalance, equity: CONFIG.initialBalance },
        isPaused: true,
        gameTimer: null,
        view: { barsInView: 100, offset: 0 },
        pan: { isPanning: false, startX: 0, startOffset: 0 }
    };
}

function startGame() {
  if (state.fullDataset.length < 200) return;
  resetState();

  const latestPossibleStart = new Date('2025-07-15T00:00:00');
  const maxStartIndex = state.fullDataset.findIndex(b => b.date >= latestPossibleStart);
  const randomStartIndex = Math.floor(Math.random() * maxStartIndex);
  
  const startDate = state.fullDataset[randomStartIndex].date;
  let endDate = new Date(startDate);
  endDate.setMonth(endDate.getMonth() + CONFIG.gameDurationMonths);

  state.startIndex = randomStartIndex;
  let endIndex = state.fullDataset.findIndex(b => b.date >= endDate);
  if (endIndex === -1) endIndex = state.fullDataset.length - 1;
  state.endIndex = endIndex;
  
  state.gameData = state.fullDataset.slice(state.startIndex, state.endIndex);
  state.currentBarIndex = 0;
  state.view.offset = -20; // è®“Kæ£’å¾å·¦é‚Šä¸€é»é–‹å§‹

  updateHUD();
  draw();
  togglePlay(); // è‡ªå‹•é–‹å§‹
}

function gameLoop() {
    if (state.isPaused) return;
    state.currentBarIndex++;
    if (state.currentBarIndex >= state.gameData.length) {
        togglePlay(); // éŠæˆ²çµæŸï¼Œæš«åœ
        alert(`æŒ‘æˆ°çµæŸï¼æœ€çµ‚æ·¨å€¼: $${state.account.equity.toFixed(2)}`);
        return;
    }
    updatePositions();
    updateHUD();
    state.view.offset++; // è‡ªå‹•æ»¾å‹•
    draw();
}

function togglePlay() {
    state.isPaused = !state.isPaused;
    if (!state.isPaused) {
        state.gameTimer = setInterval(gameLoop, CONFIG.animationSpeed);
    } else {
        clearInterval(state.gameTimer);
    }
}

// ===== äº¤æ˜“é‚è¼¯ =====
function openOrder(side) {
    const lots = parseFloat(el('lots').value);
    const sl = parseFloat(el('slPrice').value) || null;
    const tp = parseFloat(el('tpPrice').value) || null;
    if (!lots || lots <= 0) return;

    const currentPrice = state.gameData[state.currentBarIndex].c;
    const entryPrice = side === 'buy' ? currentPrice + 0.1 : currentPrice - 0.1;

    state.positions.push({
        id: Date.now(),
        side,
        entryPrice,
        lots,
        sl,
        tp,
        pnl: 0,
    });
    updatePositionsList();
    draw();
}

function closePosition(positionId) {
    const index = state.positions.findIndex(p => p.id === positionId);
    if (index === -1) return;
    
    const position = state.positions[index];
    state.account.balance += position.pnl;
    state.positions.splice(index, 1);
    
    updatePositionsList();
    draw();
}

function updatePositions() {
    const currentPrice = state.gameData[state.currentBarIndex].c;
    let totalPnl = 0;

    for (let i = state.positions.length - 1; i >= 0; i--) {
        const p = state.positions[i];
        const direction = p.side === 'buy' ? 1 : -1;
        p.pnl = (currentPrice - p.entryPrice) * direction * p.lots * 100; // ç°¡åŒ–è¨ˆç®—
        totalPnl += p.pnl;

        // æª¢æŸ¥ SL/TP
        const hitSL = (p.sl && ((p.side === 'buy' && currentPrice <= p.sl) || (p.side === 'sell' && currentPrice >= p.sl)));
        const hitTP = (p.tp && ((p.side === 'buy' && currentPrice >= p.tp) || (p.side === 'sell' && currentPrice <= p.tp)));

        if (hitSL || hitTP) {
            state.account.balance += p.pnl;
            state.positions.splice(i, 1);
        }
    }
    state.account.equity = state.account.balance + totalPnl;
}

// ===== UI æ›´æ–° =====
function updateHUD() {
    const currentDate = state.gameData[state.currentBarIndex]?.date;
    if(currentDate) el('current-date').textContent = currentDate.toISOString().slice(0, 10);
    
    el('equity').textContent = `$${state.account.equity.toFixed(2)}`;
    const totalPnl = state.account.equity - state.account.balance;
    const pnlEl = el('total-pnl');
    pnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
    pnlEl.className = totalPnl >= 0 ? 'pnl-up' : 'pnl-down';

    const progress = state.currentBarIndex / state.gameData.length * 100;
    el('progress-bar-inner').style.width = `${progress}%`;
}

function updatePositionsList() {
    const listEl = el('positions-list');
    if (state.positions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--muted);">ç›®å‰æ²’æœ‰æŒå€‰</p>';
        return;
    }
    listEl.innerHTML = state.positions.map(p => {
        const pnlClass = p.pnl > 0 ? 'pnl-up' : (p.pnl < 0 ? 'pnl-down' : '');
        return `
            <div class="position-item">
                <span class="side-${p.side}">${p.side === 'buy' ? 'è²·å…¥' : 'è³£å‡º'}</span>
                <div>${p.lots} æ‰‹ @ ${p.entryPrice.toFixed(2)}</div>
                <div class="${pnlClass}">${p.pnl.toFixed(2)}</div>
                <button class="btn close-btn" onclick="closePosition(${p.id})">å¹³å€‰</button>
            </div>
        `;
    }).join('');
}


// ===== ç¹ªåœ– (èˆ‡å‰ç‰ˆé¡ä¼¼ï¼Œçœç•¥ä»¥ç¯€çœç©ºé–“) =====
function draw() { /* ... */ }

// ===== äº’å‹•æ§åˆ¶ (èˆ‡å‰ç‰ˆé¡ä¼¼ï¼Œçœç•¥ä»¥ç¯€çœç©ºé–“) =====
function setupInteraction() { /* ... */ }

// ===== åˆå§‹åŒ– =====
async function init() {
  await loadData();
  
  // ç¶å®šä¸»æŒ‰éˆ•
  el('btnBuy').addEventListener('click', () => {
      el('order-title').textContent = 'å»ºç«‹è²·å…¥è¨‚å–®';
      el('confirmOrderBtn').className = 'btn buy';
      el('confirmOrderBtn').onclick = () => { openOrder('buy'); el('orderModal').classList.remove('visible'); };
      el('orderModal').classList.add('visible');
  });
  el('btnSell').addEventListener('click', () => {
      el('order-title').textContent = 'å»ºç«‹è³£å‡ºè¨‚å–®';
      el('confirmOrderBtn').className = 'btn sell';
      el('confirmOrderBtn').onclick = () => { openOrder('sell'); el('orderModal').classList.remove('visible'); };
      el('orderModal').classList.add('visible');
  });
  el('btnManage').addEventListener('click', () => {
      updatePositionsList();
      el('positionsModal').classList.add('visible');
  });

  // é—œé–‰å½ˆçª—
  document.querySelectorAll('.modal-overlay').forEach(modal => {
      modal.addEventListener('click', (e) => {
          if (e.target === modal) {
              modal.classList.remove('visible');
          }
      });
  });

  setupInteraction();
  new ResizeObserver(draw).observe(chartWrap);
  startGame();
}

init();

// ç‚ºäº†è®“ç¨‹å¼ç¢¼èƒ½åŸ·è¡Œï¼Œè£œä¸Šçœç•¥çš„å‡½æ•¸
function draw() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);
  
  const startIdx = Math.floor(state.view.offset);
  const endIdx = startIdx + Math.floor(state.view.barsInView);
  const dataInView = state.gameData.slice(Math.max(0, startIdx), Math.min(state.currentBarIndex + 1, endIdx));
  if (dataInView.length === 0) return;

  const hi = Math.max(...dataInView.map(b => b.h));
  const lo = Math.min(...dataInView.map(b => b.l));
  const pad = (hi - lo) * 0.15 || 5;
  const yMax = hi + pad, yMin = lo - pad;
  const barWidth = W / state.view.barsInView;
  const y = v => H - ((v - yMin) / (yMax - yMin) * H);

  // ç¹ªè£½ K æ£’
  for (let i = 0; i < dataInView.length; i++) {
    const b = dataInView[i];
    const x = (startIdx + i - state.view.offset) * barWidth + barWidth / 2;
    const up = b.c >= b.o;
    ctx.strokeStyle = up ? 'var(--good)' : 'var(--danger)';
    ctx.fillStyle = up ? 'rgba(40, 199, 130, 0.3)' : 'rgba(255, 95, 109, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x, y(b.h)); ctx.lineTo(x, y(b.l)); ctx.stroke();
    const w = Math.max(2, barWidth * 0.7);
    const y1 = y(b.o), y2 = y(b.c);
    ctx.fillRect(x - w / 2, Math.min(y1, y2), w, Math.max(1, Math.abs(y1 - y2)));
  }
  
  // ç¹ªè£½æŒå€‰ç·šã€SL/TP ç·š
  state.positions.forEach(p => {
    const entryY = y(p.entryPrice);
    ctx.strokeStyle = p.side === 'buy' ? 'var(--good)' : 'var(--danger)';
    ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.moveTo(0, entryY); ctx.lineTo(W, entryY); ctx.stroke();
    if (p.sl) {
        ctx.strokeStyle = 'var(--danger)';
        const slY = y(p.sl);
        ctx.beginPath(); ctx.moveTo(0, slY); ctx.lineTo(W, slY); ctx.stroke();
    }
    if (p.tp) {
        ctx.strokeStyle = 'var(--good)';
        const tpY = y(p.tp);
        ctx.beginPath(); ctx.moveTo(0, tpY); ctx.lineTo(W, tpY); ctx.stroke();
    }
    ctx.setLineDash([]);
  });
}

function setupInteraction() {
    el('zoom-in').onclick = () => handleZoom(1);
    el('zoom-out').onclick = () => handleZoom(-1);
    chartWrap.addEventListener('wheel', e => { e.preventDefault(); handleZoom(e.deltaY < 0 ? 1 : -1); }, { passive: false });
    const startPan = (x) => { state.pan.isPanning = true; state.pan.startX = x; state.pan.startOffset = state.view.offset; };
    const movePan = (x) => { if (!state.pan.isPanning) return; const dx = x - state.pan.startX; const barWidth = chartWrap.clientWidth / state.view.barsInView; state.view.offset = state.pan.startOffset - dx / barWidth; clampOffset(); draw(); };
    const endPan = () => { state.pan.isPanning = false; };
    chartWrap.addEventListener('mousedown', e => startPan(e.clientX));
    chartWrap.addEventListener('mousemove', e => movePan(e.clientX));
    chartWrap.addEventListener('mouseup', endPan);
    chartWrap.addEventListener('mouseleave', endPan);
    chartWrap.addEventListener('touchstart', e => startPan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchmove', e => movePan(e.touches[0].clientX), { passive: true });
    chartWrap.addEventListener('touchend', endPan);
}
function handleZoom(direction) {
    const oldBarsInView = state.view.barsInView;
    const newBarsInView = direction > 0 ? Math.max(CONFIG.minBarsInView, oldBarsInView / 1.5) : Math.min(CONFIG.maxBarsInView, oldBarsInView * 1.5);
    const centerBar = state.view.offset + oldBarsInView / 2;
    state.view.offset = centerBar - newBarsInView / 2;
    state.view.barsInView = newBarsInView;
    clampOffset();
    draw();
}
function clampOffset() {
    state.view.offset = Math.max(0, Math.min(state.view.offset, state.currentBarIndex - state.view.barsInView / 2));
}

</script>
</body>
</html>
